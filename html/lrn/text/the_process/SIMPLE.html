<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>SIMPLE SIMPLE</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://razafy.com/css/styling.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#onja-wave-a-minimalistic-programming-methodology"
id="toc-onja-wave-a-minimalistic-programming-methodology">Onja ⋰⋱⋰⋱⋰⋯
(Wave) – A Minimalistic Programming Methodology</a>
<ul>
<li><a href="#context" id="toc-context">Context</a></li>
<li><a href="#introducing-the-wave-onja"
id="toc-introducing-the-wave-onja">Introducing The Wave (Onja 〜 )
⋰⋱⋰⋱⋰</a></li>
<li><a href="#the-wave" id="toc-the-wave">The wave</a></li>
<li><a href="#running-example-the-simple-warehouse"
id="toc-running-example-the-simple-warehouse">Running Example: The
Simple Warehouse</a></li>
</ul></li>
</ul>
</nav>
<div class="bg_onja">

</div>
<div class="navbar">
<a class="openbtn" onclick="openNav()">☰</a>
</div>
<main>
<p>⇦ <a href="../../../../index.html">home</a> - <a
href="../../index.html">lerina</a> - <a href="../index.html">texts</a> -
<a href="./index.html">the process</a></p>
<h1 id="onja-wave-a-minimalistic-programming-methodology">Onja ⋰⋱⋰⋱⋰⋯
(Wave) – A Minimalistic Programming Methodology</h1>
<!-- ↝  U+219D -->
<h2 id="context">Context</h2>
<p>This text is inspired by <a
href="http://wrigstad.com/ioopm18/simple.html" target="_blank">SIMPLE: A
Programming Methodology</a> by Tobias Wrigstad, a Professor in Computing
Science at <a href="http://www.uu.se/" target="_blank">Uppsala
University</a>.</p>
<p>It also draws from structured programming ideas already in usage back
in the 70’s and best exposed by Dolores M. Etter in Problem solving with
structured FORTRAN 77 (The Benjamin/Cummings Pub 1984) and Engineering
Problem Solving with C.</p>
<p><strong>Problem-Solving process or methodology</strong></p>
<p>Etter stipulates a five point process to solve problems involving the
a computer:</p>
<p>The process or methodology for problem solving has the following five
steps:</p>
<ol type="1">
<li>State the problem clearly.</li>
<li>Describe the input and output information.</li>
<li>Work the problem by hand (or with a calculator) for a simple set of
data.</li>
<li>Develop a solution and convert it to a computer program.</li>
<li>Test the solution with a variety of data.</li>
</ol>
<p><a href="https://archive.org/details/problemsolvingwi0000ette"
target="_blank">source: Dolores M. Etter in Problem solving with
structured FORTRAN 77</a></p>
<p>Key Steps for Problem Solving</p>
<ol type="1">
<li>Define your problem</li>
<li>Make sure you fully understand the problem</li>
<li>Break the problem down into small and manageable pieces</li>
<li>Go as deep as you can, until you can get to easy (yes or no)
questions</li>
<li>Work your way from the bottom until the problem is solved</li>
<li>Recognise some problems are completely out of your control and
that’s ok.</li>
</ol>
<p><a href="https://www.youtube.com/watch?v=x77-gT8bWLo"
target="_blank">source: Problem Solve Like a Computer Programmer | Kyle
Smyth | TEDxRPLCentralLibrary</a></p>
<p><strong>Programming methodology</strong></p>
<p>Wrigstad lays out a Ten Steps system he calls “SIMPLE”</p>
<ol type="1">
<li>Start with a high-level work breakdown structure<br />
Mine your specification for data (nouns) and actions (verbs –
behaviour/functions). Make simple drawings, e.g., mindmaps, to record
your insights. Making things look easy is almost always good.</li>
<li>Write code to test the validity of your thinking<br />
…not to drive the thinking! Thinking should invariably come before
coding, especially thinking about how you check that your thinking is
valid.</li>
<li>Always have a working program<br />
In combination with cheating, this usually means inserting dummy
functions.</li>
<li>Compile after every change<br />
Fix errors now, not later. Fix errors one by one. Fix errors in the
order they were printed. Take time to actually read the compiler message
so you know you are fixing the right thing.</li>
<li>Run the program “all the time” to spot errors<br />
This requires always working code – preferably in combination with
automated test that don’t involve ocular inspection, etc.</li>
<li>Recursively break your problems up into smaller sub problems<br />
Only start solving problems when they start feeling easy. Make a task
for each problem or subproblem to put on the stack, take tasks from the
stack in a reasonable order (preferably easiest first); when the stack
is empty – you are done!</li>
<li>Break each task up into increments and start with the easy
ones<br />
Generate new tasks to put on the stack as you go. If suitable, start
with a straight-line version (without any if-statements). When the
straight-line version works add conditionals, one by one. Start with the
most basic or the most insteresting cases. When you are writing a loop,
do the above steps first and add the looping step last.</li>
<li>Whenever you run the risk of getting stuck, cheat<br />
Don’t forget to push new tasks on the stack that undoes the cheating,
later. This records the cheat, which is great.</li>
<li>Use dodging to help breaking complex cases up into several less
complex ones<br />
Don’t forget to push new tasks on the stack that undoes the dodge,
later. This records the dodge, which is great.</li>
<li>Alternate between thinking, coding and refactoring
<ul>
<li>thinking – not so much that you get stuck, though,</li>
<li>coding – but never without first thinking about what to code, and
occasionally</li>
<li>refactoring – especially to address your cheats and dodges.</li>
</ul></li>
</ol>
<p>[<a href="http://wrigstad.com/ioopm18/simple.html"
target="_blank">source: SIMPLE _ A Programming Methodology</a></p>
<p><strong>TDD</strong></p>
<p>There are 5 steps in the TDD flow:</p>
<ol type="1">
<li>Read, understand, and process the feature or bug request.</li>
<li>Translate the requirement by writing a unit test. The unit test will
run and fail as no code is implemented yet.</li>
<li>Write and implement the code that fulfills the requirement. Run all
tests and they should pass, if not repeat this step.</li>
<li>Clean up your code by refactoring.</li>
<li>Rinse, lather and repeat.</li>
</ol>
<p><a
href="https://developer.ibm.com/articles/5-steps-of-test-driven-development/"
target="_blank">source: 5 steps of test-driven development</a></p>
<p>REM: every simgle point of TTD has been turned into a business</p>
<ol type="1">
<li>… Tools, books and seminars about Group work and software for
ticketing, bug tracking …</li>
<li>… Books &amp; seminars about the benefits of tests.</li>
<li>… Tools &amp; seminars about Writing tests.</li>
<li>… Books &amp; seminars about Clean code and refactoring.</li>
<li>… Books &amp; seminars about CI/CD and devops.</li>
</ol>
<p><strong>REACTO</strong></p>
<ol type="1">
<li>Repeat: make sure you do understand the problem.</li>
<li>Example: get insights by doing examples</li>
<li>Approach: come up with your approach(es) to the problem (brute force
first)</li>
<li>Code: write the code for your chosen approach</li>
<li>Testing: pass the testcases</li>
<li>Optimize: optimize the complexities (time and space) of your
algorithm</li>
</ol>
<p><a href="https://www.youtube.com/watch?v=DIR_rxusO8Q"
target="_blank">source: Whiteboard Coding Interviews: A 6 Step Process
to Solve Any Problem</a></p>
<p><strong>Function Design Recipe</strong> UofT</p>
<p><strong>Js recipe</strong> find it</p>
<p><strong>ALSO of NOTE</strong></p>
<p><a href="https://www.youtube.com/watch?v=QOjTJAFyNrU"
target="_blank">How to Solve a Problem in Four Steps: The IDEA
Model</a><br />
<a href="https://www.youtube.com/watch?v=UFc-RPbq8kg"
target="_blank">Problem-Solving for Developers - A Beginner’s
Guide</a><br />
<a href="" target="_blank"></a><br />
<a href="" target="_blank"></a><br />
<a href="" target="_blank"></a></p>
<h2 id="introducing-the-wave-onja">Introducing The Wave (Onja 〜 )
⋰⋱⋰⋱⋰</h2>
<!-- U+301C 〜  U+22F1 ⋱  U+22F0 ⋰ 
≋ U+224B  
❀ (U+2740)  
⥵  U+2975  
-->
<!--
"Simplicity is a great virtue   
but it requires hard work to achieve it   
and education to appreciate it.   
And to make matters worse: complexity sells better."  
_ [Edsger Dijkstra](https://www.goodreads.com/quotes/215637-simplicity-is-a-great-virtue-but-it-requires-hard-work){target=_blank}
-->
<p>There is no clear cut between programming steps accumulated over
time. More importantly, programming in real life seem to blend these way
of aproching the actual practice of writing software.</p>
<p>Etter’s Problem-Solving with a computer program solution and
Wrigstad’s SIMPL Programming Methodology.</p>
<p>Dolores M. Etter’s 5 stage process can be can seen as the high-level
view of tackling Problems Opportunities or Challenges. This high-level
view can be subdivided into <code>Understanding the Problem</code> and
<code>Validate the Solution</code></p>
<p>Understanding the Problem:</p>
<ol type="1">
<li>State the problem clearly.</li>
<li>Describe the input and output information.</li>
<li>Work the problem by hand (or with a calculator) for a simple set of
data.</li>
</ol>
<p>Validate the Solution:</p>
<ol start="4" type="1">
<li>Develop a solution and convert it to a computer program.</li>
<li>Test the solution with a variety of data</li>
</ol>
<p>And the 10 rules may be seen as the low-level expression of what
actually goes through the mind of a programmer as software is
written.</p>
<p><strong>I Principles</strong></p>
<ol type="1">
<li>KISS (keep it small and straightforward). Think Big _ in
<strong>small steps</strong>.</li>
<li>TDD stands for <strong>Thinking</strong> Driven development<br />
</li>
<li>BDD stands for <strong>Build</strong> Driven deployment</li>
</ol>
<p><strong>II Precepts</strong></p>
<ul>
<li>Break it down<br />
</li>
<li>Validate
<ul>
<li>test assumptions and hypothesis</li>
<li>test your thinking with code</li>
</ul></li>
<li>Never end in a Broken state.</li>
</ul>
<p><strong>III Rules for coding</strong></p>
<ul>
<li>you must test working build</li>
<li>You can only commit working builds</li>
<li>Breakdown Tasks until there is only one Item per sub-tasks</li>
<li>Maintain the flow
<ul>
<li>Avoid stoping by temporarly subtituting complicated tasks with a
simpler version</li>
<li>use <code>props</code> and <code>stand-ins</code> until the real
think can take over the task</li>
</ul></li>
<li>Write your thoughs as comments or pseudo-code</li>
<li>Never stop with a Broken build.</li>
</ul>
<p><strong>IV Rules for design</strong></p>
<ul>
<li>Write imperatively first. Then refactor into a functional
style.</li>
<li>See thing through three point of views
<ul>
<li>Data - Input - Output - processing (Procedural)</li>
<li>Noun - Verbs - Attributes (Objects)</li>
<li>Data - Computation - Actions (Fuctional)</li>
</ul></li>
<li>Favor push over pull when it comes to Data.</li>
<li>Favor decomposition and composition at all times.</li>
</ul>
<hr />
<p><strong>Keep the tempo</strong></p>
<p>Alternate between::</p>
<pre><code>`thinking` and `validating`
`coding` and `verifying`</code></pre>
<p>Think a little: not so much that you get stuck in analysis
paralysis.<br />
Validate a little: Just enough tries or code to validate the
thinking.<br />
_ Tobias Wrigstad</p>
<p>The Onja ⋰⋱⋰⋯ distiles these rules and stages into a rythmic wave
like software writting process one can condense into
<sub><code>t.h.i.n.k. a little</code></sub>⋰<sup><code>c.o.d.e. a little</code></sup>⋱⋰⋯</p>
<h2 id="the-wave">The wave</h2>
<p>Its not a cycle. Its a three stages wave rippling through the
flow</p>
<ul>
<li>Trough: Think: not so much that you get stuck in analysis
paralysis.</li>
<li>base: Validate</li>
<li>Crest: unbroken idea or code</li>
</ul>
<pre><code>C.o.d.e.   --------**------------------**------------------**----------------***-
|                *    *              *    *              *    *            *    
Verify     ----*--------*----------*--------*----------*--------*--------*-------
|            *            *      *            *      *            *    *            
T.h.i.n.k. *----------------**-*----------------**-*----------------**-----------</code></pre>
<ul>
<li>T.h.i.n.k. a little Understand and Organize</li>
</ul>
<p><code>T</code>urn<br />
<code>H</code>ypothesis<br />
<code>I</code>nto<br />
<code>N</code>imble<br />
<code>K</code>ickstarters</p>
<ul>
<li>C.o.d.e. a little Try and Verify</li>
</ul>
<p><code>C</code>oncise<br />
<code>O</code>utput<br />
<code>D</code>irectly<br />
<code>E</code>valuated</p>
<h3 id="t.h.i.n.k.-a-little">T.h.i.n.k. a little</h3>
<ul>
<li><p>What is the quest? What is the desired final result? This is your
ultimate output.</p>
<ul>
<li>That is last step in a chain of results to satisfy or complete the
quest.</li>
<li>Define the scope of the project.</li>
</ul></li>
<li><p>What are you starting with? What are the available the
inputs.</p></li>
<li><p>What is missing to get from those initial input to the final
output.</p></li>
</ul>
<h3 id="c.o.d.e.-a-little">C.o.d.e. a little</h3>
<ul>
<li><p>Validate</p></li>
<li><p>Concretize your thinking or code.</p></li>
<li><p>Verify</p></li>
</ul>
<!-- 
Think, Verify your thinking, concretize, verify your implementation, think ...

longitudinal progress (side to side though the flow of time and working build delivered)  
transverse (up and down) phases think, verify (manual walkthrough, automated tests, code that validate the thinking), concretize (task breakdown, working build, ...) 

The point is to be as Still as possible. The shorter wavelength and the smaller the wave height the flatter and managable our activity will be.
The apparent Cerelity hit due to short wavelength is offset though sustainable high frequency.

hurdles
you will require a good understanding of the algorithms and techniques you intend to implement.

-->
<p>⌌ ———————– ⌍ <!-- U+230C U+230D --><br />
⌨ Practice time <!-- U+2328 --><br />
⌎ ———————– ⌏ <!-- U+230E U+230F --></p>
<p>https://www.geeksforgeeks.org/how-to-approach-a-coding-problem/</p>
<h2 id="running-example-the-simple-warehouse">Running Example: The
Simple Warehouse</h2>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>The simple warehouse program is an information system for managing
the contents of a storage facility for different kinds of wares.<br />
Every ware in the warehouse has a name, a description, a storage
location, a pricetag, information about the number of items of the
particular ware stored in the warehouse, and the cost of each
item.<br />
A storage location is a “section” (a single letter a-z), plus a shelf
(an integer).</p>
<p>The simple warehouse program manages a database of wares and supports
the following operations:</p>
<ul>
<li><code>A</code>dding a ware</li>
<li><code>R</code>emoving a ware</li>
<li><code>E</code>diting the information about a ware</li>
<li><code>P</code>rinting the information for a specific ware</li>
<li><code>L</code>isting all wares in the database</li>
<li><code>U</code>ndoing the last action</li>
<li><code>Q</code>uitting the program</li>
</ul>
<p>When starting the program, the user is presented with the main menu
with the above alternatives and picks a choice by entering the first
letter of each alternative, i.e., |<code>A</code>|, |<code>R</code>|,
|<code>E</code>|, |<code>P</code>|, |<code>L</code>|, |<code>U</code>|,
or |<code>Q</code>|.</p>
<p>When choosing to quit, the user is prompted with a yes/no question:
do you really want to quit? If the answer is |Y|, the program exits. If
the answer is |N|, the program displays the main menu again. If the
answer is anything other than |Y| or |N|, an error message is printed
and the question repeated.</p>
<p>When choosing to add a ware, the user is prompted with five
consecutive dialogues asking her to enter the required information for a
ware:</p>
<ul>
<li>Name</li>
<li>Description</li>
<li>Storage location</li>
<li>Price</li>
<li>Amount</li>
</ul>
<p>The program then displays the information back to the user and asks
whether this is correct or not. The user has three options:</p>
<ul>
<li>Edit the information</li>
<li>Save the information</li>
<li>Abort</li>
</ul>
<p>The choice is again indicated by entering the first character of each
option. The first alternative allows the user to re-enter one piece of
the required information for a ware after which the editer ware is
displayed again with the same question as above. The save alternative
saves the information to the database and then returns to the main menu.
The abort alternative returns to the main menu without saving.</p>
<p>The rest of the actions on the main menu should be fairly
self-explanatory.</p>
<h3 id="the-minimum-viable-product-was-defined-in-abstract-terms">The
minimum viable product was defined in abstract terms</h3>
<h3 id="specific-required-features">Specific required features</h3>
<h3 id="the-rhythmic-wave">The rhythmic wave</h3>
<p>stages of building our project: • Analyzing the problem domain •
Modeling system behavior • Building the tokenizer • Building the parser
• Building the evaluator • Dealing with errors • Building a command-line
application</p>
</main>
<footer>
<a href="https://github.com/lerina" target="_blank" title="github"><img
src="https://razafy.com/img/github32px.png" class="link glow"
alt="github" /> </a>
</footer>
<script src="https://razafy.com/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);

let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../../index.html">lerina</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
</body>
</html>
