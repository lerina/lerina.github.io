<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>SIMPLE SIMPLE</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://razafy.com/css/styling.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#onja-wave-a-minimalistic-programming-methodology"
id="toc-onja-wave-a-minimalistic-programming-methodology">Onja ⋰⋱⋰⋱⋰⋯
(Wave) – A Minimalistic Programming Methodology</a>
<ul>
<li><a href="#context" id="toc-context">Context</a></li>
<li><a href="#introducing-the-wave-onja"
id="toc-introducing-the-wave-onja">Introducing The Wave (Onja 〜 )
⋰⋱⋰⋱⋰</a></li>
</ul></li>
</ul>
</nav>
<div class="bg_onja">

</div>
<div class="navbar">
<a class="openbtn" onclick="openNav()">☰</a>
</div>
<main>
<p>⇦ <a href="../../../../index.html">home</a> - <a
href="../../index.html">lerina</a> - <a href="../index.html">texts</a> -
<a href="./index.html">the process</a></p>
<h1 id="onja-wave-a-minimalistic-programming-methodology">Onja ⋰⋱⋰⋱⋰⋯
(Wave) – A Minimalistic Programming Methodology</h1>
<blockquote>
<p>Beautiful Code</p>
</blockquote>
<pre><code>We ascribe `beauty` to that which is simple,
which has no superfluous parts;
    which exaclty answers its end,
    which stands related to all things,
    which is the mean of all extremes.
    
    _ Ralph Waldo Emerson, _The conduct of life_</code></pre>
<!-- ↝  U+219D -->
<h2 id="context">Context</h2>
<p>This text is inspired by <a
href="http://wrigstad.com/ioopm18/simple.html" target="_blank">SIMPLE: A
Programming Methodology</a> by Tobias Wrigstad, a Professor in Computing
Science at <a href="http://www.uu.se/" target="_blank">Uppsala
University</a>.</p>
<p>It also draws from structured programming ideas already in usage back
in the 70’s and best exposed by Dolores M. Etter in Problem solving with
structured FORTRAN 77 (The Benjamin/Cummings Pub 1984) and Engineering
Problem Solving with C.</p>
<p><strong>Problem-Solving process or methodology</strong></p>
<p>Etter stipulates a five point process to solve problems involving the
a computer:</p>
<p>The process or methodology for problem solving has the following five
steps:</p>
<ol type="1">
<li>State the problem clearly.</li>
<li>Describe the input and output information.</li>
<li>Work the problem by hand (or with a calculator) for a simple set of
data.</li>
<li>Develop a solution and convert it to a computer program.</li>
<li>Test the solution with a variety of data.</li>
</ol>
<p><a href="https://archive.org/details/problemsolvingwi0000ette"
target="_blank">source: Dolores M. Etter in Problem solving with
structured FORTRAN 77</a></p>
<p>Key Steps for Problem Solving</p>
<ol type="1">
<li>Define your problem</li>
<li>Make sure you fully understand the problem</li>
<li>Break the problem down into small and manageable pieces</li>
<li>Go as deep as you can, until you can get to easy (yes or no)
questions</li>
<li>Work your way from the bottom until the problem is solved</li>
<li>Recognise some problems are completely out of your control and
that’s ok.</li>
</ol>
<p><a href="https://www.youtube.com/watch?v=x77-gT8bWLo"
target="_blank">source: Problem Solve Like a Computer Programmer | Kyle
Smyth | TEDxRPLCentralLibrary</a></p>
<p><strong>Programming methodology</strong></p>
<p>Wrigstad lays out a Ten Steps system he calls “SIMPLE”</p>
<ol type="1">
<li>Start with a high-level work breakdown structure<br />
Mine your specification for data (nouns) and actions (verbs –
behaviour/functions). Make simple drawings, e.g., mindmaps, to record
your insights. Making things look easy is almost always good.</li>
<li>Write code to test the validity of your thinking<br />
…not to drive the thinking! Thinking should invariably come before
coding, especially thinking about how you check that your thinking is
valid.</li>
<li>Always have a working program<br />
In combination with cheating, this usually means inserting dummy
functions.</li>
<li>Compile after every change<br />
Fix errors now, not later. Fix errors one by one. Fix errors in the
order they were printed. Take time to actually read the compiler message
so you know you are fixing the right thing.</li>
<li>Run the program “all the time” to spot errors<br />
This requires always working code – preferably in combination with
automated test that don’t involve ocular inspection, etc.</li>
<li>Recursively break your problems up into smaller sub problems<br />
Only start solving problems when they start feeling easy. Make a task
for each problem or subproblem to put on the stack, take tasks from the
stack in a reasonable order (preferably easiest first); when the stack
is empty – you are done!</li>
<li>Break each task up into increments and start with the easy
ones<br />
Generate new tasks to put on the stack as you go. If suitable, start
with a straight-line version (without any if-statements). When the
straight-line version works add conditionals, one by one. Start with the
most basic or the most insteresting cases. When you are writing a loop,
do the above steps first and add the looping step last.</li>
<li>Whenever you run the risk of getting stuck, cheat<br />
Don’t forget to push new tasks on the stack that undoes the cheating,
later. This records the cheat, which is great.</li>
<li>Use dodging to help breaking complex cases up into several less
complex ones<br />
Don’t forget to push new tasks on the stack that undoes the dodge,
later. This records the dodge, which is great.</li>
<li>Alternate between thinking, coding and refactoring
<ul>
<li>thinking – not so much that you get stuck, though,</li>
<li>coding – but never without first thinking about what to code, and
occasionally</li>
<li>refactoring – especially to address your cheats and dodges.</li>
</ul></li>
</ol>
<p>[<a href="http://wrigstad.com/ioopm18/simple.html"
target="_blank">source: SIMPLE _ A Programming Methodology</a></p>
<p><strong>TDD</strong></p>
<p>There are 5 steps in the TDD flow:</p>
<ol type="1">
<li>Read, understand, and process the feature or bug request.</li>
<li>Translate the requirement by writing a unit test. The unit test will
run and fail as no code is implemented yet.</li>
<li>Write and implement the code that fulfills the requirement. Run all
tests and they should pass, if not repeat this step.</li>
<li>Clean up your code by refactoring.</li>
<li>Rinse, lather and repeat.</li>
</ol>
<p><a
href="https://developer.ibm.com/articles/5-steps-of-test-driven-development/"
target="_blank">source: 5 steps of test-driven development</a></p>
<p>REM: every simgle point of TTD has been turned into a business</p>
<ol type="1">
<li>… Tools, books and seminars about Group work and software for
ticketing, bug tracking …</li>
<li>… Books &amp; seminars about the benefits of tests.</li>
<li>… Tools &amp; seminars about Writing tests.</li>
<li>… Books &amp; seminars about Clean code and refactoring.</li>
<li>… Books &amp; seminars about CI/CD and devops.</li>
</ol>
<p><strong>REACTO</strong></p>
<ol type="1">
<li>Repeat: make sure you do understand the problem.</li>
<li>Example: get insights by doing examples</li>
<li>Approach: come up with your approach(es) to the problem (brute force
first)</li>
<li>Code: write the code for your chosen approach</li>
<li>Testing: pass the testcases</li>
<li>Optimize: optimize the complexities (time and space) of your
algorithm</li>
</ol>
<p><a href="https://www.youtube.com/watch?v=DIR_rxusO8Q"
target="_blank">source: Whiteboard Coding Interviews: A 6 Step Process
to Solve Any Problem</a></p>
<p><strong>Function Design Recipe</strong> UofT</p>
<p><strong>Js recipe</strong> find it</p>
<p><strong>ALSO of NOTE</strong></p>
<p><a href="https://www.youtube.com/watch?v=QOjTJAFyNrU"
target="_blank">How to Solve a Problem in Four Steps: The IDEA
Model</a><br />
<a href="https://www.youtube.com/watch?v=UFc-RPbq8kg"
target="_blank">Problem-Solving for Developers - A Beginner’s
Guide</a><br />
<a href="http://htdp.org/2022-8-7/Book/index.html" target="_blank">How
to Design Programs, Second Edition</a><br />
<a href="https://course.ccs.neu.edu/cs5010sp15/recipe.html"
target="_blank">The Program Design Recipe</a><br />
<a href="" target="_blank"></a></p>
<h2 id="introducing-the-wave-onja">Introducing The Wave (Onja 〜 )
⋰⋱⋰⋱⋰</h2>
<p>There is no clear cut between programming steps accumulated over
time. In real life tend to blend these ways of approaching the actual
practice of writing software. Through time these methods and practices
have been either made systematic or rendered implicit.</p>
<p>In developing Onja, we took the <em>ancient</em> but still very
pertinant 5-points “Problem-Solving with a computer program solution” as
exposed by D. M. Etter and the most recent SIMPL Programming Methodology
described by Wrigstad.</p>
<p>Dolores M. Etter’s 5 stage process can be can seen as the high-level
view of tackling Problems, Opportunities or Challenges (POC). This
high-level view can be subdivided into
<code>Understanding the Problem</code> and
<code>Validate the Solution</code></p>
<p>Understanding the Problem:</p>
<ol type="1">
<li>State the problem clearly.</li>
<li>Describe the input and output information.</li>
<li>Work the problem by hand (or with a calculator) for a simple set of
data.</li>
</ol>
<p>Validate the Solution:</p>
<ol start="4" type="1">
<li>Develop a solution and convert it to a computer program.</li>
<li>Test the solution with a variety of data</li>
</ol>
<p>Wrigstad’s “10 rules” may be seen as the low-level expression of what
actually goes through the mind of a programmer as software is
written.</p>
<p><strong>I Principles</strong></p>
<ol type="1">
<li>KISS (keep it small and straightforward). Think Big _ in
<strong>small steps</strong>.</li>
<li>TDD stands for <strong>Thinking</strong> Driven development<br />
</li>
<li>BDD stands for <strong>Build</strong> Driven deployment</li>
</ol>
<p><strong>II Precepts</strong></p>
<ul>
<li>Breakdown Quests or Tasks until there is only one Item per
sub-tasks</li>
<li>Validate
<ul>
<li>test assumptions and hypothesis</li>
<li>test your thinking with code</li>
</ul></li>
<li>Never stop in a Broken state or build.</li>
</ul>
<p><strong>III Rules for coding</strong></p>
<ul>
<li>You can only commit tested working builds</li>
<li>Maintain the flow
<ul>
<li>Avoid stoping by temporarly subtituting complicated tasks with a
simpler version</li>
<li>use <code>props</code> and <code>stand-ins</code> until the real
think can take over the task</li>
</ul></li>
<li>Write your thoughts as comments or pseudo-code</li>
</ul>
<p><strong>IV Rules for design</strong></p>
<ul>
<li>Write imperatively first. Then refactor into a functional
style.</li>
<li>See thing through three point of views
<ul>
<li>Data - Input - Output - processing (Procedural)</li>
<li>Noun - Verbs - Attributes (Objects)</li>
<li>Data - Computation - Actions (Fuctional)</li>
</ul></li>
<li>Favor push over pull when it comes to Data.</li>
<li>Favor decomposition and composition at all times.</li>
</ul>
<p><strong>V Keep the tempo</strong></p>
<p>Alternate between::</p>
<pre><code>`thinking` and `validating`
`coding` and `verifying`</code></pre>
<p>Think a little: not so much that you get stuck in analysis
paralysis.<br />
Validate a little: Just enough tries or code to validate the
thinking.<br />
_ Tobias Wrigstad</p>
<p>The Onja ⋰⋱⋰⋯ distiles these rules and stages into a rythmic wave
like software writting process one can condense into
<sub><code>t.h.i.n.k. a little</code></sub>⋰<sup><code>c.o.d.e. a little</code></sup>⋱⋰⋯</p>
<button>
<a href="./onja01.html">NEXT: The wave Metaphor</a>
</button>
</main>
<footer>
<a href="https://github.com/lerina" target="_blank" title="github"><img
src="https://razafy.com/img/github32px.png" class="link glow"
alt="github" /></a>
</footer>
<script src="https://razafy.com/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);

let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../../index.html">lerina</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
</body>
</html>
