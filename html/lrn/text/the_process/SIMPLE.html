<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>SIMPLE</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://razafy.com/css/styling.css" />
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#simple-a-minimalistic-programming-methodology">SIMPLE – A Minimalistic Programming Methodology</a><ul>
<li><a href="#simple-a-flexible-structured-approach-to-code-implemention">1 SIMPLE: A flexible structured approach to code implemention</a></li>
<li><a href="#a-summary-of-simple-in-ten-steps">A Summary of SIMPLE in Ten Steps</a></li>
<li><a href="#running-example-the-simple-warehouse">2 Running Example: The Simple Warehouse</a></li>
<li><a href="#the-simple-approach">3 The SIMPLE Approach</a><ul>
<li><a href="#step-1.-think-a-little.">3.1 Step 1. Think a little.</a></li>
<li><a href="#step-2-code-a-little.">3.2 Step 2: Code a little.</a></li>
<li><a href="#step-3-think-a-little-more.">3.3 Step 3: Think a little more.</a></li>
<li><a href="#step-4-code-a-little-more.">3.4 Step 4: Code a little more.</a></li>
<li><a href="#intermission-developing-in-increments">3.5 Intermission: Developing in Increments</a></li>
<li><a href="#step-5-remove-the-cheats">3.6 Step 5: Remove the Cheats</a></li>
<li><a href="#step-6-think-a-little-code-a-little-seems-familiar">3.7 Step 6: Think a little – Code a little (Seems familiar?)</a></li>
<li><a href="#step-7-think-a-little-code-a-little-again">3.8 Step 7: Think a little – Code a little (again)</a></li>
<li><a href="#step-8-think-a-little-code-a-little">3.9 Step 8: Think a Little – Code a Little</a></li>
<li><a href="#step-9-and-beyond">3.10 Step 9, and beyond</a></li>
<li><a href="#summary-and-conclusions">3.11 Summary and Conclusions</a></li>
</ul></li>
<li><a href="#a-summary-of-simple-in-ten-steps-1">4 A Summary of SIMPLE in Ten Steps</a></li>
<li><a href="#tickets-tasks-and-post-it-stacks">5 Tickets, Tasks and Post-it Stacks</a></li>
<li><a href="#the-three-rules-of-stubbing">6 The Three Rules of Stubbing</a></li>
<li><a href="#dodging-not-quite-stubbing">7 Dodging: Not Quite Stubbing</a></li>
</ul></li>
</ul>
</nav>
<p>⇦ <a href="../../../../index.html">home</a> - <a href="../../index.html">lerina</a> - <a href="../index.html">texts</a> - <a href="./index.html">the process</a></p>
<h1 id="simple-a-minimalistic-programming-methodology">SIMPLE – A Minimalistic Programming Methodology</h1>
<p>This text is an adaptation of this wonderful page <a href="http://wrigstad.com/ioopm18/simple.html">SIMPLE: A Programming Methodology</a> by Tobias Wrigstad, a Professor in Computing Science at <a href="http://www.uu.se/">Uppsala University</a>. I’ve been trying to express what <a href="https://www.youtube.com/watch?v=xPecMsFmEm4">software writers</a> do. We are both <a href="https://en.wikipedia.org/wiki/Logic">logician</a> and <a href="https://www.youtube.com/watch?v=-jRREn6ifEQ">poets</a>. We are also <a href="http://fineartdrawinglca.blogspot.com/2016/07/iterative-drawing_11.html">iterative artists</a></p>
<p>I replaced the term cheating used in the original text and main source of inspiration for this text with the more widespread usage “stubbing” as described here <a href="https://courses.engr.illinois.edu/cs225/sp2019/guides/stub-out/">The purpose of ‘stubbing out’ a function</a></p>
<h2 id="simple-a-flexible-structured-approach-to-code-implemention">1 SIMPLE: A flexible structured approach to code implemention</h2>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>In a nutshell SIMPLE dictates that you:</p>
<ul>
<li>Use the specification in a structured manner to do both function design and data design.</li>
<li>Work in an incremental fashion, by solving many simple problems instead of few complex ones.</li>
<li>Always have a working program that you can run and test.</li>
<li>Compile continuously.</li>
<li>Test continuously, preferably automated but at least manually.</li>
<li>Write straight-line code first, before complicated branches and loops.</li>
<li>Use tricks – stubbing and dodging – to keep programming simple, and push problems into the future.</li>
</ul>
<p>takeaway:</p>
<p>function design and data design<br />
incremental progress Between each incrementation the code can run and passes its tests</p>
<h2 id="a-summary-of-simple-in-ten-steps">A Summary of SIMPLE in Ten Steps</h2>
<p>Start with a high-level work breakdown structure - Textual-Analysis<br />
Mine your specification for data (nouns) and actions (verbs – behaviour/functions). Make simple drawings, e.g., mind-maps, to record your insights. Making things look easy is almost always good. - Spikes Write code to test the validity of your thinking …not to drive the thinking! Thinking should invariably come before coding, especially thinking about how you check that your thinking is valid. - The one rule Always have a working program. In combination with stubs and temping, this usually means inserting dummy functions. Compile after every change - Refactor early Fix errors now, not later. Fix errors one by one. Fix errors in the order they were printed. Take time to actually read the compiler message so you know you are fixing the right thing. -The one Rule again Run the program “all the time” to spot errors This requires always working code – preferably in combination with automated test that don’t involve ocular inspection, etc. - The main tool (Simplify) Recursively break your problems up into smaller sub problems Only start solving problems when they start feeling easy. Make a task for each problem or sub-problem to put on the stack, take tasks from the stack in a reasonable order (preferably easiest first); when the stack is empty – you are done! Break each task up into increments and start with the easy ones Generate new tasks to put on the stack as you go. If suitable, start with a straight-line version (without any if-statements). When the straight-line version works add conditionals, one by one. Start with the most basic or the most interesting cases. When you are writing a loop, do the above steps first and add the looping step last. Whenever you run the risk of getting stuck, Stub, Temp, mock and fake Don’t forget to push new tasks on the stack that undoes the subtitution, later. This records the subs, which is great. - Temping Use Temping to help breaking complex cases up into several less complex ones Don’t forget to push new tasks on the stack that undoes the dodge, later. This records the dodge, which is great. Alternate between thinking, coding and refactoring</p>
<pre><code>    thinking – not so much that you get stuck, though,
    coding – but never without first thinking about what to code, and occasionally
    refactoring – especially to address your cheats and dodges (tempTypes)

Refactoring is good to do between larger tasks. Make it a habit to continuously go back and refactor your solutions so that recently gotten insights rub off on older code too. 
Think, code, verify.
CI runs the automated tests.</code></pre>
<h2 id="running-example-the-simple-warehouse">2 Running Example: The Simple Warehouse</h2>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>The simple warehouse program is an information system for managing the contents of a storage facility for different kinds of wares.<br />
Every ware in the warehouse has a name, a description, a storage location, a pricetag, information about the number of items of the particular ware stored in the warehouse, and the cost of each item.<br />
A storage location is a “section” (a single letter a-z), plus a shelf (an integer).</p>
<p>The simple warehouse program manages a database of wares and supports the following operations:</p>
<ul>
<li><code>A</code>dding a ware</li>
<li><code>R</code>emoving a ware</li>
<li><code>E</code>diting the information about a ware</li>
<li><code>P</code>rinting the information for a specific ware</li>
<li><code>L</code>isting all wares in the database</li>
<li><code>U</code>ndoing the last action</li>
<li><code>Q</code>uitting the program</li>
</ul>
<p>When starting the program, the user is presented with the main menu with the above alternatives and picks a choice by entering the first letter of each alternative, i.e., |<code>A</code>|, |<code>R</code>|, |<code>E</code>|, |<code>P</code>|, |<code>L</code>|, |<code>U</code>|, or |<code>Q</code>|.</p>
<p>When choosing to quit, the user is prompted with a yes/no question: do you really want to quit? If the answer is |Y|, the program exits. If the answer is |N|, the program displays the main menu again. If the answer is anything other than |Y| or |N|, an error message is printed and the question repeated.</p>
<p>When choosing to add a ware, the user is prompted with five consecutive dialogues asking her to enter the required information for a ware:</p>
<ul>
<li>Name</li>
<li>Description</li>
<li>Storage location</li>
<li>Price</li>
<li>Amount</li>
</ul>
<p>The program then displays the information back to the user and asks whether this is correct or not. The user has three options:</p>
<ul>
<li>Edit the information</li>
<li>Save the information</li>
<li>Abort</li>
</ul>
<p>The choice is again indicated by entering the first character of each option. The first alternative allows the user to re-enter one piece of the required information for a ware after which the editer ware is displayed again with the same question as above. The save alternative saves the information to the database and then returns to the main menu. The abort alternative returns to the main menu without saving.</p>
<p>The rest of the actions on the main menu should be fairly self-explanatory.</p>
<h2 id="the-simple-approach">3 The SIMPLE Approach</h2>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>The most fundamental principle of SIMPLE is to <strong>always have a working program</strong>.</p>
<p>By a working program is meant a program that compiles without warnings or errors, and runs. In the beginning, the program is not going to do anything useful, which is fine.</p>
<p>The SIMPLE approach is all about adding functions to the program little by little until it suddenly is finished.</p>
<p>By always having a working program, it is easier to test the program, and the most shallow bugs can often be caught by just running the program and spotting the error. Furthermore, working with a program that runs is generally much more humanly rewarding and avoids the scary feeling of “not having anything” for a long while until finally the individual pieces are connected and a program magically appears.</p>
<p><em>I am supposed to write a program. Where do I start?</em></p>
<figure>
<img src="GTY_janet_leigh_kab_150916_12x5_992.jpg" alt="I am supposed to write a program. Where do I start?" /><figcaption>I am supposed to write a program. Where do I start?</figcaption>
</figure>
<p>This is exactly the question SIMPLE is trying to answer. Along with the question, when am I done? We will now proceed by walking through a number of steps, and stopping and recapping once in a while.</p>
<h3 id="step-1.-think-a-little.">3.1 Step 1. Think a little.</h3>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>The most important answer to this question is about where you should <em>not</em> start: don’t start to code (yet)! Before we start to code, we should make sure to understand something more about the program. The goal is to make sure we have a basic understanding of what the program is supposed to accomplish, but not yet care about how it should accomplish it.</p>
<p>To get a feeling for what the program is trying to accomplish, we mine the specification. This means re-reading it, looking for some particular kind of information. To understand the program’s <em>core behaviour</em>, we pay close attention to the verbs and actions. Using a pen to underline or highlight them is not a bad idea.</p>
<p>For concreteness, I am copying in parts of the specification from above, <em>highlighting</em> as I go.</p>
<p>The simple warehouse program is an for … letter a-z), plus a shelf (an integer).</p>
<p>The simple warehouse program manages a database of wares and supports the following operations:</p>
<ol type="1">
<li><strong>Adding</strong> a ware</li>
<li><strong>Removing</strong> a ware</li>
<li><strong>Editing</strong> the information about a ware</li>
<li><strong>Printing</strong> the information for a specific ware</li>
<li><strong>Listing</strong> all wares in the database</li>
<li><strong>Undoing</strong> the last action</li>
<li><strong>Quitting</strong> the program</li>
</ol>
<p>When <strong>starting</strong> the program, the user is <strong>presented</strong> with the <strong>main menu</strong> with the above alternatives and <strong>picks a choice</strong> by entering the <em>first letter</em> of each alternative, i.e., |<code>A</code>|, |<code>R</code>|, |<code>E</code>|, |<code>P</code>|, |<code>L</code>|, |<code>U</code>|, or |<code>Q</code>|.</p>
<p>When <strong>choosing to quit</strong>, the user <strong>is prompted with a yes/no question</strong>: …</p>
<p>Looking at the text above, I have a pretty good overview of what the program is supposed to do at a high-level. Of course, this specification is extremely simple by listing the main menu with a lot of actions, but even if it didn’t, picking the actions probably would not be that much harder.</p>
<p>Now, I take a piece of paper and write these things down. A mindmap <a href="http://en.wikipedia.org/wiki/Mind_map" class="uri">http://en.wikipedia.org/wiki/Mind_map</a> is usually a good way to capture hierarchical structures.</p>
<figure>
<img src="img1.png" alt="Figure 2" /><figcaption>Figure 2</figcaption>
</figure>
<p>Figure 2: Initial mind map of actions in the program</p>
<p>The mind-map tells me what actions that the program should support, but so-far nothing about how they should be implemented. So far, that’s fine.</p>
<p><em>This is what we are doing:</em> We are abstracting and compartmentalising. If we tried to understand the entire system before starting to code, we would probably never start to code, because it is very hard to know when you truly understand something. Some people are good at convincing themselves that they “get it”, regardless of whether it is true or not. Others are good at convincing themselves that they don’t. The key is to not get into a situation where this matters. At least not yet.</p>
<p>What we are going to do is the following: we are going to alternate between thinking a little and coding a little. We are going to think just enough so that we understand what is a plausible next step forward. Then we are going to evaluate whether that was a good step or not by coding. This is good, because coding is a good way to understand sloppily formulated ideas <a href="http://web.media.mit.edu/%7Eminsky/papers/Why%20programming%20is--.html" class="uri">http://web.media.mit.edu/%7Eminsky/papers/Why%20programming%20is--.html</a>. By forcing us to concretise, coding challenges us to understand what it is we understand.</p>
<h3 id="step-2-code-a-little.">3.2 Step 2: Code a little.</h3>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>Following the most fundamental principle of SIMPLE, we start with the minimal working program. If we are using C, we would probably write something like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb2-6" title="6">{</a>
<a class="sourceLine" id="cb2-7" title="7">    puts(<span class="st">&quot;Welcome to my warehouse program!&quot;</span>);</a>
<a class="sourceLine" id="cb2-8" title="8">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb2-9" title="9">}</a></code></pre></div>
<p>We’ll follow each C code snipet</p>
<hr />
<p>with a Rust version:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb3-1" title="1"><span class="co">// main.rs</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb3-4" title="4">   <span class="pp">println!</span>(<span class="st">&quot;Welcome to my warehouse program!&quot;</span>);</a>
<a class="sourceLine" id="cb3-5" title="5"><span class="op">}</span></a></code></pre></div>
<p>This program is pretty much hello world, but it compiles and runs.</p>
<p>Now, we take the actions from the mind-map and turn them into functions. For example, for “add”, we do:</p>
<p>C</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="dt">void</span> add_action(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb4-5" title="5">{</a>
<a class="sourceLine" id="cb4-6" title="6">    puts(<span class="st">&quot;Add action is not implemented yet&quot;</span>);</a>
<a class="sourceLine" id="cb4-7" title="7">}</a></code></pre></div>
<hr />
<p>Rust</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb5-1" title="1"><span class="co">// main.rs </span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">fn</span> add_action() <span class="op">{</span></a>
<a class="sourceLine" id="cb5-4" title="4">   <span class="pp">println!</span>(<span class="st">&quot;Add action is not implemented yet&quot;</span>);</a>
<a class="sourceLine" id="cb5-5" title="5">   <span class="co">//unimplemented!(&quot;Stopping here!&quot;);</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="op">}</span></a></code></pre></div>
<p>And similar functions for all the other actions. We do this in order to have placeholders for code that we are going to write. Again we want to compartmentalise as much as possible: by focusing on just one small thing at a time, each problem is going to not just seem simple, but be simple. And that is one of the secret sauces to success. (More ingredients are coming up later.)</p>
<p>/Between each function you add, compile the program./</p>
<p>Tip</p>
<blockquote>
<p><em>Compile Early. Compile Often.</em></p>
</blockquote>
<p>Unless you are looking for trouble, or are writing live code in front of an audience and are desperately trying to come across as a human compiler, you really want to compile your code all the time.</p>
<p>When you are new to a programming language, make a habit to compile after each edit. After a while, you will be able to go up to a few lines. Then a bit more, etc.</p>
<p>The reason for this is to compartmentalise your errors too! If you write 100 lines of code before you try to compile, you are likely to get 50 errors. Unless you are hardened by experience, this can be an insurmountable and cause you to give up. The nastiest compiler errors always happen in the code you wrote more than one hour ago. Not because you were a worse programmer then, but because it was one hour ago! You probably don’t remember what you were thinking back then, so you have to work hard at retracing your steps. If you try to make sure the code compiles every two minutes, <a href="https://www.theobjectivestandard.com/2013/09/spocks-illogic-the-needs-of-the-many-outweigh-the-needs-of-the-few/">logic dictates</a> that solving these bugs is way way easier. Good programmers likes easy.</p>
<p>Tip</p>
<blockquote>
<p><em>A Note About Compiler Errors</em></p>
</blockquote>
<p>If for some reason you do get a whole page of compiler errors there are four important things to do, two of which are really hard even for a seasoned programmer:</p>
<ul>
<li>Don’t panic!</li>
<li>Read the error messages!</li>
<li>Address the errors <em>one by one</em> and <em>in the order they were printed on the screen</em>.</li>
<li>Recompile all the time, and always after addressing each error.</li>
</ul>
<p>Compilers are usually really bad at printing readable error messages. But you can learn how to read them. It will pay off because 90% of the time, there will be 10 or so errors. Focus on learning those first! (Seasoned programmers often just read the line number information, and jump there to fix the error themselves. This is just stupid, but very human.)</p>
<p>It is also quite common for compilers to become confused by errors earlier in the code. Compilers read like Westerners, i.e., top-down left-right. Often an error on line N cause one or more errors on lines N+X and N+Y, and since the compiler in the general case cannot rule out that the errors are unrelated, it prints all of them. Consequently, if the compiler says you have 10 errors, it is more likely less than 10, sometimes just one. The error that appears closest to your cursor on the prompt after compiling is therefore more likely to be a “faux error” than the first error that the compiler printed. Don’t waste time fixing something that does not need fixing. (Seasoned programmers sometimes get carried away and forget this too.)</p>
<p>Since one error often create “faux errors” later in the code, it is a very good idea to recompile all the time while fixing compile errors. It may be that fixing one error closes all of the remaining ones. Also, it is not uncommon to introduce a new error while you are fixing another one, so recompile often to make sure that the error number goes down steadily.</p>
<h3 id="step-3-think-a-little-more.">3.3 Step 3: Think a little more.</h3>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>We now have a working program that does absolutely nothing. Let’s start adding some functionality to our program following the specification.</p>
<p>The first six action all require either that there is some data in the program, or that we are able to add some data. We haven’t done any data design yet, so if we want to start with these, we should that. However, the last action, quitting, is very simple and does not do much so that is a good starting point.</p>
<p>We now go back to our mind-map and extend the specification of quit.</p>
<figure>
<img src="img2.png" alt="Figure 3" /><figcaption>Figure 3</figcaption>
</figure>
<p>Figure 3: Second mindmap of the program</p>
<p>Re-reading the specification, we now know that triggering quit should enter into a confirmation dialogue, and if the user replies |Y|, then we quit, if |N| we return to the main menu, otherwise repeat the question.</p>
<h3 id="step-4-code-a-little-more.">3.4 Step 4: Code a little more.</h3>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>To keep the program as simple as possible, we are not going to add functionality for choosing an action in the main menu just yet. That’s not needed, because the only thing we are going to implement is quit. So, although it is futile, let’s extend the program so that when we run it, it asks if we want to quit. To this end, we will add a |while| loop that loops forever and that in each turn of the loop asks us whether we want to quit. This will allow us to test both the yes and no answers.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb6-6" title="6">{</a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="cf">while</span> (true)</a>
<a class="sourceLine" id="cb6-8" title="8">    {</a>
<a class="sourceLine" id="cb6-9" title="9">      puts(<span class="st">&quot;Welcome to my warehouse program!&quot;</span>);</a>
<a class="sourceLine" id="cb6-10" title="10"></a>
<a class="sourceLine" id="cb6-11" title="11">      <span class="cf">if</span> (quit_action()) <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb6-12" title="12">    }</a>
<a class="sourceLine" id="cb6-13" title="13">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb6-14" title="14">}</a></code></pre></div>
<hr />
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb7-1" title="1"><span class="co">// main.rs</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">fn</span> main()<span class="op">{</span></a>
<a class="sourceLine" id="cb7-4" title="4">   <span class="pp">println!</span>(<span class="st">&quot;Welcome to my warehouse program!&quot;</span>);</a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6">   <span class="kw">loop</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-7" title="7">      <span class="kw">if</span> quit_action() <span class="op">{</span> <span class="kw">break</span>; <span class="op">}</span> <span class="co">// quit_action()-&gt; bool</span></a>
<a class="sourceLine" id="cb7-8" title="8">   <span class="op">}</span></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>Once this edit is done, we compile and run the program. Just to be sure we did not break anything. But oh, it does! |quit_action()| must first be updated to return a |bool|. We fix this and add a return false; as the default return and also include |stdbool.h| at the top of the file.</p>
<p>Moving on, we now have a function |quit_action()| that looks like this:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="dt">bool</span> quit_action(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb8-5" title="5">{</a>
<a class="sourceLine" id="cb8-6" title="6">    puts(<span class="st">&quot;Quit action is not implemented yet&quot;</span>);</a>
<a class="sourceLine" id="cb8-7" title="7">    <span class="cf">return</span> false;</a>
<a class="sourceLine" id="cb8-8" title="8">}</a></code></pre></div>
<hr />
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb9-1" title="1"><span class="co">//main.rs</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3">   <span class="kw">fn</span> quit_action()-&gt; <span class="dt">bool</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-4" title="4">      <span class="pp">println!</span>(<span class="st">&quot;Quit action is not implemented yet&quot;</span>);</a>
<a class="sourceLine" id="cb9-5" title="5"></a>
<a class="sourceLine" id="cb9-6" title="6">      <span class="cn">false</span></a>
<a class="sourceLine" id="cb9-7" title="7">   <span class="op">}</span></a></code></pre></div>
<p>Our goal now is to implement the behaviour of the specification which was just re-iterated above. We are going to do this in a few small increments. (I will return in a little bit to how to come up with good increments.)</p>
<ul>
<li>Print confirmation question</li>
<li>Read input</li>
<li>Handle |Y| case</li>
<li>Handle |N| case</li>
<li>Handle remaining cases</li>
</ul>
<p>Increment 1 is easy. Just change the existing |puts()|:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="dt">bool</span> quit_action(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb10-5" title="5">{</a>
<a class="sourceLine" id="cb10-6" title="6">    puts(<span class="st">&quot;Do you want to quit? [Y/N]&quot;</span>);</a>
<a class="sourceLine" id="cb10-7" title="7">    <span class="cf">return</span> false;</a>
<a class="sourceLine" id="cb10-8" title="8">}</a></code></pre></div>
<hr />
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb11-1" title="1"><span class="co">//main.rs</span></a>
<a class="sourceLine" id="cb11-2" title="2"></a>
<a class="sourceLine" id="cb11-3" title="3">   <span class="kw">fn</span> quit_action()-&gt; <span class="dt">bool</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-4" title="4">      <span class="pp">println!</span>(<span class="st">&quot;Do you want to quit? [Y/N]&quot;</span>);</a>
<a class="sourceLine" id="cb11-5" title="5"></a>
<a class="sourceLine" id="cb11-6" title="6">      <span class="cn">false</span></a>
<a class="sourceLine" id="cb11-7" title="7">   <span class="op">}</span></a></code></pre></div>
<p>Increment 2 is much harder. It requires us to know how to read input from a user in C. This is actually pretty complicated and there are many opportunities for errors. Therefore, I am going to use one of the best programming tricks ever – I am going to “<em>cheat</em>”. By stubbing, I mean the following: <em>I am going to assume the existence of a function that solves the problem for me.</em> This makes increment 2 really simple:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb12-2" title="2"></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="dt">bool</span> quit_action(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb12-5" title="5">{</a>
<a class="sourceLine" id="cb12-6" title="6">    puts(<span class="st">&quot;Do you want to quit? [Y/N]&quot;</span>);</a>
<a class="sourceLine" id="cb12-7" title="7">    <span class="dt">char</span> input = get_char_input(); <span class="co">// &lt;---- This line was added</span></a>
<a class="sourceLine" id="cb12-8" title="8">    <span class="cf">return</span> false;</a>
<a class="sourceLine" id="cb12-9" title="9">}</a></code></pre></div>
<hr />
<div class="sourceCode" id="cb13"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb13-1" title="1"><span class="co">// main.rs</span></a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3">   <span class="kw">fn</span> quit_action()-&gt; <span class="dt">bool</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb13-4" title="4">      <span class="pp">println!</span>(<span class="st">&quot;Do you want to quit? [Y/N]&quot;</span>);</a>
<a class="sourceLine" id="cb13-5" title="5">      <span class="kw">let</span> input = get_char_input(); <span class="co">// &lt;---- This line was added</span></a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7">      <span class="cn">false</span></a>
<a class="sourceLine" id="cb13-8" title="8">   <span class="op">}</span></a></code></pre></div>
<p><em>You really need to understand that</em> stubbing is one of the best tools in the programming toolbox. You should use it all the time. The first rule of stubbing is this:</p>
<div class="line-block">If you don’t know immediately how to solve a problem,<br />
assume the existence of a function that solves this problem for you,<br />
and call that function.</div>
<p>This is great because usually when you are programming, you are going somewhere and you have a particular control flow <a href="http://en.wikipedia.org/wiki/Control_flow" class="uri">http://en.wikipedia.org/wiki/Control_flow</a> in mind. Getting stuck implementing one step of this flow usually means your train of thought is interrupted and because your mind is now focused on solving the current step, you will have a harder time continuing where you got stuck once you are unstuck.</p>
<p>Note</p>
<p>Aside: This is actually not so different from tricks used by surrealist authors experimenting with automatic text. There a standard trick is to choose a word or a first letter of a word that you revert to whenever your brain gets stuck. Here our actions are slightly more sensible. (At least to some.)</p>
<p>Like we did with the empty action functions from the start, we add a dummy function to the file called |get_char_input()| to stay true to the ideal of always having a working program:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="dt">char</span> get_char_input() <span class="co">// &lt;-- return type derived from the call-site</span></a>
<a class="sourceLine" id="cb14-5" title="5">{</a>
<a class="sourceLine" id="cb14-6" title="6">    <span class="cf">return</span> <span class="ch">&#39;Y&#39;</span>; <span class="co">// &lt;-- a good default because of how increment 3 is specified</span></a>
<a class="sourceLine" id="cb14-7" title="7">}</a></code></pre></div>
<hr />
<div class="sourceCode" id="cb15"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb15-1" title="1"><span class="co">// main.rs</span></a>
<a class="sourceLine" id="cb15-2" title="2"></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="kw">fn</span> get_char_input() -&gt; <span class="dt">String</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb15-4" title="4"></a>
<a class="sourceLine" id="cb15-5" title="5">    <span class="dt">String</span>::new(<span class="st">&quot;Y&quot;</span>)</a>
<a class="sourceLine" id="cb15-6" title="6"><span class="op">}</span></a></code></pre></div>
<p>We can now compile and run our program as a kind of minimal testing.</p>
<p>Back to our increment 3, which is dealing with the base case of the user inputting a |Y|:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb16-2" title="2"></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="dt">bool</span> quit_action(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb16-5" title="5">{</a>
<a class="sourceLine" id="cb16-6" title="6">    puts(<span class="st">&quot;Do you want to quit? [Y/N]&quot;</span>);</a>
<a class="sourceLine" id="cb16-7" title="7">    <span class="dt">char</span> input = get_char_input();</a>
<a class="sourceLine" id="cb16-8" title="8">    <span class="cf">if</span> (input == <span class="ch">&#39;Y&#39;</span>) <span class="cf">return</span> true;</a>
<a class="sourceLine" id="cb16-9" title="9">    <span class="cf">return</span> false;</a>
<a class="sourceLine" id="cb16-10" title="10">}</a></code></pre></div>
<hr />
<div class="sourceCode" id="cb17"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb17-1" title="1"><span class="co">// main.rs</span></a>
<a class="sourceLine" id="cb17-2" title="2"></a>
<a class="sourceLine" id="cb17-3" title="3">   <span class="kw">fn</span> quit_action()-&gt; <span class="dt">bool</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb17-4" title="4">      <span class="pp">println!</span>(<span class="st">&quot;Do you want to quit? [Y/N]&quot;</span>);</a>
<a class="sourceLine" id="cb17-5" title="5">      <span class="kw">let</span> input = get_char_input();</a>
<a class="sourceLine" id="cb17-6" title="6">      </a>
<a class="sourceLine" id="cb17-7" title="7">      <span class="kw">if</span> input == <span class="st">&quot;Y&quot;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb17-8" title="8">        <span class="kw">return</span> <span class="cn">true</span>;</a>
<a class="sourceLine" id="cb17-9" title="9">      <span class="op">}</span></a>
<a class="sourceLine" id="cb17-10" title="10"></a>
<a class="sourceLine" id="cb17-11" title="11">      <span class="cn">false</span></a>
<a class="sourceLine" id="cb17-12" title="12">   <span class="op">}</span></a></code></pre></div>
<p>Increment 4 is dealing with the case of the user inputting a |N|. Turns out it is already handled, as the function returns |false| as a default. This leaves us with increment 5, which is the user replying with something other than |Y| or |N|.</p>
<p>The reason why I left this case until now is because this is the case that removes some of the simplicity of the code we have been working on so far: we must now add a loop to this function to be able to repeat the question.</p>
<p>We start by wrapping the entire function inside a |while|. The exit condition of the |while| is that input is either |Y| or |N|. Otherwise, the specification dictates`, an error message shall be printed and the question shall be asked again indefinitely. Here is a first attempt at doing this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb18-2" title="2"></a>
<a class="sourceLine" id="cb18-3" title="3"><span class="dt">bool</span> quit_action(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb18-4" title="4">{</a>
<a class="sourceLine" id="cb18-5" title="5">    <span class="cf">while</span> (true)</a>
<a class="sourceLine" id="cb18-6" title="6">    {</a>
<a class="sourceLine" id="cb18-7" title="7">      puts(<span class="st">&quot;Do you want to quit? [Y/N]&quot;</span>);</a>
<a class="sourceLine" id="cb18-8" title="8">      <span class="dt">char</span> input = get_char_input();</a>
<a class="sourceLine" id="cb18-9" title="9"></a>
<a class="sourceLine" id="cb18-10" title="10">      <span class="cf">if</span> (input == <span class="ch">&#39;Y&#39;</span>) <span class="cf">return</span> true;</a>
<a class="sourceLine" id="cb18-11" title="11">      <span class="cf">if</span> (input == <span class="ch">&#39;N&#39;</span>) <span class="cf">return</span> false;</a>
<a class="sourceLine" id="cb18-12" title="12"></a>
<a class="sourceLine" id="cb18-13" title="13">      puts(<span class="st">&quot;Only Y or N are valid answers!&quot;</span>);</a>
<a class="sourceLine" id="cb18-14" title="14">    }</a>
<a class="sourceLine" id="cb18-15" title="15"></a>
<a class="sourceLine" id="cb18-16" title="16"><span class="cf">return</span> false;</a>
<a class="sourceLine" id="cb18-17" title="17">}</a></code></pre></div>
<hr />
<div class="sourceCode" id="cb19"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb19-1" title="1"><span class="co">// main.rs</span></a>
<a class="sourceLine" id="cb19-2" title="2"></a>
<a class="sourceLine" id="cb19-3" title="3"><span class="kw">fn</span> quit_action()-&gt; <span class="dt">bool</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb19-4" title="4">    <span class="kw">loop</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb19-5" title="5">          <span class="pp">println!</span>(<span class="st">&quot;Do you want to quit? [Y/N]&quot;</span>);</a>
<a class="sourceLine" id="cb19-6" title="6">          <span class="kw">let</span> input = get_char_input();</a>
<a class="sourceLine" id="cb19-7" title="7">          </a>
<a class="sourceLine" id="cb19-8" title="8">          <span class="kw">if</span> input == <span class="st">&quot;Y&quot;</span> <span class="op">{</span> <span class="kw">return</span> <span class="cn">true</span>; <span class="op">}</span></a>
<a class="sourceLine" id="cb19-9" title="9">          <span class="kw">if</span> input == <span class="st">&quot;N&quot;</span> <span class="op">{</span> <span class="kw">return</span> <span class="cn">false</span>; <span class="op">}</span></a>
<a class="sourceLine" id="cb19-10" title="10">    <span class="op">}</span></a>
<a class="sourceLine" id="cb19-11" title="11">    <span class="pp">println!</span>(<span class="st">&quot;Only Y or N are valid answers!&quot;</span>);</a>
<a class="sourceLine" id="cb19-12" title="12"></a>
<a class="sourceLine" id="cb19-13" title="13">    <span class="cn">false</span></a>
<a class="sourceLine" id="cb19-14" title="14"><span class="op">}</span></a></code></pre></div>
<p>Note how I insert “paragraph breaks” into the code to capture what belongs together, and to help the reader “breathe”. Asking the question and getting the reply feels like two related concepts. The two checks of the exit conditions are clearly also related. Thus, I group these together by separating them with a paragraph, and also put another paragraph before the error which is the logical conclusion of the function.</p>
<p>Also note that I removed the |// TODO: implement| comment since the function is now properly implemented, modulo the cheat – the call to the (yet) non-existent function.</p>
<h3 id="intermission-developing-in-increments">3.5 Intermission: Developing in Increments</h3>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>The |quit_action()| function was developed in a series of steps. The choice of the steps was very deliberate. Here are the rules to follow:</p>
<p>If there is any kind of branching, start with the most basic interesting case first In our example, Y and N are equally basic but only Y leads to something interesting, i.e., exits the program. The non yes or no cases require retrying which is more complicated, so we delay those even further. In the end, the order is Y, N, and “the rest”. Always finish a straight-line version first This means that any code that involves loops, you start by focusing on getting one iteration of the loop working in the working program. Once that is done, you can more easily wrap the working code inside a loop. Note that by this rule, the Y case would still be implemented before “the rest” even if Y called some other functions to save the database etc. Each increment should accomplish something sensible Each increment should result in a working program. Each increment should ideally have a testable outcome For example, when we implemented (skipped…) increment 4, we should also have changed the |get_char_input()| to return N to test this. And similar for increment 5.</p>
<p>Now: back to the running example.</p>
<h3 id="step-5-remove-the-cheats">3.6 Step 5: Remove the Cheats</h3>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>We have finished |quit_action()|, but mostly because we cheated. To finish implementing this part of the program, we will now remove the cheat by implementing |get_char_input()|. However, the reason why we didn’t write this piece of code down immediately from the start was because we thought it was complicated and did not know exactly how to do it. So, how do we proceed now?</p>
<p>Well, we cannot magically suddenly grasp how to read user input. This knowledge generally comes from somewhere. Let’s cover the three most basic cases:</p>
<ol type="1">
<li>Google/Stack Exchange</li>
<li>A text book</li>
<li>Man pages</li>
</ol>
<h4 id="man-pages">3.6.1 Man Pages</h4>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>Posix compliant operating systems have a |man| command that brings up the manual for a certain topic. For example, if you write |man printf|, you will get the manual page for |printf| /and associated functions/. The associated functions bit is key – often you know how to do something related, but maybe not this particular case. For example, you may know how to read formatted data from the terminal with |scanf|, and then you can use man |scanf| to find out about |fscanf| that reads formatted data from a file. The man pages are a great tool to know because they are such quick access to information, usually at a much higher quality (but less specific) than Stack Exchange etc.</p>
<h4 id="a-text-book">3.6.2 A Text Book</h4>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>You may have a text book on the subject. If so, great. Figuring out what to look for might be tricky. You first have to make the connection to I/O, and then you must go through 50 pages to find a mention of the specific functionality you are looking for. However, if you do, a text book usually gets you there. As long as you are doing something quite basic.</p>
<h4 id="google-stack-exchange">3.6.3 Google / Stack Exchange</h4>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>This is usually the easiest option. And a really good one at that. A problem with code from Stack Exchange or random blogs is that you may not always understand exactly what the code does, and why. You normally end up with 40+ suggested solutions to your problem, 10 of which use libraries that you don’t have or know how to include, another 10 that you cannot get to compile because of reasons, leaving another 20 which you must somehow chose between.</p>
<p>So how do you do that? Actually, in the same way as with the text book or examples from man pages: you try it out.</p>
<p>Here is the golden rule of trying code out: <em>start with a new empty file that just tests the code you’re trying to get to run.</em></p>
<p>The reason for this is <em>compartmentalising</em>. It may be that the reason why you are stuck on something is because there is an error in your code somewhere that breaks some part. Pasting random code into the place where you believe that the error is, will probably not uncover anything. It will just cause you to go through all 20 versions and (erroneously) conclude that none of them works.</p>
<p>Also, by isolating the code you are looking at in a single file, there is a lot less disturbance. You want to be working at all times with the smallest possible thing that can work. Remember: <em>good programmers like lazy.</em></p>
<p>If the problem is getting user input, then writing a small test program for that is easy. To simplify copying the solution across to the “real program” you can even name the functions right from the start:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb20-2" title="2"></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb20-4" title="4"></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="dt">char</span> get_char_input()</a>
<a class="sourceLine" id="cb20-6" title="6">{</a>
<a class="sourceLine" id="cb20-7" title="7">    <span class="co">// paste code here</span></a>
<a class="sourceLine" id="cb20-8" title="8">}</a>
<a class="sourceLine" id="cb20-9" title="9"></a>
<a class="sourceLine" id="cb20-10" title="10"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb20-11" title="11">{</a>
<a class="sourceLine" id="cb20-12" title="12">    printf(<span class="st">&quot;You pressed: &#39;%c&#39;</span><span class="sc">\n</span><span class="st">&quot;</span>, get_char_input());</a>
<a class="sourceLine" id="cb20-13" title="13">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb20-14" title="14">}</a></code></pre></div>
<hr />
<div class="sourceCode" id="cb21"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb21-1" title="1"><span class="co">// main.rs</span></a>
<a class="sourceLine" id="cb21-2" title="2"></a>
<a class="sourceLine" id="cb21-3" title="3"><span class="kw">fn</span> get_char_input() -&gt; <span class="dt">String</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb21-4" title="4">  <span class="co">// paste code here</span></a>
<a class="sourceLine" id="cb21-5" title="5"><span class="op">}</span></a>
<a class="sourceLine" id="cb21-6" title="6"></a>
<a class="sourceLine" id="cb21-7" title="7"><span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb21-8" title="8">  <span class="pp">println!</span>(<span class="st">&quot;You pressed: &#39;{}&#39;&quot;</span>, get_char_input());</a>
<a class="sourceLine" id="cb21-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>This program will call |get_char_input()| and print out the character between single quotes to avoid confusion. We can now spend the next 15 minutes on getting the code that we are finding online to work in this file, and then simply copy |get_char_input()| across to our other C file.</p>
<p>Tip</p>
<blockquote>
<p><em>Make it Easy to Write Small Test Programs</em></p>
</blockquote>
<p>The easiest way to understand how something works in programming is generally to test it out. To that end, make it really easy to start with an empty file, compile and run it. This could be hacking your editor, downloading a plugin to your IDE, or saving an empty file plus makefile <a href="http://mrbook.org/tutorials/make/" class="uri">http://mrbook.org/tutorials/make/</a> in a directory that you simply copy to make a new “testbed” for something.</p>
<p>Understand that testing something out simplifies life tremendously, and that all minutes spent on simplifying simplification simplifies even more.</p>
<h3 id="step-6-think-a-little-code-a-little-seems-familiar">3.7 Step 6: Think a little – Code a little (Seems familiar?)</h3>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>Now that we are done with quitting the program, it is time to move on to the next action. However, in order to get to the next action, we must first extend the main loop of the program so that the user can choose between whatever action we choose to implement next, and quitting.</p>
<p>Looking at the specification, the user’s input is again by reading a character. Great that we have already implemented |get_char_input()| to do exactly that. (If we hadn’t, we could just rely on the existing cheat, but eventually we would have to implement it of course.)</p>
<p>Following the instructions on how to develop in increments, etc. and looking at how we implemented the dialogue in |quit_action()|, we can relatively quickly write something like this:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb22-2" title="2"></a>
<a class="sourceLine" id="cb22-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb22-4" title="4"></a>
<a class="sourceLine" id="cb22-5" title="5"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb22-6" title="6">{</a>
<a class="sourceLine" id="cb22-7" title="7">    <span class="dt">bool</span> should_quit = false;</a>
<a class="sourceLine" id="cb22-8" title="8"></a>
<a class="sourceLine" id="cb22-9" title="9">    <span class="cf">while</span> (!should_quit)</a>
<a class="sourceLine" id="cb22-10" title="10">    {</a>
<a class="sourceLine" id="cb22-11" title="11">      puts(<span class="st">&quot;Main menu:&quot;</span>);</a>
<a class="sourceLine" id="cb22-12" title="12">      puts(<span class="st">&quot;[A]dd ware&quot;</span>);</a>
<a class="sourceLine" id="cb22-13" title="13">      <span class="co">// ... &lt;--- remaining actions, or just omit them for now</span></a>
<a class="sourceLine" id="cb22-14" title="14">      puts(<span class="st">&quot;[Q]uit&quot;</span>);</a>
<a class="sourceLine" id="cb22-15" title="15">      <span class="dt">char</span> input = get_char_input();</a>
<a class="sourceLine" id="cb22-16" title="16"></a>
<a class="sourceLine" id="cb22-17" title="17">      <span class="co">// Hmmm ... code formatting?</span></a>
<a class="sourceLine" id="cb22-18" title="18">      <span class="cf">if</span> (input == <span class="ch">&#39;A&#39;</span>)      { add_action(); }</a>
<a class="sourceLine" id="cb22-19" title="19">      <span class="cf">else</span> <span class="cf">if</span> (input == <span class="ch">&#39;Q&#39;</span>) { should_quit = quit_action(); }</a>
<a class="sourceLine" id="cb22-20" title="20">      <span class="cf">else</span>                   { puts(<span class="st">&quot;Invalid choice!&quot;</span>); }</a>
<a class="sourceLine" id="cb22-21" title="21">    }</a>
<a class="sourceLine" id="cb22-22" title="22">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb22-23" title="23">}</a></code></pre></div>
<hr />
<div class="sourceCode" id="cb23"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb23-1" title="1"><span class="co">// main.rs</span></a>
<a class="sourceLine" id="cb23-2" title="2"></a>
<a class="sourceLine" id="cb23-3" title="3"><span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb23-4" title="4"></a>
<a class="sourceLine" id="cb23-5" title="5">    <span class="kw">loop</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb23-6" title="6">      <span class="pp">println!</span>(<span class="st">&quot;Main menu:&quot;</span>);</a>
<a class="sourceLine" id="cb23-7" title="7">      <span class="pp">println!</span>(<span class="st">&quot;[A]dd ware&quot;</span>);</a>
<a class="sourceLine" id="cb23-8" title="8">      <span class="co">// ... &lt;--- remaining actions, or just omit them for now</span></a>
<a class="sourceLine" id="cb23-9" title="9">      <span class="pp">println!</span>(<span class="st">&quot;[Q]uit&quot;</span>);</a>
<a class="sourceLine" id="cb23-10" title="10">      <span class="kw">let</span> input: <span class="dt">String</span> = get_char_input();</a>
<a class="sourceLine" id="cb23-11" title="11"></a>
<a class="sourceLine" id="cb23-12" title="12">      <span class="co">// Hmmm ... code formatting?</span></a>
<a class="sourceLine" id="cb23-13" title="13">      <span class="kw">if</span> input == <span class="st">&quot;A&quot;</span>      <span class="op">{</span> add_action(); <span class="op">}</span></a>
<a class="sourceLine" id="cb23-14" title="14">      <span class="kw">else</span> <span class="kw">if</span> input == <span class="st">&quot;Q&quot;</span> <span class="op">{</span> <span class="kw">if</span> quit_action() == <span class="st">&quot;Y&quot;</span> <span class="op">{</span> <span class="kw">break</span>; <span class="op">}</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb23-15" title="15">      <span class="kw">else</span>                   <span class="op">{</span> <span class="pp">println!</span>(<span class="st">&quot;Invalid choice!&quot;</span>); <span class="op">}</span></a>
<a class="sourceLine" id="cb23-16" title="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb23-17" title="17"></a>
<a class="sourceLine" id="cb23-18" title="18"><span class="op">}</span></a></code></pre></div>
<p>Here, I added printing of (part of) the main menu, a call to |get_char_input()|, and I also changed the code a little to make use of a |should_quit()| variable to control whether the main loop should continue or not. The reason for this is simply because code with fewer exit points is simpler to understand.</p>
<p>However, looking at this code and the code for |quit_action()|, I notice that there is a small modicum of repetition. In both cases, I have to handle the failure mode, i.e., when the user presses something that isn’t part of the protocol.</p>
<p>Now <em>refactoring</em> enters into the picture. What I want to do now is to improve the code for |get_char_input()| so that it can handle the failure for me. A simple way to do that is to pass both the question and the valid alternatives to the |get_char_input()| function:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" title="1"><span class="co">/* c version */</span></a>
<a class="sourceLine" id="cb24-2" title="2"></a>
<a class="sourceLine" id="cb24-3" title="3"><span class="dt">char</span> input = get_char_input(<span class="st">&quot;Do you want to quit?&quot;</span>, <span class="st">&quot;YN&quot;</span>);</a>
<a class="sourceLine" id="cb24-4" title="4"><span class="dt">char</span> input = get_char_input(<span class="st">&quot;Choose menu item!&quot;</span>, <span class="st">&quot;AREPLUQ&quot;</span>);</a></code></pre></div>
<hr />
<div class="sourceCode" id="cb25"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb25-1" title="1"><span class="co">// rust version</span></a>
<a class="sourceLine" id="cb25-2" title="2"></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="kw">let</span> input = get_char_input(<span class="st">&quot;Do you want to quit?&quot;</span>, <span class="st">&quot;YN&quot;</span>);</a>
<a class="sourceLine" id="cb25-4" title="4"><span class="kw">let</span> input = get_char_input(<span class="st">&quot;Choose menu item!&quot;</span>, <span class="st">&quot;AREPLUQ&quot;</span>);</a></code></pre></div>
<p>The code for this is almost given in the specification of this assignment, so won’t be repeated here. However, the resulting code for |main()| is nice. Here rewritten with a switch statement just for fun, and the main menu printed in its own function:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb26-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb26-2" title="2"></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb26-4" title="4"><span class="dt">int</span> main(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb26-5" title="5">{</a>
<a class="sourceLine" id="cb26-6" title="6">    <span class="dt">bool</span> should_quit = false;</a>
<a class="sourceLine" id="cb26-7" title="7">    <span class="cf">while</span> (!should_quit)</a>
<a class="sourceLine" id="cb26-8" title="8">    {</a>
<a class="sourceLine" id="cb26-9" title="9">      print_main_menu(); <span class="co">// &lt;--- menu now in a function</span></a>
<a class="sourceLine" id="cb26-10" title="10">      <span class="cf">switch</span> (get_char_input(<span class="st">&quot;Choose menu item!&quot;</span>, <span class="st">&quot;AREPLUQ&quot;</span>))</a>
<a class="sourceLine" id="cb26-11" title="11">        {</a>
<a class="sourceLine" id="cb26-12" title="12">        <span class="cf">case</span> <span class="ch">&#39;A&#39;</span>: add_action();                <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb26-13" title="13">        <span class="cf">case</span> <span class="ch">&#39;R&#39;</span>: ...                          <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb26-14" title="14">        <span class="cf">case</span> <span class="ch">&#39;E&#39;</span>: ...                          <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb26-15" title="15">        <span class="cf">case</span> <span class="ch">&#39;P&#39;</span>: ...                          <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb26-16" title="16">        <span class="cf">case</span> <span class="ch">&#39;L&#39;</span>: ...                          <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb26-17" title="17">        <span class="cf">case</span> <span class="ch">&#39;U&#39;</span>: ...                          <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb26-18" title="18">        <span class="cf">case</span> <span class="ch">&#39;Q&#39;</span>: should_quit = quit_action(); <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb26-19" title="19">        }</a>
<a class="sourceLine" id="cb26-20" title="20">    }</a>
<a class="sourceLine" id="cb26-21" title="21">    <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb26-22" title="22">}</a></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb27-1" title="1"><span class="co">/* main.rs */</span></a>
<a class="sourceLine" id="cb27-2" title="2"></a>
<a class="sourceLine" id="cb27-3" title="3"><span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb27-4" title="4">    <span class="kw">loop</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb27-5" title="5">      print_main_menu(); <span class="co">// &lt;--- menu now in a function</span></a>
<a class="sourceLine" id="cb27-6" title="6">      <span class="kw">let</span> choice = get_char_input(<span class="st">&quot;Choose menu item!&quot;</span>, <span class="st">&quot;AREPLUQ&quot;</span>);</a>
<a class="sourceLine" id="cb27-7" title="7">      <span class="kw">match</span> choice <span class="op">{</span></a>
<a class="sourceLine" id="cb27-8" title="8">        <span class="ch">&#39;A&#39;</span> =&gt; add_action(),</a>
<a class="sourceLine" id="cb27-9" title="9">        <span class="ch">&#39;R&#39;</span> =&gt; ...         ,</a>
<a class="sourceLine" id="cb27-10" title="10">        <span class="ch">&#39;E&#39;</span> =&gt; ...         ,</a>
<a class="sourceLine" id="cb27-11" title="11">        <span class="ch">&#39;P&#39;</span> =&gt; ...         ,</a>
<a class="sourceLine" id="cb27-12" title="12">        <span class="ch">&#39;L&#39;</span> =&gt; ...         ,</a>
<a class="sourceLine" id="cb27-13" title="13">        <span class="ch">&#39;U&#39;</span> =&gt; ...         ,</a>
<a class="sourceLine" id="cb27-14" title="14">        <span class="ch">&#39;Q&#39;</span> =&gt; <span class="op">{</span> quit_action() == <span class="st">&quot;Y&quot;</span>; <span class="kw">break</span>;<span class="op">}</span> ,</a>
<a class="sourceLine" id="cb27-15" title="15">        _ =&gt; ()</a>
<a class="sourceLine" id="cb27-16" title="16">        <span class="op">}</span></a>
<a class="sourceLine" id="cb27-17" title="17">    <span class="op">}</span></a>
<a class="sourceLine" id="cb27-18" title="18">    </a>
<a class="sourceLine" id="cb27-19" title="19"><span class="op">}</span></a></code></pre></div>
<p>Now, we can compile and run the program again, and test that it works to trigger |add_action()|, which will print “Add action is not implemented yet”. Time to implement it!</p>
<h3 id="step-7-think-a-little-code-a-little-again">3.8 Step 7: Think a little – Code a little (again)</h3>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>A good candidate for this is adding a ware, because editing, removing, listing, undoing, etc. all presuppose the existence of some data in the database. Adding something new is often simpler than editing or removing. This means that is a good place to start.</p>
<p>It is now time to go back to the specification again, and read about the add action. We extend our mind-map accordingly:</p>
<figure>
<img src="img3.png" alt="Figure 4" /><figcaption>Figure 4</figcaption>
</figure>
<p>Figure 4: Third mindmap of the program</p>
<p>We have now arrived at a good place to do some <em>data design</em>. In other programs, we might have started with that if there weren’t any functions that did not manipulate any core data for the program. But what do we mean by <em>core data</em>?</p>
<p>Unsurprisingly, perhaps, the program’s <em>core data</em> is the central data for the program. A complicated program might have tons of different kinds of core data, but in our example, we are more lucky. To understand a program’s core data, we simply <em>mine the specification</em> again, this time looking for nouns <a href="http://en.wikipedia.org/wiki/Noun" class="uri">http://en.wikipedia.org/wiki/Noun</a>. Let’s do that now!</p>
<p>Again, for concreteness, I am copying in the specification and highlighting as I go:</p>
<p>Every <em>ware</em> in the warehouse has a <em>name</em>, a <em>description</em>, a <em>storage location</em>, a <em>pricetag</em>, information about the <em>number of items</em> of the particular wares stored in the warehouse, and the <em>cost of each item</em>. A storage location is a <em>section</em> (a single letter a-z), plus a <em>shelf</em> (an integer).</p>
<p>The simple warehouse program manages a <em>database</em> of wares and supports the following operations:</p>
<ol type="1">
<li>Adding a <em>ware</em></li>
<li>Removing a <em>ware</em></li>
<li>Editing the information about a <em>ware</em></li>
<li>Printing the information for a specific <em>ware</em></li>
<li>Listing all wares in the <em>database</em></li>
<li>Undoing the last <em>action</em></li>
<li>Quitting the program</li>
</ol>
<p>Looking at the highlighted information above, and reading the surrounding text, a pattern emerges. There is a <em>database</em>, which stores <em>wares</em>, that each store name, description, storage location, pricetag, and number of items. There is also a mentioning of <em>action</em>, which makes sense: in order to undo an action, we need to somehow record what the program did just before, and enough information to undo it. We don’t know exactly what this information is yet, but that’s fine. It probably does not make sense to implement undo until there are actions to be undone. (Read more in the aside below.)</p>
<p>The specification gives us a (mostly) very good idea for a data type for <em>ware</em>. Name and description are clearly strings. Price and number of items (which I will be calling amount from now on) are clearly integers. The storage location is less clear, however. Rather that getting stuck on this detail, let’s cheat and assume that there is a type |storage_location_t| that solves the problem. Now, we can write the type for ware:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb28-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb28-2" title="2"></a>
<a class="sourceLine" id="cb28-3" title="3"><span class="kw">struct</span> ware</a>
<a class="sourceLine" id="cb28-4" title="4">{</a>
<a class="sourceLine" id="cb28-5" title="5">    <span class="dt">char</span> *name;</a>
<a class="sourceLine" id="cb28-6" title="6">    <span class="dt">char</span> *description;</a>
<a class="sourceLine" id="cb28-7" title="7">    storage_location_t storage_location;</a>
<a class="sourceLine" id="cb28-8" title="8">    <span class="dt">int</span>   price;</a>
<a class="sourceLine" id="cb28-9" title="9">    <span class="dt">int</span>   amount;</a>
<a class="sourceLine" id="cb28-10" title="10">};</a></code></pre></div>
<p>By stubbing a little, we now have a type |ware|. However, in the interest of making progress and working in an incremental fashion, we are also going to apply another great simplification trick: <em>dodging</em>.</p>
<p>Getting information from the user at all is a great first step in an incremental development methodology. Once that is done and works, we can start caring about making sure that the information is correct. It is time to <em>dodge</em>.</p>
<p>Dodging means <em>temporarily</em> simplifying the specification. In the current example, a good dodge is to say: for now, I am going to only store string data in wares, and worry about integers and storage locations later. This allows us to use a single function for reading input from the user to complete the entire specification for adding a ware, modulo saving it to the database.</p>
<p>Temporarily, we change to type of |ware| to this:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb29-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="kw">struct</span> ware</a>
<a class="sourceLine" id="cb29-4" title="4">{</a>
<a class="sourceLine" id="cb29-5" title="5">    <span class="dt">char</span> *name;</a>
<a class="sourceLine" id="cb29-6" title="6">    <span class="dt">char</span> *description;</a>
<a class="sourceLine" id="cb29-7" title="7">    <span class="dt">char</span> *storage_location; <span class="co">// </span><span class="al">TODO</span><span class="co">: storage_location_t</span></a>
<a class="sourceLine" id="cb29-8" title="8">    <span class="dt">char</span> *price;            <span class="co">// </span><span class="al">TODO</span><span class="co">: int</span></a>
<a class="sourceLine" id="cb29-9" title="9">    <span class="dt">char</span> *amount;           <span class="co">// </span><span class="al">TODO</span><span class="co">: int</span></a>
<a class="sourceLine" id="cb29-10" title="10">};</a></code></pre></div>
<p>And then we can make a version of |get_char_input()|, for example |get_string_input()|. We will probably also cheat and assume its existence on the first pass through the code. We will also cheat and assume the existence of a |add_to_db()| function, which does nothing except prints out the obligatory disclaimer of it not yet being implemented.</p>
<p>Here is a list of suitable steps for almost implementing |add_action()|. Each step notably results in a program that can compile and run, but probably does not do anything useful.</p>
<ol type="1">
<li>Read all the inputs as strings and save them into a ware object, assuming the existance of several functions (This could quite possibly be several increments.): a. |get_string_input()|, b. |print_ware()| (to print a ware to the user before answering the save, edit, abort), c. |edit_ware()|, (for when the user selects edit above) and d. |add_to_db()|.</li>
<li>Implement |get_string_input()|.</li>
<li>Implement |edit_ware()|.</li>
<li>In 1. above, we are writing straight-line code. No loops, and the only branching is the calls to |edit_ware()| and |add_to_db()| based on the users input. This means we do not yet implement the case where the user makes an edit, gets a printout and makes the edit again. This support we add in this step.</li>
<li>Make price and amount ints in ware and replace the two calls to |get_string_input()| with calls to an assumed |get_int_input()|.</li>
<li>Implement |get_int_input()|.</li>
<li>Decide how to do the storage location. And implement that. This is likely several steps given that we cheated on the type for storage location before.</li>
</ol>
<p>The last thing we will do is to deal with the database – a final piece of the puzzle missing to finish this action.</p>
<p>Attention</p>
<p><em>Multiple Possible Ways Forward</em></p>
<p>Undo is a good example of a choice in how we choose to go forward. For example, we could chose to implement undo for each action that we implement, i.e,. after add we implement undo add, after edit we implement undo edit, etc. Or we simply wait until all actions are implemented and implement undo for all of them in a single hit. There is no right or wrong here, just two different ways of working, each with its own merit. For example, it is easy to argue that implementing undo X right after implementing X is the best way because at this point, we probably have the best understanding of how X works. On the other hand, it is easy to argue that if we implement the entire undo behaviour at the same time, it is easier to come up with a clean design for it that will work for all cases. If we started with a design for undo add, we might not yet see all the information that must be saved. (For example, undo edit will require us to store the original values of the edited data!)</p>
<h3 id="step-8-think-a-little-code-a-little">3.9 Step 8: Think a Little – Code a Little</h3>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>Choosing the proper database design is of course very important for the program at hand. There are multiple alternatives ranging from simple to hard, for example:</p>
<ol type="1">
<li>A statically sized array of wares</li>
<li>A dynamically sized in-memory structure like a list or a tree</li>
<li>An external database back-end</li>
</ol>
<p>There is however one very important realisation at this stage and that is that right now, <em>it does not matter</em> (right now).</p>
<p>The rationale is that we are trying to piece by piece construct a piece of software that fulfils the specification. We are just about to wrap-up the part of the program that will be adding the first item in the database. We don’t have the code to remove items, edit them, etc. So really, we could not care less at this point how the database is designed.</p>
<p>This is a great opportunity to dodge again. This time, we are going to dodge in three discrete steps:</p>
<ol type="1">
<li>The database holds only one single element</li>
<li>The database is an array of fixed maximal size</li>
<li>Make the final decision once the program’s done otherwise</li>
</ol>
<p>The first database design will allow implementing everything except adding and removing with multiple wares, and listing multiple wares. The second design will allow us to do all that. The third design will make the program less of a Mickey Mouse program <a href="http://www.catb.org/jargon/html/M/mickey-mouse-program.html" class="uri">http://www.catb.org/jargon/html/M/mickey-mouse-program.html</a>.</p>
<p>Following the first database design, we can now define a struct for the database like so:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb30-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb30-2" title="2"></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="kw">struct</span> db</a>
<a class="sourceLine" id="cb30-4" title="4">{</a>
<a class="sourceLine" id="cb30-5" title="5">    <span class="kw">struct</span> ware ware; <span class="co">// </span><span class="al">TODO</span><span class="co">: improve later</span></a>
<a class="sourceLine" id="cb30-6" title="6">};</a>
<a class="sourceLine" id="cb30-7" title="7"></a>
<a class="sourceLine" id="cb30-8" title="8"><span class="kw">typedef</span> <span class="kw">struct</span> db db_t;</a></code></pre></div>
<p>Now, we can finally finish the implementation of |add_action()|. To do this, we will go through the program and make a few simple changes:</p>
<ol type="1">
<li>We want to create a |db_t| value in main.</li>
<li>We want to pass a pointer to the |db_t| value to |add_action()|.</li>
<li>We want to pass a pointer to the |db_t| value to |add_to_db()|.</li>
</ol>
<p>Now we can implement |add_to_db()| like so:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb31-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb31-2" title="2"></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="dt">void</span> add_to_db(db_t *db, <span class="kw">struct</span> ware ware)</a>
<a class="sourceLine" id="cb31-4" title="4">{</a>
<a class="sourceLine" id="cb31-5" title="5">    db-&gt;ware = ware;</a>
<a class="sourceLine" id="cb31-6" title="6">}</a></code></pre></div>
<p>And now we are done with |add_action()|.</p>
<p>As we finish more actions and move on to the second database design, we simply update struct db:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb32-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb32-2" title="2"></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="pp">#define Max_elements_in_db 128</span></a>
<a class="sourceLine" id="cb32-4" title="4"><span class="kw">struct</span> db</a>
<a class="sourceLine" id="cb32-5" title="5">{</a>
<a class="sourceLine" id="cb32-6" title="6">    <span class="kw">struct</span> ware wares[Max_elements_in_db]; <span class="co">// </span><span class="al">TODO</span><span class="co">: improve later</span></a>
<a class="sourceLine" id="cb32-7" title="7">    <span class="dt">int</span> size;</a>
<a class="sourceLine" id="cb32-8" title="8">};</a></code></pre></div>
<p>That was easy, and now we can finalise more complex parts of out program. Moreover, if we have isolated the how the database works from the rest of the program correctly, only functions like |add_to_db()| etc. will have to change as a result:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb33-1" title="1"><span class="co">/* main.c */</span></a>
<a class="sourceLine" id="cb33-2" title="2"></a>
<a class="sourceLine" id="cb33-3" title="3"><span class="dt">void</span> add_to_db(db_t *db, <span class="kw">struct</span> ware ware)</a>
<a class="sourceLine" id="cb33-4" title="4">{</a>
<a class="sourceLine" id="cb33-5" title="5">    <span class="co">// Saves ware on the next available index and increase size by 1</span></a>
<a class="sourceLine" id="cb33-6" title="6">    db-&gt;wares[db-&gt;size++] = ware;</a>
<a class="sourceLine" id="cb33-7" title="7">}</a></code></pre></div>
<h3 id="step-9-and-beyond">3.10 Step 9, and beyond</h3>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>Think/code/refactor/remove cheats. Repeat until done. Find a good balance.</p>
<h3 id="summary-and-conclusions">3.11 Summary and Conclusions</h3>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>Almost all hard problems can be broken down into less-hard subproblems, which in turn can be broken down to even less-hard subsubproblems, etc. After a while of breaking work down into smaller and smaller tasks, the tasks finally become simple, and that is the right time to start solving them. That’s SIMPLE in a nutshell.</p>
<p>As soon as we hit a bump in the road – a problem we don’t know immediately how to solve, or don’t know how to solve well, or just cannot be bothered with solving right now – we keep things simple by stubbing and dodging. We reserve ourselves that right by always making clear notes about our cheats and dodges and by promising ourselves that we will set things straight in the future. And by keeping our promises.</p>
<h2 id="a-summary-of-simple-in-ten-steps-1">4 A Summary of SIMPLE in Ten Steps</h2>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p><strong>Start with a high-level work breakdown structure</strong></p>
<p>Mine your specification for data (nouns) and actions (verbs – behaviour/functions). Make simple drawings, e.g., mindmaps, to record your insights. Making things look easy is almost always good.</p>
<p><strong>Write code to test the validity of your thinking</strong></p>
<p>…not to drive the thinking! Thinking should invariably come before coding, especially thinking about how you check that your thinking is valid.</p>
<p><strong>Always have a working program</strong></p>
<p>In combination with stubbing, this usually means inserting dummy functions.</p>
<p><strong>Compile after every change</strong></p>
<p>Fix errors now, not later. Fix errors one by one. Fix errors in the order they were printed. Take time to actually read the compiler message so you know you are fixing the right thing.</p>
<p><strong>Run the program “all the time” to spot errors</strong></p>
<p>This requires always working code – preferably in combination with automated test that don’t involve ocular inspection, etc.</p>
<p><strong>Recursively break your problems up into smaller sub problems</strong></p>
<p>Only start solving problems when they start feeling easy. Make a task for each problem or subproblem to put on the stack, take tasks from the stack in a reasonable order (preferably easiest first); when the stack is empty – you are done!</p>
<p><strong>Break each task up into increments and start with the easy ones</strong></p>
<p>Generate new tasks to put on the stack as you go. If suitable, start with a straight-line version (without any if-statements). When the straight-line version works add conditionals, one by one. Start with the most basic or the most insteresting cases. When you are writing a loop, do the above steps first and add the looping step last.</p>
<p><strong>Whenever you run the risk of getting stuck, cheat</strong></p>
<p>Don’t forget to push new tasks on the stack that undoes the stubbing, later. This records the cheat, which is great.</p>
<p><strong>Use dodging to help breaking complex cases up into several less complex ones</strong></p>
<p>Don’t forget to push new tasks on the stack that undoes the dodge, later. This records the dodge, which is great. Alternate between thinking, coding and refactoring</p>
<ul>
<li>thinking – not so much that you get stuck, though,</li>
<li>coding – but never without first thinking about what to code, and occasionally</li>
<li>refactoring – especially to address your cheats and dodges.</li>
</ul>
<p>Refactoring is good to do between larger tasks. Make it a habit to continuously go back and refactor your solutions so that recently gotten insights rub off on older code too.</p>
<pre><code>    Note that this is a simple programming methodology, not a fully-fledged
    software design methodology. This means that it will not scale to
    “large” software, but will work fine for relatively simple programs up
    to say a few thousand lines of code. Certain domains, especially
    mathematical domains, might benefit from more advance thinking before
    implementing because there are more “truths” in such domains than in
    more fickle domains, especially ones involving human users. Although the
    running example used a program with a user interface, SIMPLE works
    equally well with non-UI programs.</code></pre>
<figure>
<img src="everyone-can-code.jpg" alt="Everyone can code" /><figcaption>Everyone can code</figcaption>
</figure>
<h2 id="tickets-tasks-and-post-it-stacks">5 Tickets, Tasks and Post-it Stacks</h2>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>Programming with SIMPLE revolves around breaking problems down into sets of smaller and smaller tasks. Actually, almost all programming works like that.</p>
<p>Our first problem was “implement an information system for a warehouse”. This is a very big and vague problem, so to solve it, we perused the specification to find the top-level actions that the system should support. We thus identified a set of tasks, one for each action, and started working through the tasks one by one. We carefully chose the order of tasks to make sure that we started as simple as possible and never worked on a task that could not be a part of the running program because it relied on another feature that wasn’t quite ready.</p>
<p>We are following a divide-and-conquer approach, where you recursively break down tasks into increasingly smaller pieces until each piece is trivially solvable. As is visible, from the steps above, we do not strive to break everything down into simple problems. For example, we started by doing |quit_action()| as soon as we realised it was simple enough, without caring about breaking down everything else first. The more you implement the program, the more you will understand it. You will never understand the program less than right at the start – therefore, trying to make a detailed planning with that limited understanding is a bad idea. Instead, tasks will be created as part of the implementation. At every step of the way, you will have a pile of tasks to perform. When this pile is empty, you’re done.</p>
<p>The cases where tasks are created in SIMPLE are ideally:</p>
<ol type="1">
<li>As part of the initial identification of top-level tasks</li>
<li>As part of the data design</li>
<li>When you pick a task to implement, you usually start by breaking it down into several smaller tasks</li>
<li>Stubbing creates a new task for the stubbing function</li>
<li>Dodging creates one or more new tasks to undo the simplifications</li>
</ol>
<p>Naturally, tasks are sometimes created because you forgot to create them elsewhere, or because of misunderstanding, etc.</p>
<p><em>Actually having a physical pile of tasks in front of you is not a bad idea.</em> It is quite common in modern software development organisations to rely heavily on post-it notes for task planning and follow-up. You will have one or two post-it notes that you are currently <em>doing</em>, a growing pile of post-it notes that are <em>done</em>, and one pile that’s <em>next</em>. Physically moving something from doing to done or seeing a large stack of notes in the done pile is gratifying. Physically moving something from next to doing reifies a commitment. Glancing at a number of post-it notes in the next section of the paper or whiteboard where you keep your tasks is a quick way to get an overview of where you are headed.</p>
<p>Using a physical stack of post-it notes or some equivalent software is an excellent way to manage the constantly growing and shrinking tasks. Of course, adding notes in the code is great too, but why not both.</p>
<p>Regardless of how you manage your tasks, an important question is where you put new tasks when they are created – to the front (so they are next in line) or to the back (so they won’t be dealt with for a while). There is no simple rule but there is a SIMPLE guideline: <em>simpler tasks go in front of more complicated tasks.</em></p>
<p>When you test your software, you may run into bugs or defects which aren’t of immediate importance. For each defect that you do not immediately fix, create a ticket, and put that in the task queue. A ticket is a task like any other, just one that’s about fixing something that’s inadvertently broken. Creating tickets for defects is a good way to avoid breaking the current flow by switching into debugging mode, and helps us remember it so it eventually gets fixed.</p>
<h2 id="the-three-rules-of-stubbing">6 The Three Rules of Stubbing</h2>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>Stubbing is one of the best tools in the programming toolbox, and a trick you should be using all the time. The rule of stubbing is this (also repeated above):</p>
<p>If you don’t know immediately how to solve a problem, assume the existence of a function that solves this problem for you, and call that function.</p>
<p>There is also a second rule of stubbing:</p>
<p>If you write code that you think about as Step 1; Step 2; Step 3; … Step n, and one of the steps suddenly turns out to be way longer/more complicated/more involved than the others, assume the existence of a function that performs that step for you, and call that function.</p>
<p>Finally, there is a third rule of stubbing:</p>
<p>If you write straight-line code, and you suddenly come across a step that you just cannot be bothered with implementing right now, assume the existence of a function that performs that step for you, and call that function.</p>
<p>(Yes – I deliberately formatted them as poems.)</p>
<p>In addition to help you stay focused on the control flow you are implementing and not get stuck in details, stubbing has the automatic side-effect of breaking down your code into smaller chunks. It also isolates trickier code inside single functions. For example, the logic for reading user input is now nicely encapsulated inside the |get_char_input()| function and we can solve this problem completely in isolation of the rest of the code for quitting the program although that code depends on it.</p>
<p>By giving a proper name to each function invented by stubbing, we make sure that the code reads more high-level, and it also helps us remember what problem the function in question should solve.</p>
<h2 id="dodging-not-quite-stubbing">7 Dodging: Not Quite Stubbing</h2>
<p><a href="#TOC"> <code>^--</code> </a></p>
<p>When doing the initial database design, we made proper use of dodging twice to make immediate simplifications that help us make progress and construct good increments. Here are two examples of dodging guidelines:</p>
<p>If a feature has several similar yet not identical cases, start by reducing them to the most basic case and getting that to work.</p>
<p>and</p>
<p>If a feature involves a collection of objects, investigate whether starting with just a single object is possible and easier.</p>
<p>Dodging involves simplifying the requirements temporarily in order to create a simpler specification. The word temporarily is key here, and it is imperative that we have some system in place to help us remember what simplifications we have made to make sure we roll them back at some point and replace them (step by step) with the full specification.</p>
<p>By starting with a design of the ware struct where everything is a string, we have reduced the number of different input methods for wares from three to one, and also to the simplest one where input does not need any real checking. This way, we can write a program in which the user can input data into the database, and once that program is sufficiently implemented, we can add more input methods and change the types in the ware struct. Following the guidelines for increments, we implement support for:</p>
<ol type="1">
<li>Name, description</li>
<li>Price, amount</li>
<li>Storage location</li>
</ol>
<p>in this very order, which is the ascending order of complexity. That is is the fact is easy to see: all input is a valid string; integer input may fail if the user types something other than a number; storage location requires two different inputs to be correct.</p>
<p>Finally, by starting with a database with only one item we have just enough to be able to have a working program in which we do pretty much everything except have more than one ware in the database. The logic for everything except writing to the database should be exactly the same for the entire program regardless of whether the database is an array of wares, a binary tree, etc.</p>
<hr />
<p><a href="#TOC"> <code>^--</code> </a></p>
<p><em>Want to report a bug?</em> <a href="https://github.com/IOOPM-UU/course-web/issues/new?title=Bug%20on%20page%20simple.org&amp;body=Please%20describe%20the%20issue%20clearly,%20help%20me%20locate%20it%20on%20the%20page,%20and%20if%20possible%20suggest%20a%20fix.&amp;assignee=TobiasWrigstad">Please place an issue here</a>. Pull requests are graciously accepted (hint, hint).</p>
<p><em>Ended up here randomly?</em> These are the pages for a one-semester course at 67% speed on imperative and object-oriented programming at <a href="http://it.uu.se/">the department of Information Technology</a> at <a href="http://www.uu.se/">Uppsala University</a>, ran by <a href="http://wrigstad.com/">Tobias Wrigstad</a>.</p>
<p>Author: Tobias Wrigstad</p>
<p>Created: 2019-04-19 Fri 17:39</p>
<p><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</body>
</html>
