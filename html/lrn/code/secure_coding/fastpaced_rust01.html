<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>fastpaced_rust01</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://razafy.com/css/styling.css" />
</head>
<body>
<nav id="TOC">
<ul>
<li><a href="#the-rust-programming-language-a-fast-paced-tutorial-level-01">The Rust programming language: A Fast-paced tutorial (Level 01)</a><ul>
<li><a href="#variable-binding">Variable binding</a><ul>
<li><a href="#define-and-assign-with-automatic-type-inferance">Define and assign with automatic type inferance</a></li>
<li><a href="#variable-binding-with-explicit-type">Variable Binding with Explicit type</a></li>
<li><a href="#discarding-a-value">Discarding a value</a></li>
<li><a href="#shadowing-variables">Shadowing Variables</a></li>
<li><a href="#tuples">Tuples</a></li>
<li><a href="#statements">Statements</a></li>
<li><a href="#fuctions">Fuctions</a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul></li>
</ul>
</nav>
<p>â‡¦ <a href="../../../../index.html">razafy.com</a> - <a href="../../index.html">lerina</a> - <a href="./index.html">code</a></p>
<h1 id="the-rust-programming-language-a-fast-paced-tutorial-level-01">The Rust programming language: A Fast-paced tutorial (Level 01)</h1>
<p>Replace with 20min for each header. add worked examples and exercise</p>
<ol type="1">
<li>add headers</li>
<li>link to official book</li>
<li>reformulate with pix</li>
<li>change examples</li>
<li>add exercise</li>
<li>worked problem/exercise</li>
<li>problem and solution</li>
<li>assignment</li>
</ol>
<h2 id="variable-binding">Variable binding</h2>
<p>See also <a href="https://doc.rust-lang.org/stable/book/ch02-00-guessing-game-tutorial.html#storing-values-with-variables">Storing Values with Variables</a></p>
<p>Create variables with the <code>let</code> statement.</p>
<h3 id="define-and-assign-with-automatic-type-inferance">Define and assign with automatic type inferance</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">let</span> x; <span class="co">// declare &quot;x&quot;</span></a>
<a class="sourceLine" id="cb1-2" title="2">x = <span class="dv">42</span>; <span class="co">// assign 42 to &quot;x&quot;</span></a></code></pre></div>
<p>This can also be written as a single line:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb2-1" title="1"></a>
<a class="sourceLine" id="cb2-2" title="2">          <span class="kw">let</span> x = <span class="dv">42</span>;</a></code></pre></div>
<h3 id="variable-binding-with-explicit-type">Variable Binding with Explicit type</h3>
<p>You can specify the variable's type explicitly with <code>:</code>, that's a type annotation:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb3-1" title="1"></a>
<a class="sourceLine" id="cb3-2" title="2">          <span class="kw">let</span> x: <span class="dt">i32</span>; <span class="co">// `i32` is a signed 32-bit integer</span></a>
<a class="sourceLine" id="cb3-3" title="3">          x = <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb3-4" title="4">          <span class="co">// there&#39;s i8, i16, i32, i64, i128</span></a>
<a class="sourceLine" id="cb3-5" title="5">          <span class="co">//    also u8, u16, u32, u64, u128 for unsigned</span></a></code></pre></div>
<p>This can also be written as a single line:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb4-1" title="1"></a>
<a class="sourceLine" id="cb4-2" title="2">          <span class="kw">let</span> x: <span class="dt">i32</span> = <span class="dv">42</span>;</a></code></pre></div>
<p>If you declare a name and initialize it later, the compiler will prevent you from using it before it's initialized.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb5-1" title="1"></a>
<a class="sourceLine" id="cb5-2" title="2">          <span class="kw">let</span> x;</a>
<a class="sourceLine" id="cb5-3" title="3">          foobar(x); <span class="co">// error: borrow of possibly-uninitialized variable: `x`</span></a>
<a class="sourceLine" id="cb5-4" title="4">          x = <span class="dv">42</span>;</a></code></pre></div>
<p>However, doing this is completely fine:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb6-1" title="1"></a>
<a class="sourceLine" id="cb6-2" title="2">          <span class="kw">let</span> x;</a>
<a class="sourceLine" id="cb6-3" title="3">          x = <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb6-4" title="4">          foobar(x); <span class="co">// the type of `x` will be inferred from here</span></a></code></pre></div>
<h3 id="discarding-a-value">Discarding a value</h3>
<p>The underscore <code>_</code> is a special name - or rather, a "lack of name". It basically means to throw away something:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb7-1" title="1"></a>
<a class="sourceLine" id="cb7-2" title="2">          <span class="co">// this does *nothing* because 42 is a constant</span></a>
<a class="sourceLine" id="cb7-3" title="3">          <span class="kw">let</span> _ = <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb7-4" title="4">          <span class="co">// this calls `get_thing` but throws away its result</span></a>
<a class="sourceLine" id="cb7-5" title="5">          <span class="kw">let</span> _ = get_thing();</a></code></pre></div>
<p>Names that <em>start</em> with an underscore are regular names, it's just that the compiler won't warn about them being unused:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb8-1" title="1"></a>
<a class="sourceLine" id="cb8-2" title="2">          <span class="co">// we may use `_x` eventually, but our code is a work-in-progress</span></a>
<a class="sourceLine" id="cb8-3" title="3">          <span class="co">// and we just wanted to get rid of a compiler warning for now.</span></a>
<a class="sourceLine" id="cb8-4" title="4">          <span class="kw">let</span> _x = <span class="dv">42</span>;</a></code></pre></div>
<h3 id="shadowing-variables">Shadowing Variables</h3>
<p>Separate bindings with the same name can be introduced - you can <em>shadow</em> a variable binding:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb9-1" title="1"></a>
<a class="sourceLine" id="cb9-2" title="2">          <span class="kw">let</span> x = <span class="dv">13</span>;</a>
<a class="sourceLine" id="cb9-3" title="3">          <span class="kw">let</span> x = x + <span class="dv">3</span>;</a>
<a class="sourceLine" id="cb9-4" title="4">          <span class="co">// using `x` after that line only refers to the second `x`,</span></a>
<a class="sourceLine" id="cb9-5" title="5">          <span class="co">// the first `x` no longer exists.</span></a></code></pre></div>
<h3 id="tuples">Tuples</h3>
<p>Rust has tuples, which you can think of as "fixed-length collections of values of different types".</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb10-1" title="1"></a>
<a class="sourceLine" id="cb10-2" title="2">          <span class="kw">let</span> pair = (<span class="ch">&#39;a&#39;</span>, <span class="dv">17</span>);</a>
<a class="sourceLine" id="cb10-3" title="3">          pair.<span class="dv">0</span>; <span class="co">// this is &#39;a&#39;</span></a>
<a class="sourceLine" id="cb10-4" title="4">          pair.<span class="dv">1</span>; <span class="co">// this is 17</span></a></code></pre></div>
<p>If we really we wanted to annotate the type of <code>pair</code>, we would write:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb11-1" title="1"></a>
<a class="sourceLine" id="cb11-2" title="2">          <span class="kw">let</span> pair: (<span class="dt">char</span>, <span class="dt">i32</span>) = (<span class="ch">&#39;a&#39;</span>, <span class="dv">17</span>);</a></code></pre></div>
<p>Tuples can be <em>destructured</em> when doing an assignment, which means they're broken down into their individual fields:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb12-1" title="1"></a>
<a class="sourceLine" id="cb12-2" title="2">          <span class="kw">let</span> (some_char, some_int) = (<span class="ch">&#39;a&#39;</span>, <span class="dv">17</span>);</a>
<a class="sourceLine" id="cb12-3" title="3">          <span class="co">// now, `some_char` is &#39;a&#39;, and `some_int` is 17</span></a></code></pre></div>
<p>This is especially useful when a function returns a tuple:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb13-1" title="1"></a>
<a class="sourceLine" id="cb13-2" title="2">          <span class="kw">let</span> (left, right) = slice.split_at(middle);</a></code></pre></div>
<p>Of course, when destructuring a tuple, <code>_</code> can be used to throw away part of it:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb14-1" title="1"></a>
<a class="sourceLine" id="cb14-2" title="2">          <span class="kw">let</span> (_, right) = slice.split_at(middle);</a></code></pre></div>
<h3 id="statements">Statements</h3>
<p>The semi-colon marks the end of a statement:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb15-1" title="1"></a>
<a class="sourceLine" id="cb15-2" title="2">          <span class="kw">let</span> x = <span class="dv">3</span>;</a>
<a class="sourceLine" id="cb15-3" title="3">          <span class="kw">let</span> y = <span class="dv">5</span>;</a>
<a class="sourceLine" id="cb15-4" title="4">          <span class="kw">let</span> z = y + x;</a></code></pre></div>
<p>Which means statements can span multiple lines:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb16-1" title="1"></a>
<a class="sourceLine" id="cb16-2" title="2">          <span class="kw">let</span> x = <span class="pp">vec!</span><span class="op">[</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span><span class="op">]</span></a>
<a class="sourceLine" id="cb16-3" title="3">              .iter()</a>
<a class="sourceLine" id="cb16-4" title="4">              .map(|x| x + <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb16-5" title="5">              .fold(<span class="dv">0</span>, |x, y| x + y);</a></code></pre></div>
<p>(We'll go over what those actually mean later).</p>
<h3 id="fuctions">Fuctions</h3>
<p><code>fn</code> declares a function.</p>
<p>Here's a void function:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb17-1" title="1"></a>
<a class="sourceLine" id="cb17-2" title="2">          <span class="kw">fn</span> greet() <span class="op">{</span></a>
<a class="sourceLine" id="cb17-3" title="3">              <span class="pp">println!</span>(<span class="st">&quot;Hi there!&quot;</span>);</a>
<a class="sourceLine" id="cb17-4" title="4">          <span class="op">}</span></a></code></pre></div>
<p>And here's a function that returns a 32-bit signed integer. The arrow indicates its return type:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb18-1" title="1"></a>
<a class="sourceLine" id="cb18-2" title="2">          <span class="kw">fn</span> fair_dice_roll() -&gt; <span class="dt">i32</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb18-3" title="3">              <span class="dv">4</span></a>
<a class="sourceLine" id="cb18-4" title="4">          <span class="op">}</span></a></code></pre></div>
<p>A pair of brackets declares a block, which has its own scope:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb19-1" title="1"></a>
<a class="sourceLine" id="cb19-2" title="2">          <span class="co">// This prints &quot;in&quot;, then &quot;out&quot;</span></a>
<a class="sourceLine" id="cb19-3" title="3">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb19-4" title="4">              <span class="kw">let</span> x = <span class="st">&quot;out&quot;</span>;</a>
<a class="sourceLine" id="cb19-5" title="5">              <span class="op">{</span></a>
<a class="sourceLine" id="cb19-6" title="6">                  <span class="co">// this is a different `x`</span></a>
<a class="sourceLine" id="cb19-7" title="7">                  <span class="kw">let</span> x = <span class="st">&quot;in&quot;</span>;</a>
<a class="sourceLine" id="cb19-8" title="8">                  <span class="pp">println!</span>(x);</a>
<a class="sourceLine" id="cb19-9" title="9">              <span class="op">}</span></a>
<a class="sourceLine" id="cb19-10" title="10">              <span class="pp">println!</span>(x);</a>
<a class="sourceLine" id="cb19-11" title="11">          <span class="op">}</span></a></code></pre></div>
<p>Blocks are also expressions, which mean they evaluate to.. a value.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb20-1" title="1"></a>
<a class="sourceLine" id="cb20-2" title="2">          <span class="co">// this:</span></a>
<a class="sourceLine" id="cb20-3" title="3">          <span class="kw">let</span> x = <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb20-4" title="4">          <span class="co">// is equivalent to this:</span></a>
<a class="sourceLine" id="cb20-5" title="5">          <span class="kw">let</span> x = <span class="op">{</span> <span class="dv">42</span> <span class="op">}</span>;</a></code></pre></div>
<p>Inside a block, there can be multiple statements:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb21-1" title="1"></a>
<a class="sourceLine" id="cb21-2" title="2">          <span class="kw">let</span> x = <span class="op">{</span></a>
<a class="sourceLine" id="cb21-3" title="3">              <span class="kw">let</span> y = <span class="dv">1</span>; <span class="co">// first statement</span></a>
<a class="sourceLine" id="cb21-4" title="4">              <span class="kw">let</span> z = <span class="dv">2</span>; <span class="co">// second statement</span></a>
<a class="sourceLine" id="cb21-5" title="5">              y + z <span class="co">// this is the *tail* - what the whole block will evaluate to</span></a>
<a class="sourceLine" id="cb21-6" title="6">          <span class="op">}</span>;</a></code></pre></div>
<p>And that's why "omitting the semicolon at the end of a function" is the same as returning, ie. these are equivalent:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb22-1" title="1"></a>
<a class="sourceLine" id="cb22-2" title="2">          <span class="kw">fn</span> fair_dice_roll() -&gt; <span class="dt">i32</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb22-3" title="3">              <span class="kw">return</span> <span class="dv">4</span>;</a>
<a class="sourceLine" id="cb22-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb22-5" title="5">          <span class="kw">fn</span> fair_dice_roll() -&gt; <span class="dt">i32</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb22-6" title="6">              <span class="dv">4</span></a>
<a class="sourceLine" id="cb22-7" title="7">          <span class="op">}</span></a></code></pre></div>
<p><code>if</code> conditionals are also expressions:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb23-1" title="1"></a>
<a class="sourceLine" id="cb23-2" title="2">          <span class="kw">fn</span> fair_dice_roll() -&gt; <span class="dt">i32</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb23-3" title="3">              <span class="kw">if</span> feeling_lucky <span class="op">{</span></a>
<a class="sourceLine" id="cb23-4" title="4">                  <span class="dv">6</span></a>
<a class="sourceLine" id="cb23-5" title="5">              <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb23-6" title="6">                  <span class="dv">4</span></a>
<a class="sourceLine" id="cb23-7" title="7">              <span class="op">}</span></a>
<a class="sourceLine" id="cb23-8" title="8">          <span class="op">}</span></a></code></pre></div>
<p>A <code>match</code> is also an expression:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb24-1" title="1"></a>
<a class="sourceLine" id="cb24-2" title="2">          <span class="kw">fn</span> fair_dice_roll() -&gt; <span class="dt">i32</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb24-3" title="3">              <span class="kw">match</span> feeling_lucky <span class="op">{</span></a>
<a class="sourceLine" id="cb24-4" title="4">                  <span class="cn">true</span> =&gt; <span class="dv">6</span>,</a>
<a class="sourceLine" id="cb24-5" title="5">                  <span class="cn">false</span> =&gt; <span class="dv">4</span>,</a>
<a class="sourceLine" id="cb24-6" title="6">              <span class="op">}</span></a>
<a class="sourceLine" id="cb24-7" title="7">          <span class="op">}</span></a></code></pre></div>
<p>Dots are typically used to access fields of a value:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb25-1" title="1"></a>
<a class="sourceLine" id="cb25-2" title="2">          <span class="kw">let</span> a = (<span class="dv">10</span>, <span class="dv">20</span>);</a>
<a class="sourceLine" id="cb25-3" title="3">          a.<span class="dv">0</span>; <span class="co">// this is 10</span></a>
<a class="sourceLine" id="cb25-4" title="4">          <span class="kw">let</span> amos = get_some_struct();</a>
<a class="sourceLine" id="cb25-5" title="5">          amos.nickname; <span class="co">// this is &quot;fasterthanlime&quot;</span></a></code></pre></div>
<p>Or call a method on a value:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb26-1" title="1"></a>
<a class="sourceLine" id="cb26-2" title="2">          <span class="kw">let</span> nick = <span class="st">&quot;fasterthanlime&quot;</span>;</a>
<a class="sourceLine" id="cb26-3" title="3">          nick.len(); <span class="co">// this is 14</span></a></code></pre></div>
<p>The double-colon, <code>::</code>, is similar but it operates on namespaces.</p>
<p>In this example, <code>std</code> is a <em>crate</em> (~ a library), <code>cmp</code> is a <em>module</em> (~ a source file), and <code>min</code> is a <em>function</em>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb27-1" title="1"></a>
<a class="sourceLine" id="cb27-2" title="2">          <span class="kw">let</span> least = <span class="pp">std::cmp::</span>min(<span class="dv">3</span>, <span class="dv">8</span>); <span class="co">// this is 3</span></a></code></pre></div>
<p><code>use</code> directives can be used to "bring in scope" names from other namespace:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb28-1" title="1"></a>
<a class="sourceLine" id="cb28-2" title="2">          <span class="kw">use</span> <span class="pp">std::cmp::</span>min;</a>
<a class="sourceLine" id="cb28-3" title="3">          <span class="kw">let</span> least = min(<span class="dv">7</span>, <span class="dv">1</span>); <span class="co">// this is 1</span></a></code></pre></div>
<p>Within <code>use</code> directives, curly brackets have another meaning: they're "globs". If we want to import both <code>min</code> and <code>max</code>, we can do any of these:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb29-1" title="1"></a>
<a class="sourceLine" id="cb29-2" title="2">          <span class="co">// this works:</span></a>
<a class="sourceLine" id="cb29-3" title="3">          <span class="kw">use</span> <span class="pp">std::cmp::</span>min;</a>
<a class="sourceLine" id="cb29-4" title="4">          <span class="kw">use</span> <span class="pp">std::cmp::</span>max;</a>
<a class="sourceLine" id="cb29-5" title="5">          <span class="co">// this also works:</span></a>
<a class="sourceLine" id="cb29-6" title="6">          <span class="kw">use</span> <span class="pp">std::cmp::</span><span class="op">{</span>min, max<span class="op">}</span>;</a>
<a class="sourceLine" id="cb29-7" title="7">          <span class="co">// this also works!</span></a>
<a class="sourceLine" id="cb29-8" title="8">          <span class="kw">use</span> <span class="pp">std::</span><span class="op">{</span><span class="pp">cmp::</span>min, <span class="pp">cmp::</span>max<span class="op">}</span>;</a></code></pre></div>
<p>A wildcard ( <code>*</code>) lets you import every symbol from a namespace:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb30-1" title="1"></a>
<a class="sourceLine" id="cb30-2" title="2">          <span class="co">// this brings `min` and `max` in scope, and many other things</span></a>
<a class="sourceLine" id="cb30-3" title="3">          <span class="kw">use</span> <span class="pp">std::cmp::</span>*;</a></code></pre></div>
<p>Types are namespaces too, and methods can be called as regular functions:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb31-1" title="1"></a>
<a class="sourceLine" id="cb31-2" title="2">          <span class="kw">let</span> x = <span class="st">&quot;amos&quot;</span>.len(); <span class="co">// this is 4</span></a>
<a class="sourceLine" id="cb31-3" title="3">          <span class="kw">let</span> x = <span class="dt">str</span>::len(<span class="st">&quot;amos&quot;</span>); <span class="co">// this is also 4</span></a></code></pre></div>
<p><code>str</code> is a primitive type, but many non-primitive types are also in scope by default.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb32-1" title="1"></a>
<a class="sourceLine" id="cb32-2" title="2">          <span class="co">// `Vec` is a regular struct, not a primitive type</span></a>
<a class="sourceLine" id="cb32-3" title="3">          <span class="kw">let</span> v = <span class="dt">Vec</span>::new();</a>
<a class="sourceLine" id="cb32-4" title="4">          <span class="co">// this is exactly the same code, but with the *full* path to `Vec`</span></a>
<a class="sourceLine" id="cb32-5" title="5">          <span class="kw">let</span> v = <span class="pp">std::vec::</span><span class="dt">Vec</span>::new();</a></code></pre></div>
<p>This works because Rust inserts this at the beginning of every module:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb33-1" title="1"></a>
<a class="sourceLine" id="cb33-2" title="2">          <span class="kw">use</span> <span class="pp">std::prelude::v1::</span>*;</a></code></pre></div>
<p>(Which in turns re-exports a lot of symbols, like <code>Vec</code>, <code>String</code>, <code>Option</code> and <code>Result</code>).</p>
<p>Structs are declared with the <code>struct</code> keyword:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb34-1" title="1"></a>
<a class="sourceLine" id="cb34-2" title="2">          <span class="kw">struct</span> Vec2 <span class="op">{</span></a>
<a class="sourceLine" id="cb34-3" title="3">              x: <span class="dt">f64</span>, <span class="co">// 64-bit floating point, aka &quot;double precision&quot;</span></a>
<a class="sourceLine" id="cb34-4" title="4">              y: <span class="dt">f64</span>,</a>
<a class="sourceLine" id="cb34-5" title="5">          <span class="op">}</span></a></code></pre></div>
<p>They can be initialized using <em>struct literals</em>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb35-1" title="1"></a>
<a class="sourceLine" id="cb35-2" title="2">          <span class="kw">let</span> v1 = Vec2 <span class="op">{</span> x: <span class="dv">1.0</span>, y: <span class="dv">3.0</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb35-3" title="3">          <span class="kw">let</span> v2 = Vec2 <span class="op">{</span> y: <span class="dv">2.0</span>, x: <span class="dv">4.0</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb35-4" title="4">          <span class="co">// the order does not matter, only the names do</span></a></code></pre></div>
<p>There is a shortcut for initializing the <em>rest of the fields</em> from another struct:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb36-1" title="1"></a>
<a class="sourceLine" id="cb36-2" title="2">          <span class="kw">let</span> v3 = Vec2 <span class="op">{</span></a>
<a class="sourceLine" id="cb36-3" title="3">              x: <span class="dv">14.0</span>,</a>
<a class="sourceLine" id="cb36-4" title="4">              ..v2</a>
<a class="sourceLine" id="cb36-5" title="5">          <span class="op">}</span>;</a></code></pre></div>
<p>This is called "struct update syntax", can only happen in last position, and cannot be followed by a comma.</p>
<p>Note that <em>the rest of the fields</em> can mean <em>all the fields</em>:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb37-1" title="1"></a>
<a class="sourceLine" id="cb37-2" title="2">          <span class="kw">let</span> v4 = Vec2 <span class="op">{</span> ..v3 <span class="op">}</span>;</a></code></pre></div>
<p>Structs, like tuples, can be destructured.</p>
<p>Just like this is a valid <code>let</code> pattern:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb38-1" title="1"></a>
<a class="sourceLine" id="cb38-2" title="2">          <span class="kw">let</span> (left, right) = slice.split_at(middle);</a></code></pre></div>
<p>So is this:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb39-1" title="1"></a>
<a class="sourceLine" id="cb39-2" title="2">          <span class="kw">let</span> v = Vec2 <span class="op">{</span> x: <span class="dv">3.0</span>, y: <span class="dv">6.0</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb39-3" title="3">          <span class="kw">let</span> Vec2 <span class="op">{</span> x, y <span class="op">}</span> = v;</a>
<a class="sourceLine" id="cb39-4" title="4">          <span class="co">// `x` is now 3.0, `y` is now `6.0`</span></a></code></pre></div>
<p>And this:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb40-1" title="1"></a>
<a class="sourceLine" id="cb40-2" title="2">          <span class="kw">let</span> Vec2 <span class="op">{</span> x, .. <span class="op">}</span> = v;</a>
<a class="sourceLine" id="cb40-3" title="3">          <span class="co">// this throws away `v.y`</span></a></code></pre></div>
<p><code>let</code> patterns can be used as conditions in <code>if</code>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb41-1" title="1"></a>
<a class="sourceLine" id="cb41-2" title="2">          <span class="kw">struct</span> Number <span class="op">{</span></a>
<a class="sourceLine" id="cb41-3" title="3">              odd: <span class="dt">bool</span>,</a>
<a class="sourceLine" id="cb41-4" title="4">              value: <span class="dt">i32</span>,</a>
<a class="sourceLine" id="cb41-5" title="5">          <span class="op">}</span></a>
<a class="sourceLine" id="cb41-6" title="6">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb41-7" title="7">              <span class="kw">let</span> one = Number <span class="op">{</span> odd: <span class="cn">true</span>, value: <span class="dv">1</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb41-8" title="8">              <span class="kw">let</span> two = Number <span class="op">{</span> odd: <span class="cn">false</span>, value: <span class="dv">2</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb41-9" title="9">              print_number(one);</a>
<a class="sourceLine" id="cb41-10" title="10">              print_number(two);</a>
<a class="sourceLine" id="cb41-11" title="11">          <span class="op">}</span></a>
<a class="sourceLine" id="cb41-12" title="12">          <span class="kw">fn</span> print_number(n: Number) <span class="op">{</span></a>
<a class="sourceLine" id="cb41-13" title="13">              <span class="kw">if</span> <span class="kw">let</span> Number <span class="op">{</span> odd: <span class="cn">true</span>, value <span class="op">}</span> = n <span class="op">{</span></a>
<a class="sourceLine" id="cb41-14" title="14">                  <span class="pp">println!</span>(<span class="st">&quot;Odd number: {}&quot;</span>, value);</a>
<a class="sourceLine" id="cb41-15" title="15">              <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> <span class="kw">let</span> Number <span class="op">{</span> odd: <span class="cn">false</span>, value <span class="op">}</span> = n <span class="op">{</span></a>
<a class="sourceLine" id="cb41-16" title="16">                  <span class="pp">println!</span>(<span class="st">&quot;Even number: {}&quot;</span>, value);</a>
<a class="sourceLine" id="cb41-17" title="17">              <span class="op">}</span></a>
<a class="sourceLine" id="cb41-18" title="18">          <span class="op">}</span></a>
<a class="sourceLine" id="cb41-19" title="19">          <span class="co">// this prints:</span></a>
<a class="sourceLine" id="cb41-20" title="20">          <span class="co">// Odd number: 1</span></a>
<a class="sourceLine" id="cb41-21" title="21">          <span class="co">// Even number: 2</span></a></code></pre></div>
<p><code>match</code> arms are also patterns, just like <code>if       let</code>:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb42-1" title="1"></a>
<a class="sourceLine" id="cb42-2" title="2">          <span class="kw">fn</span> print_number(n: Number) <span class="op">{</span></a>
<a class="sourceLine" id="cb42-3" title="3">              <span class="kw">match</span> n <span class="op">{</span></a>
<a class="sourceLine" id="cb42-4" title="4">                  Number <span class="op">{</span> odd: <span class="cn">true</span>, value <span class="op">}</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;Odd number: {}&quot;</span>, value),</a>
<a class="sourceLine" id="cb42-5" title="5">                  Number <span class="op">{</span> odd: <span class="cn">false</span>, value <span class="op">}</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;Even number: {}&quot;</span>, value),</a>
<a class="sourceLine" id="cb42-6" title="6">              <span class="op">}</span></a>
<a class="sourceLine" id="cb42-7" title="7">          <span class="op">}</span></a>
<a class="sourceLine" id="cb42-8" title="8">          <span class="co">// this prints the same as before</span></a></code></pre></div>
<p>A <code>match</code> has to be exhaustive: at least one arm needs to match.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb43-1" title="1"></a>
<a class="sourceLine" id="cb43-2" title="2">          <span class="kw">fn</span> print_number(n: Number) <span class="op">{</span></a>
<a class="sourceLine" id="cb43-3" title="3">              <span class="kw">match</span> n <span class="op">{</span></a>
<a class="sourceLine" id="cb43-4" title="4">                  Number <span class="op">{</span> value: <span class="dv">1</span>, .. <span class="op">}</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;One&quot;</span>),</a>
<a class="sourceLine" id="cb43-5" title="5">                  Number <span class="op">{</span> value: <span class="dv">2</span>, .. <span class="op">}</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;Two&quot;</span>),</a>
<a class="sourceLine" id="cb43-6" title="6">                  Number <span class="op">{</span> value, .. <span class="op">}</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, value),</a>
<a class="sourceLine" id="cb43-7" title="7">                  <span class="co">// if that last arm didn&#39;t exist, we would get a compile-time error</span></a>
<a class="sourceLine" id="cb43-8" title="8">              <span class="op">}</span></a>
<a class="sourceLine" id="cb43-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>If that's hard, <code>_</code> can be used as a "catch-all" pattern:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb44-1" title="1"></a>
<a class="sourceLine" id="cb44-2" title="2">          <span class="kw">fn</span> print_number(n: Number) <span class="op">{</span></a>
<a class="sourceLine" id="cb44-3" title="3">              <span class="kw">match</span> n.value <span class="op">{</span></a>
<a class="sourceLine" id="cb44-4" title="4">                  <span class="dv">1</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;One&quot;</span>),</a>
<a class="sourceLine" id="cb44-5" title="5">                  <span class="dv">2</span> =&gt; <span class="pp">println!</span>(<span class="st">&quot;Two&quot;</span>),</a>
<a class="sourceLine" id="cb44-6" title="6">                  _ =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, n.value),</a>
<a class="sourceLine" id="cb44-7" title="7">              <span class="op">}</span></a>
<a class="sourceLine" id="cb44-8" title="8">          <span class="op">}</span></a></code></pre></div>
<p>You can declare methods on your own types:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb45-1" title="1"></a>
<a class="sourceLine" id="cb45-2" title="2">          <span class="kw">struct</span> Number <span class="op">{</span></a>
<a class="sourceLine" id="cb45-3" title="3">              odd: <span class="dt">bool</span>,</a>
<a class="sourceLine" id="cb45-4" title="4">              value: <span class="dt">i32</span>,</a>
<a class="sourceLine" id="cb45-5" title="5">          <span class="op">}</span></a>
<a class="sourceLine" id="cb45-6" title="6">          <span class="kw">impl</span> Number <span class="op">{</span></a>
<a class="sourceLine" id="cb45-7" title="7">              <span class="kw">fn</span> is_strictly_positive(<span class="kw">self</span>) -&gt; <span class="dt">bool</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb45-8" title="8">                  <span class="kw">self</span>.value &gt; <span class="dv">0</span></a>
<a class="sourceLine" id="cb45-9" title="9">              <span class="op">}</span></a>
<a class="sourceLine" id="cb45-10" title="10">          <span class="op">}</span></a></code></pre></div>
<p>And use them like usual:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb46-1" title="1"></a>
<a class="sourceLine" id="cb46-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb46-3" title="3">              <span class="kw">let</span> minus_two = Number <span class="op">{</span></a>
<a class="sourceLine" id="cb46-4" title="4">                  odd: <span class="cn">false</span>,</a>
<a class="sourceLine" id="cb46-5" title="5">                  value: -<span class="dv">2</span>,</a>
<a class="sourceLine" id="cb46-6" title="6">              <span class="op">}</span>;</a>
<a class="sourceLine" id="cb46-7" title="7">              <span class="pp">println!</span>(<span class="st">&quot;positive? {}&quot;</span>, minus_two.is_strictly_positive());</a>
<a class="sourceLine" id="cb46-8" title="8">              <span class="co">// this prints &quot;positive? false&quot;</span></a>
<a class="sourceLine" id="cb46-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>Variable bindings are immutable by default, which means their interior can't be mutated:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb47-1" title="1"></a>
<a class="sourceLine" id="cb47-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb47-3" title="3">              <span class="kw">let</span> n = Number <span class="op">{</span></a>
<a class="sourceLine" id="cb47-4" title="4">                  odd: <span class="cn">true</span>,</a>
<a class="sourceLine" id="cb47-5" title="5">                  value: <span class="dv">17</span>,</a>
<a class="sourceLine" id="cb47-6" title="6">              <span class="op">}</span>;</a>
<a class="sourceLine" id="cb47-7" title="7">              n.odd = <span class="cn">false</span>; <span class="co">// error: cannot assign to `n.odd`,</span></a>
<a class="sourceLine" id="cb47-8" title="8">                             <span class="co">// as `n` is not declared to be mutable</span></a>
<a class="sourceLine" id="cb47-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>And also that they cannot be assigned to:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb48-1" title="1"></a>
<a class="sourceLine" id="cb48-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb48-3" title="3">              <span class="kw">let</span> n = Number <span class="op">{</span></a>
<a class="sourceLine" id="cb48-4" title="4">                  odd: <span class="cn">true</span>,</a>
<a class="sourceLine" id="cb48-5" title="5">                  value: <span class="dv">17</span>,</a>
<a class="sourceLine" id="cb48-6" title="6">              <span class="op">}</span>;</a>
<a class="sourceLine" id="cb48-7" title="7">              n = Number <span class="op">{</span></a>
<a class="sourceLine" id="cb48-8" title="8">                  odd: <span class="cn">false</span>,</a>
<a class="sourceLine" id="cb48-9" title="9">                  value: <span class="dv">22</span>,</a>
<a class="sourceLine" id="cb48-10" title="10">              <span class="op">}</span>; <span class="co">// error: cannot assign twice to immutable variable `n`</span></a>
<a class="sourceLine" id="cb48-11" title="11">          <span class="op">}</span></a></code></pre></div>
<p><code>mut</code> makes a variable binding mutable:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb49-1" title="1"></a>
<a class="sourceLine" id="cb49-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb49-3" title="3">              <span class="kw">let</span> <span class="kw">mut</span> n = Number <span class="op">{</span></a>
<a class="sourceLine" id="cb49-4" title="4">                  odd: <span class="cn">true</span>,</a>
<a class="sourceLine" id="cb49-5" title="5">                  value: <span class="dv">17</span>,</a>
<a class="sourceLine" id="cb49-6" title="6">              <span class="op">}</span></a>
<a class="sourceLine" id="cb49-7" title="7">              n.value = <span class="dv">19</span>; <span class="co">// all good</span></a>
<a class="sourceLine" id="cb49-8" title="8">          <span class="op">}</span></a></code></pre></div>
<p>Traits are something multiple types can have in common:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb50-1" title="1"></a>
<a class="sourceLine" id="cb50-2" title="2">          <span class="kw">trait</span> Signed <span class="op">{</span></a>
<a class="sourceLine" id="cb50-3" title="3">              <span class="kw">fn</span> is_strictly_negative(<span class="kw">self</span>) -&gt; <span class="dt">bool</span>;</a>
<a class="sourceLine" id="cb50-4" title="4">          <span class="op">}</span></a></code></pre></div>
<p>You can implement:</p>
<ul>
<li>one of your traits on anyone's type</li>
<li>anyone's trait on one of your types</li>
<li>but not a foreign trait on a foreign type</li>
</ul>
<p>These are called the "orphan rules".</p>
<p>Here's an implementation of our trait on our type:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb51-1" title="1"></a>
<a class="sourceLine" id="cb51-2" title="2">          <span class="kw">impl</span> Signed <span class="kw">for</span> Number <span class="op">{</span></a>
<a class="sourceLine" id="cb51-3" title="3">              <span class="kw">fn</span> is_strictly_negative(<span class="kw">self</span>) -&gt; <span class="dt">bool</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-4" title="4">                  <span class="kw">self</span>.value &lt; <span class="dv">0</span></a>
<a class="sourceLine" id="cb51-5" title="5">              <span class="op">}</span></a>
<a class="sourceLine" id="cb51-6" title="6">          <span class="op">}</span></a>
<a class="sourceLine" id="cb51-7" title="7">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb51-8" title="8">              <span class="kw">let</span> n = Number <span class="op">{</span> odd: <span class="cn">false</span>, value: -<span class="dv">44</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb51-9" title="9">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, n.is_strictly_negative()); <span class="co">// prints &quot;true&quot;</span></a>
<a class="sourceLine" id="cb51-10" title="10">          <span class="op">}</span></a></code></pre></div>
<p>Our trait on a foreign type (a primitive type, even):</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb52-1" title="1"></a>
<a class="sourceLine" id="cb52-2" title="2">          <span class="kw">impl</span> Signed <span class="kw">for</span> <span class="dt">i32</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb52-3" title="3">              <span class="kw">fn</span> is_strictly_negative(<span class="kw">self</span>) -&gt; <span class="dt">bool</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb52-4" title="4">                  <span class="kw">self</span> &lt; <span class="dv">0</span></a>
<a class="sourceLine" id="cb52-5" title="5">              <span class="op">}</span></a>
<a class="sourceLine" id="cb52-6" title="6">          <span class="op">}</span></a>
<a class="sourceLine" id="cb52-7" title="7">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb52-8" title="8">              <span class="kw">let</span> n: <span class="dt">i32</span> = -<span class="dv">44</span>;</a>
<a class="sourceLine" id="cb52-9" title="9">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, n.is_strictly_negative()); <span class="co">// prints &quot;true&quot;</span></a>
<a class="sourceLine" id="cb52-10" title="10">          <span class="op">}</span></a></code></pre></div>
<p>A foreign trait on our type:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb53-1" title="1"></a>
<a class="sourceLine" id="cb53-2" title="2">          <span class="co">// the `Neg` trait is used to overload `-`, the</span></a>
<a class="sourceLine" id="cb53-3" title="3">          <span class="co">// unary minus operator.</span></a>
<a class="sourceLine" id="cb53-4" title="4">          <span class="kw">impl</span> <span class="pp">std::ops::</span>Neg <span class="kw">for</span> Number <span class="op">{</span></a>
<a class="sourceLine" id="cb53-5" title="5">              <span class="kw">type</span> Output = Number;</a>
<a class="sourceLine" id="cb53-6" title="6">              <span class="kw">fn</span> neg(<span class="kw">self</span>) -&gt; Number <span class="op">{</span></a>
<a class="sourceLine" id="cb53-7" title="7">                  Number <span class="op">{</span></a>
<a class="sourceLine" id="cb53-8" title="8">                      value: -<span class="kw">self</span>.value,</a>
<a class="sourceLine" id="cb53-9" title="9">                      odd: <span class="kw">self</span>.odd,</a>
<a class="sourceLine" id="cb53-10" title="10">                  <span class="op">}</span>        </a>
<a class="sourceLine" id="cb53-11" title="11">              <span class="op">}</span></a>
<a class="sourceLine" id="cb53-12" title="12">          <span class="op">}</span></a>
<a class="sourceLine" id="cb53-13" title="13">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb53-14" title="14">              <span class="kw">let</span> n = Number <span class="op">{</span> odd: <span class="cn">true</span>, value: <span class="dv">987</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb53-15" title="15">              <span class="kw">let</span> m = -n; <span class="co">// this is only possible because we implemented `Neg`</span></a>
<a class="sourceLine" id="cb53-16" title="16">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, m.value); <span class="co">// prints &quot;-987&quot;</span></a>
<a class="sourceLine" id="cb53-17" title="17">          <span class="op">}</span></a></code></pre></div>
<p>An <code>impl</code> block is always <em>for</em> a type, so, inside that block, <code>Self</code> means that type:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb54-1" title="1"></a>
<a class="sourceLine" id="cb54-2" title="2">          <span class="kw">impl</span> <span class="pp">std::ops::</span>Neg <span class="kw">for</span> Number <span class="op">{</span></a>
<a class="sourceLine" id="cb54-3" title="3">              <span class="kw">type</span> Output = <span class="kw">Self</span>;</a>
<a class="sourceLine" id="cb54-4" title="4">              <span class="kw">fn</span> neg(<span class="kw">self</span>) -&gt; <span class="kw">Self</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb54-5" title="5">                  <span class="kw">Self</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb54-6" title="6">                      value: -<span class="kw">self</span>.value,</a>
<a class="sourceLine" id="cb54-7" title="7">                      odd: <span class="kw">self</span>.odd,</a>
<a class="sourceLine" id="cb54-8" title="8">                  <span class="op">}</span>        </a>
<a class="sourceLine" id="cb54-9" title="9">              <span class="op">}</span></a>
<a class="sourceLine" id="cb54-10" title="10">          <span class="op">}</span></a></code></pre></div>
<p>Some traits are <em>markers</em> - they don't say that a type implements some methods, they say that certain things can be done with a type.</p>
<p>For example, <code>i32</code> implements trait <code>Copy</code> (in short, <code>i32</code> <em>is</em> <code>Copy</code>), so this works:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb55-1" title="1"></a>
<a class="sourceLine" id="cb55-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb55-3" title="3">              <span class="kw">let</span> a: <span class="dt">i32</span> = <span class="dv">15</span>;</a>
<a class="sourceLine" id="cb55-4" title="4">              <span class="kw">let</span> b = a; <span class="co">// `a` is copied</span></a>
<a class="sourceLine" id="cb55-5" title="5">              <span class="kw">let</span> c = a; <span class="co">// `a` is copied again</span></a>
<a class="sourceLine" id="cb55-6" title="6">          <span class="op">}</span></a></code></pre></div>
<p>And this also works:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb56-1" title="1"></a>
<a class="sourceLine" id="cb56-2" title="2">          <span class="kw">fn</span> print_i32(x: <span class="dt">i32</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb56-3" title="3">              <span class="pp">println!</span>(<span class="st">&quot;x = {}&quot;</span>, x);</a>
<a class="sourceLine" id="cb56-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb56-5" title="5">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb56-6" title="6">              <span class="kw">let</span> a: <span class="dt">i32</span> = <span class="dv">15</span>;</a>
<a class="sourceLine" id="cb56-7" title="7">              print_i32(a); <span class="co">// `a` is copied</span></a>
<a class="sourceLine" id="cb56-8" title="8">              print_i32(a); <span class="co">// `a` is copied again</span></a>
<a class="sourceLine" id="cb56-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>But the <code>Number</code> struct is not <code>Copy</code>, so this doesn't work:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb57-1" title="1"></a>
<a class="sourceLine" id="cb57-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb57-3" title="3">              <span class="kw">let</span> n = Number <span class="op">{</span> odd: <span class="cn">true</span>, value: <span class="dv">51</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb57-4" title="4">              <span class="kw">let</span> m = n; <span class="co">// `n` is moved into `m`</span></a>
<a class="sourceLine" id="cb57-5" title="5">              <span class="kw">let</span> o = n; <span class="co">// error: use of moved value: `n`</span></a>
<a class="sourceLine" id="cb57-6" title="6">          <span class="op">}</span></a></code></pre></div>
<p>And neither does this:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb58-1" title="1"></a>
<a class="sourceLine" id="cb58-2" title="2">          <span class="kw">fn</span> print_number(n: Number) <span class="op">{</span></a>
<a class="sourceLine" id="cb58-3" title="3">              <span class="pp">println!</span>(<span class="st">&quot;{} number {}&quot;</span>, <span class="kw">if</span> n.odd <span class="op">{</span> <span class="st">&quot;odd&quot;</span> <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> <span class="st">&quot;even&quot;</span> <span class="op">}</span>, n.value);</a>
<a class="sourceLine" id="cb58-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb58-5" title="5">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb58-6" title="6">              <span class="kw">let</span> n = Number <span class="op">{</span> odd: <span class="cn">true</span>, value: <span class="dv">51</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb58-7" title="7">              print_number(n); <span class="co">// `n` is moved</span></a>
<a class="sourceLine" id="cb58-8" title="8">              print_number(n); <span class="co">// error: use of moved value: `n`</span></a>
<a class="sourceLine" id="cb58-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>But it works if <code>print_number</code> takes an immutable reference instead:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb59-1" title="1"></a>
<a class="sourceLine" id="cb59-2" title="2">          <span class="kw">fn</span> print_number(n: &amp;Number) <span class="op">{</span></a>
<a class="sourceLine" id="cb59-3" title="3">              <span class="pp">println!</span>(<span class="st">&quot;{} number {}&quot;</span>, <span class="kw">if</span> n.odd <span class="op">{</span> <span class="st">&quot;odd&quot;</span> <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> <span class="st">&quot;even&quot;</span> <span class="op">}</span>, n.value);</a>
<a class="sourceLine" id="cb59-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb59-5" title="5">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb59-6" title="6">              <span class="kw">let</span> n = Number <span class="op">{</span> odd: <span class="cn">true</span>, value: <span class="dv">51</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb59-7" title="7">              print_number(&amp;n); <span class="co">// `n` is borrowed for the time of the call</span></a>
<a class="sourceLine" id="cb59-8" title="8">              print_number(&amp;n); <span class="co">// `n` is borrowed again</span></a>
<a class="sourceLine" id="cb59-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>It also works if a function takes a <em>mutable</em> reference - but only if our variable binding is also <code>mut</code>.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb60-1" title="1"></a>
<a class="sourceLine" id="cb60-2" title="2">          <span class="kw">fn</span> invert(n: &amp;<span class="kw">mut</span> Number) <span class="op">{</span></a>
<a class="sourceLine" id="cb60-3" title="3">              n.value = -n.value;</a>
<a class="sourceLine" id="cb60-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb60-5" title="5">          <span class="kw">fn</span> print_number(n: &amp;Number) <span class="op">{</span></a>
<a class="sourceLine" id="cb60-6" title="6">              <span class="pp">println!</span>(<span class="st">&quot;{} number {}&quot;</span>, <span class="kw">if</span> n.odd <span class="op">{</span> <span class="st">&quot;odd&quot;</span> <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> <span class="st">&quot;even&quot;</span> <span class="op">}</span>, n.value);</a>
<a class="sourceLine" id="cb60-7" title="7">          <span class="op">}</span></a>
<a class="sourceLine" id="cb60-8" title="8">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb60-9" title="9">              <span class="co">// this time, `n` is mutable</span></a>
<a class="sourceLine" id="cb60-10" title="10">              <span class="kw">let</span> <span class="kw">mut</span> n = Number <span class="op">{</span> odd: <span class="cn">true</span>, value: <span class="dv">51</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb60-11" title="11">              print_number(&amp;n);</a>
<a class="sourceLine" id="cb60-12" title="12">              invert(&amp;<span class="kw">mut</span> n); <span class="co">// `n is borrowed mutably - everything is explicit</span></a>
<a class="sourceLine" id="cb60-13" title="13">              print_number(&amp;n);</a>
<a class="sourceLine" id="cb60-14" title="14">          <span class="op">}</span></a></code></pre></div>
<p>Trait methods can also take <code>self</code> by reference or mutable reference:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb61-1" title="1"></a>
<a class="sourceLine" id="cb61-2" title="2">          <span class="kw">impl</span> <span class="pp">std::clone::</span><span class="bu">Clone</span> <span class="kw">for</span> Number <span class="op">{</span></a>
<a class="sourceLine" id="cb61-3" title="3">              <span class="kw">fn</span> clone(&amp;<span class="kw">self</span>) -&gt; <span class="kw">Self</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb61-4" title="4">                  <span class="kw">Self</span> <span class="op">{</span> ..*<span class="kw">self</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb61-5" title="5">              <span class="op">}</span></a>
<a class="sourceLine" id="cb61-6" title="6">          <span class="op">}</span></a></code></pre></div>
<p>When invoking trait methods, the receiver is borrowed implicitly:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb62-1" title="1"></a>
<a class="sourceLine" id="cb62-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb62-3" title="3">              <span class="kw">let</span> n = Number <span class="op">{</span> odd: <span class="cn">true</span>, value: <span class="dv">51</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb62-4" title="4">              <span class="kw">let</span> <span class="kw">mut</span> m = n.clone();</a>
<a class="sourceLine" id="cb62-5" title="5">              m.value += <span class="dv">100</span>;</a>
<a class="sourceLine" id="cb62-6" title="6">              </a>
<a class="sourceLine" id="cb62-7" title="7">              print_number(&amp;n);</a>
<a class="sourceLine" id="cb62-8" title="8">              print_number(&amp;m);</a>
<a class="sourceLine" id="cb62-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>To highlight this: these are equivalent:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb63-1" title="1"></a>
<a class="sourceLine" id="cb63-2" title="2">          <span class="kw">let</span> m = n.clone();</a>
<a class="sourceLine" id="cb63-3" title="3">          <span class="kw">let</span> m = <span class="pp">std::clone::</span><span class="bu">Clone</span>::clone(&amp;n);</a></code></pre></div>
<p>Marker traits like <code>Copy</code> have no methods:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb64-1" title="1"></a>
<a class="sourceLine" id="cb64-2" title="2">          <span class="co">// note: `Copy` requires that `Clone` is implemented too</span></a>
<a class="sourceLine" id="cb64-3" title="3">          <span class="kw">impl</span> <span class="pp">std::clone::</span><span class="bu">Clone</span> <span class="kw">for</span> Number <span class="op">{</span></a>
<a class="sourceLine" id="cb64-4" title="4">              <span class="kw">fn</span> clone(&amp;<span class="kw">self</span>) -&gt; <span class="kw">Self</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb64-5" title="5">                  <span class="kw">Self</span> <span class="op">{</span> ..*<span class="kw">self</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb64-6" title="6">              <span class="op">}</span></a>
<a class="sourceLine" id="cb64-7" title="7">          <span class="op">}</span></a>
<a class="sourceLine" id="cb64-8" title="8">          <span class="kw">impl</span> <span class="pp">std::marker::</span><span class="bu">Copy</span> <span class="kw">for</span> Number <span class="op">{}</span></a></code></pre></div>
<p>Now, <code>Clone</code> can still be used:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb65-1" title="1"></a>
<a class="sourceLine" id="cb65-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb65-3" title="3">              <span class="kw">let</span> n = Number <span class="op">{</span> odd: <span class="cn">true</span>, value: <span class="dv">51</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb65-4" title="4">              <span class="kw">let</span> m = n.clone();</a>
<a class="sourceLine" id="cb65-5" title="5">              <span class="kw">let</span> o = n.clone();</a>
<a class="sourceLine" id="cb65-6" title="6">          <span class="op">}</span></a></code></pre></div>
<p>But <code>Number</code> values will no longer be moved:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb66-1" title="1"></a>
<a class="sourceLine" id="cb66-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb66-3" title="3">              <span class="kw">let</span> n = Number <span class="op">{</span> odd: <span class="cn">true</span>, value: <span class="dv">51</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb66-4" title="4">              <span class="kw">let</span> m = n; <span class="co">// `m` is a copy of `n`</span></a>
<a class="sourceLine" id="cb66-5" title="5">              <span class="kw">let</span> o = n; <span class="co">// same. `n` is neither moved nor borrowed.</span></a>
<a class="sourceLine" id="cb66-6" title="6">          <span class="op">}</span></a></code></pre></div>
<p>Some traits are so common, they can be implemented automatically by using the <code>derive</code> attribute:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb67-1" title="1"></a>
<a class="sourceLine" id="cb67-2" title="2">          <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="at">,</span> <span class="bu">Copy</span><span class="at">)]</span></a>
<a class="sourceLine" id="cb67-3" title="3">          <span class="kw">struct</span> Number <span class="op">{</span></a>
<a class="sourceLine" id="cb67-4" title="4">              odd: <span class="dt">bool</span>,</a>
<a class="sourceLine" id="cb67-5" title="5">              value: <span class="dt">i32</span>,</a>
<a class="sourceLine" id="cb67-6" title="6">          <span class="op">}</span></a>
<a class="sourceLine" id="cb67-7" title="7">          <span class="co">// this expands to `impl Clone for Number` and `impl Copy for Number` blocks.</span></a></code></pre></div>
<p>Functions can be generic:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb68-1" title="1"></a>
<a class="sourceLine" id="cb68-2" title="2">          <span class="kw">fn</span> foobar&lt;T&gt;(arg: T) <span class="op">{</span></a>
<a class="sourceLine" id="cb68-3" title="3">              <span class="co">// do something with `arg`</span></a>
<a class="sourceLine" id="cb68-4" title="4">          <span class="op">}</span></a></code></pre></div>
<p>They can have multiple <em>type parameters</em>, which can then be used in the function's declaration and its body, instead of concrete types:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb69-1" title="1"></a>
<a class="sourceLine" id="cb69-2" title="2">          <span class="kw">fn</span> foobar&lt;L, R&gt;(left: L, right: R) <span class="op">{</span></a>
<a class="sourceLine" id="cb69-3" title="3">              <span class="co">// do something with `left` and `right`</span></a>
<a class="sourceLine" id="cb69-4" title="4">          <span class="op">}</span></a></code></pre></div>
<p>Type parameters usually have <em>constraints</em>, so you can actually do something with them.</p>
<p>The simplest constraints are just trait names:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb70-1" title="1"></a>
<a class="sourceLine" id="cb70-2" title="2">          <span class="kw">fn</span> print&lt;T: <span class="bu">Display</span>&gt;(value: T) <span class="op">{</span></a>
<a class="sourceLine" id="cb70-3" title="3">              <span class="pp">println!</span>(<span class="st">&quot;value = {}&quot;</span>, value);</a>
<a class="sourceLine" id="cb70-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb70-5" title="5">          <span class="kw">fn</span> print&lt;T: <span class="bu">Debug</span>&gt;(value: T) <span class="op">{</span></a>
<a class="sourceLine" id="cb70-6" title="6">              <span class="pp">println!</span>(<span class="st">&quot;value = {:?}&quot;</span>, value);</a>
<a class="sourceLine" id="cb70-7" title="7">          <span class="op">}</span></a></code></pre></div>
<p>There's a longer syntax for type parameter constraints:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb71-1" title="1"></a>
<a class="sourceLine" id="cb71-2" title="2">          <span class="kw">fn</span> print&lt;T&gt;(value: T)</a>
<a class="sourceLine" id="cb71-3" title="3">          <span class="kw">where</span></a>
<a class="sourceLine" id="cb71-4" title="4">              T: <span class="bu">Display</span>,</a>
<a class="sourceLine" id="cb71-5" title="5">          <span class="op">{</span></a>
<a class="sourceLine" id="cb71-6" title="6">              <span class="pp">println!</span>(<span class="st">&quot;value = {}&quot;</span>, value);</a>
<a class="sourceLine" id="cb71-7" title="7">          <span class="op">}</span></a></code></pre></div>
<p>Constraints can be more complicated: they can require a type parameter to implement multiple traits:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb72-1" title="1"></a>
<a class="sourceLine" id="cb72-2" title="2">          <span class="kw">use</span> <span class="pp">std::fmt::</span><span class="bu">Debug</span>;</a>
<a class="sourceLine" id="cb72-3" title="3">          <span class="kw">fn</span> compare&lt;T&gt;(left: T, right: T)</a>
<a class="sourceLine" id="cb72-4" title="4">          <span class="kw">where</span></a>
<a class="sourceLine" id="cb72-5" title="5">              T: <span class="bu">Debug</span> + <span class="bu">PartialEq</span>,</a>
<a class="sourceLine" id="cb72-6" title="6">          <span class="op">{</span></a>
<a class="sourceLine" id="cb72-7" title="7">              <span class="pp">println!</span>(<span class="st">&quot;{:?} {} {:?}&quot;</span>, left, <span class="kw">if</span> left == right <span class="op">{</span> <span class="st">&quot;==&quot;</span> <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> <span class="st">&quot;!=&quot;</span> <span class="op">}</span>, right);</a>
<a class="sourceLine" id="cb72-8" title="8">          <span class="op">}</span></a>
<a class="sourceLine" id="cb72-9" title="9">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb72-10" title="10">              compare(<span class="st">&quot;tea&quot;</span>, <span class="st">&quot;coffee&quot;</span>);</a>
<a class="sourceLine" id="cb72-11" title="11">              <span class="co">// prints: &quot;tea&quot; != &quot;coffee&quot;</span></a>
<a class="sourceLine" id="cb72-12" title="12">          <span class="op">}</span></a></code></pre></div>
<p>Generic functions can be thought of as namespaces, containing an infinity of functions with different concrete types.</p>
<p>Same as with crates, and modules, and types, generic functions can be "explored" (navigated?) using <code>::</code></p>
<div class="sourceCode" id="cb73"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb73-1" title="1"></a>
<a class="sourceLine" id="cb73-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb73-3" title="3">              <span class="kw">use</span> <span class="pp">std::any::</span>type_name;</a>
<a class="sourceLine" id="cb73-4" title="4">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, <span class="pp">type_name::</span>&lt;<span class="dt">i32</span>&gt;()); <span class="co">// prints &quot;i32&quot;</span></a>
<a class="sourceLine" id="cb73-5" title="5">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, <span class="pp">type_name::</span>&lt;(<span class="dt">f64</span>, <span class="dt">char</span>)&gt;()); <span class="co">// prints &quot;(f64, char)&quot;</span></a>
<a class="sourceLine" id="cb73-6" title="6">          <span class="op">}</span></a></code></pre></div>
<p>This is lovingly called <a href="https://turbo.fish/">turbofish syntax</a>, because <code>::&lt;&gt;</code> looks like a fish.</p>
<p>Structs can be generic too:</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb74-1" title="1"></a>
<a class="sourceLine" id="cb74-2" title="2">          <span class="kw">struct</span> Pair&lt;T&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb74-3" title="3">              a: T,</a>
<a class="sourceLine" id="cb74-4" title="4">              b: T,</a>
<a class="sourceLine" id="cb74-5" title="5">          <span class="op">}</span></a>
<a class="sourceLine" id="cb74-6" title="6">          <span class="kw">fn</span> print_type_name&lt;T&gt;(_val: &amp;T) <span class="op">{</span></a>
<a class="sourceLine" id="cb74-7" title="7">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, <span class="pp">std::any::type_name::</span>&lt;T&gt;());</a>
<a class="sourceLine" id="cb74-8" title="8">          <span class="op">}</span></a>
<a class="sourceLine" id="cb74-9" title="9">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb74-10" title="10">              <span class="kw">let</span> p1 = Pair <span class="op">{</span> a: <span class="dv">3</span>, b: <span class="dv">9</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb74-11" title="11">              <span class="kw">let</span> p2 = Pair <span class="op">{</span> a: <span class="cn">true</span>, b: <span class="cn">false</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb74-12" title="12">              print_type_name(&amp;p1); <span class="co">// prints &quot;Pair&lt;i32&gt;&quot;</span></a>
<a class="sourceLine" id="cb74-13" title="13">              print_type_name(&amp;p2); <span class="co">// prints &quot;Pair&lt;bool&gt;&quot;</span></a>
<a class="sourceLine" id="cb74-14" title="14">          <span class="op">}</span></a></code></pre></div>
<p>The standard library type <code>Vec</code> (~ a heap-allocated array), is generic:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb75-1" title="1"></a>
<a class="sourceLine" id="cb75-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb75-3" title="3">              <span class="kw">let</span> <span class="kw">mut</span> v1 = <span class="dt">Vec</span>::new();</a>
<a class="sourceLine" id="cb75-4" title="4">              v1.push(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb75-5" title="5">              <span class="kw">let</span> <span class="kw">mut</span> v2 = <span class="dt">Vec</span>::new();</a>
<a class="sourceLine" id="cb75-6" title="6">              v2.push(<span class="cn">false</span>);</a>
<a class="sourceLine" id="cb75-7" title="7">              print_type_name(&amp;v1); <span class="co">// prints &quot;Vec&lt;i32&gt;&quot;</span></a>
<a class="sourceLine" id="cb75-8" title="8">              print_type_name(&amp;v2); <span class="co">// prints &quot;Vec&lt;bool&gt;&quot;</span></a>
<a class="sourceLine" id="cb75-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>Speaking of <code>Vec</code>, it comes with a macro that gives more or less "vec literals":</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb76-1" title="1"></a>
<a class="sourceLine" id="cb76-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb76-3" title="3">              <span class="kw">let</span> v1 = <span class="pp">vec!</span><span class="op">[</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span><span class="op">]</span>;</a>
<a class="sourceLine" id="cb76-4" title="4">              <span class="kw">let</span> v2 = <span class="pp">vec!</span><span class="op">[</span><span class="cn">true</span>, <span class="cn">false</span>, <span class="cn">true</span><span class="op">]</span>;</a>
<a class="sourceLine" id="cb76-5" title="5">              print_type_name(&amp;v1); <span class="co">// prints &quot;Vec&lt;i32&gt;&quot;</span></a>
<a class="sourceLine" id="cb76-6" title="6">              print_type_name(&amp;v2); <span class="co">// prints &quot;Vec&lt;bool&gt;&quot;</span></a>
<a class="sourceLine" id="cb76-7" title="7">          <span class="op">}</span></a></code></pre></div>
<p>All of <code>name!()</code>, <code>name![]</code> or <code>name!{}</code> invoke a macro. Macros just expand to regular code.</p>
<p>In fact, <code>println</code> is a macro:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb77-1" title="1"></a>
<a class="sourceLine" id="cb77-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb77-3" title="3">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, <span class="st">&quot;Hello there!&quot;</span>);</a>
<a class="sourceLine" id="cb77-4" title="4">          <span class="op">}</span></a></code></pre></div>
<p>This expands to something that has the same effect as:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb78-1" title="1"></a>
<a class="sourceLine" id="cb78-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb78-3" title="3">              <span class="kw">use</span> <span class="pp">std::io::</span><span class="op">{</span><span class="kw">self</span>, Write<span class="op">}</span>;</a>
<a class="sourceLine" id="cb78-4" title="4">              <span class="pp">io::</span>stdout().lock().write_all(<span class="st">b&quot;Hello there!</span><span class="sc">\n</span><span class="st">&quot;</span>).unwrap();</a>
<a class="sourceLine" id="cb78-5" title="5">          <span class="op">}</span></a></code></pre></div>
<p><code>panic</code> is also a macro. It violently stops execution with an error message, and the file name / line number of the error, if enabled:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb79-1" title="1"></a>
<a class="sourceLine" id="cb79-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb79-3" title="3">              <span class="pp">panic!</span>(<span class="st">&quot;This panics&quot;</span>);</a>
<a class="sourceLine" id="cb79-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb79-5" title="5">          <span class="co">// output: thread &#39;main&#39; panicked at &#39;This panics&#39;, src/main.rs:3:5</span></a></code></pre></div>
<p>Some methods also panic. For example, the <code>Option</code> type can contain something, or it can contain nothing. If <code>.unwrap()</code> is called on it, and it contains nothing, it panics:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb80-1" title="1"></a>
<a class="sourceLine" id="cb80-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb80-3" title="3">              <span class="kw">let</span> o1: <span class="dt">Option</span>&lt;<span class="dt">i32</span>&gt; = <span class="cn">Some</span>(<span class="dv">128</span>);</a>
<a class="sourceLine" id="cb80-4" title="4">              o1.unwrap(); <span class="co">// this is fine</span></a>
<a class="sourceLine" id="cb80-5" title="5">              <span class="kw">let</span> o2: <span class="dt">Option</span>&lt;<span class="dt">i32</span>&gt; = <span class="cn">None</span>;</a>
<a class="sourceLine" id="cb80-6" title="6">              o2.unwrap(); <span class="co">// this panics!</span></a>
<a class="sourceLine" id="cb80-7" title="7">          <span class="op">}</span></a>
<a class="sourceLine" id="cb80-8" title="8">          <span class="co">// output: thread &#39;main&#39; panicked at &#39;called `Option::unwrap()` on a `None` value&#39;, src/libcore/option.rs:378:21</span></a></code></pre></div>
<p><code>Option</code> is not a struct - it's an <code>enum</code>, with two variants.</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb81-1" title="1"></a>
<a class="sourceLine" id="cb81-2" title="2">          <span class="kw">enum</span> <span class="dt">Option</span>&lt;T&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb81-3" title="3">              <span class="cn">None</span>,</a>
<a class="sourceLine" id="cb81-4" title="4">              <span class="cn">Some</span>(T),</a>
<a class="sourceLine" id="cb81-5" title="5">          <span class="op">}</span></a>
<a class="sourceLine" id="cb81-6" title="6">          <span class="kw">impl</span>&lt;T&gt; <span class="dt">Option</span>&lt;T&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb81-7" title="7">              <span class="kw">fn</span> unwrap(<span class="kw">self</span>) -&gt; T <span class="op">{</span></a>
<a class="sourceLine" id="cb81-8" title="8">                  <span class="co">// enums variants can be used in patterns:</span></a>
<a class="sourceLine" id="cb81-9" title="9">                  <span class="kw">match</span> <span class="kw">self</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb81-10" title="10">                      <span class="kw">Self</span>::<span class="cn">Some</span>(t) =&gt; t,</a>
<a class="sourceLine" id="cb81-11" title="11">                      <span class="kw">Self</span>::<span class="cn">None</span> =&gt; <span class="pp">panic!</span>(<span class="st">&quot;.unwrap() called on a None option&quot;</span>),</a>
<a class="sourceLine" id="cb81-12" title="12">                  <span class="op">}</span></a>
<a class="sourceLine" id="cb81-13" title="13">              <span class="op">}</span></a>
<a class="sourceLine" id="cb81-14" title="14">          <span class="op">}</span></a>
<a class="sourceLine" id="cb81-15" title="15">          <span class="kw">use</span> <span class="kw">self</span>::<span class="dt">Option</span>::<span class="op">{</span><span class="cn">None</span>, <span class="cn">Some</span><span class="op">}</span>;</a>
<a class="sourceLine" id="cb81-16" title="16">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb81-17" title="17">              <span class="kw">let</span> o1: <span class="dt">Option</span>&lt;<span class="dt">i32</span>&gt; = <span class="cn">Some</span>(<span class="dv">128</span>);</a>
<a class="sourceLine" id="cb81-18" title="18">              o1.unwrap(); <span class="co">// this is fine</span></a>
<a class="sourceLine" id="cb81-19" title="19">              <span class="kw">let</span> o2: <span class="dt">Option</span>&lt;<span class="dt">i32</span>&gt; = <span class="cn">None</span>;</a>
<a class="sourceLine" id="cb81-20" title="20">              o2.unwrap(); <span class="co">// this panics!</span></a>
<a class="sourceLine" id="cb81-21" title="21">          <span class="op">}</span></a>
<a class="sourceLine" id="cb81-22" title="22">          <span class="co">// output: thread &#39;main&#39; panicked at &#39;.unwrap() called on a None option&#39;, src/main.rs:11:27</span></a></code></pre></div>
<p><code>Result</code> is also an enum, it can either contain something, or an error:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb82-1" title="1"></a>
<a class="sourceLine" id="cb82-2" title="2">          <span class="kw">enum</span> <span class="dt">Result</span>&lt;T, E&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb82-3" title="3">              <span class="cn">Ok</span>(T),</a>
<a class="sourceLine" id="cb82-4" title="4">              <span class="cn">Err</span>(E),</a>
<a class="sourceLine" id="cb82-5" title="5">          <span class="op">}</span></a></code></pre></div>
<p>It also panics when unwrapped and containing an error.</p>
<p>Variables bindings have a "lifetime":</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb83-1" title="1"></a>
<a class="sourceLine" id="cb83-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb83-3" title="3">              <span class="co">// `x` doesn&#39;t exist yet</span></a>
<a class="sourceLine" id="cb83-4" title="4">              <span class="op">{</span></a>
<a class="sourceLine" id="cb83-5" title="5">                  <span class="kw">let</span> x = <span class="dv">42</span>; <span class="co">// `x` starts existing</span></a>
<a class="sourceLine" id="cb83-6" title="6">                  <span class="pp">println!</span>(<span class="st">&quot;x = {}&quot;</span>, x);</a>
<a class="sourceLine" id="cb83-7" title="7">                  <span class="co">// `x` stops existing</span></a>
<a class="sourceLine" id="cb83-8" title="8">              <span class="op">}</span></a>
<a class="sourceLine" id="cb83-9" title="9">              <span class="co">// `x` no longer exists</span></a>
<a class="sourceLine" id="cb83-10" title="10">          <span class="op">}</span></a></code></pre></div>
<p>Similarly, references have a lifetime:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb84-1" title="1"></a>
<a class="sourceLine" id="cb84-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb84-3" title="3">              <span class="co">// `x` doesn&#39;t exist yet</span></a>
<a class="sourceLine" id="cb84-4" title="4">              <span class="op">{</span></a>
<a class="sourceLine" id="cb84-5" title="5">                  <span class="kw">let</span> x = <span class="dv">42</span>; <span class="co">// `x` starts existing</span></a>
<a class="sourceLine" id="cb84-6" title="6">                  <span class="kw">let</span> x_ref = &amp;x; <span class="co">// `x_ref` starts existing - it borrows `x`</span></a>
<a class="sourceLine" id="cb84-7" title="7">                  <span class="pp">println!</span>(<span class="st">&quot;x_ref = {}&quot;</span>, x_ref);</a>
<a class="sourceLine" id="cb84-8" title="8">                  <span class="co">// `x_ref` stops existing</span></a>
<a class="sourceLine" id="cb84-9" title="9">                  <span class="co">// `x` stops existing</span></a>
<a class="sourceLine" id="cb84-10" title="10">              <span class="op">}</span></a>
<a class="sourceLine" id="cb84-11" title="11">              <span class="co">// `x` no longer exists</span></a>
<a class="sourceLine" id="cb84-12" title="12">          <span class="op">}</span></a></code></pre></div>
<p>The lifetime of a reference cannot exceed the lifetime of the variable binding it borrows:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb85-1" title="1"></a>
<a class="sourceLine" id="cb85-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb85-3" title="3">              <span class="kw">let</span> x_ref = <span class="op">{</span></a>
<a class="sourceLine" id="cb85-4" title="4">                  <span class="kw">let</span> x = <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb85-5" title="5">                  &amp;x</a>
<a class="sourceLine" id="cb85-6" title="6">              <span class="op">}</span>;</a>
<a class="sourceLine" id="cb85-7" title="7">              <span class="pp">println!</span>(<span class="st">&quot;x_ref = {}&quot;</span>, x_ref);</a>
<a class="sourceLine" id="cb85-8" title="8">              <span class="co">// error: `x` does not live long enough</span></a>
<a class="sourceLine" id="cb85-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>A variable binding can be immutably borrowed multiple times:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb86-1" title="1"></a>
<a class="sourceLine" id="cb86-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb86-3" title="3">              <span class="kw">let</span> x = <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb86-4" title="4">              <span class="kw">let</span> x_ref1 = &amp;x;</a>
<a class="sourceLine" id="cb86-5" title="5">              <span class="kw">let</span> x_ref2 = &amp;x;</a>
<a class="sourceLine" id="cb86-6" title="6">              <span class="kw">let</span> x_ref3 = &amp;x;</a>
<a class="sourceLine" id="cb86-7" title="7">              <span class="pp">println!</span>(<span class="st">&quot;{} {} {}&quot;</span>, x_ref1, x_ref2, x_ref3);</a>
<a class="sourceLine" id="cb86-8" title="8">          <span class="op">}</span></a></code></pre></div>
<p>While borrowed, a variable binding cannot be mutated:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb87-1" title="1"></a>
<a class="sourceLine" id="cb87-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb87-3" title="3">              <span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb87-4" title="4">              <span class="kw">let</span> x_ref = &amp;x;</a>
<a class="sourceLine" id="cb87-5" title="5">              x = <span class="dv">13</span>;</a>
<a class="sourceLine" id="cb87-6" title="6">              <span class="pp">println!</span>(<span class="st">&quot;x_ref = {}&quot;</span>, x_ref);</a>
<a class="sourceLine" id="cb87-7" title="7">              <span class="co">// error: cannot assign to `x` because it is borrowed</span></a>
<a class="sourceLine" id="cb87-8" title="8">          <span class="op">}</span></a></code></pre></div>
<p>While immutably borrowed, a variable cannot be <em>mutably borrowed</em>:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb88-1" title="1"></a>
<a class="sourceLine" id="cb88-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb88-3" title="3">              <span class="kw">let</span> <span class="kw">mut</span> x = <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb88-4" title="4">              <span class="kw">let</span> x_ref1 = &amp;x;</a>
<a class="sourceLine" id="cb88-5" title="5">              <span class="kw">let</span> x_ref2 = &amp;<span class="kw">mut</span> x;</a>
<a class="sourceLine" id="cb88-6" title="6">              <span class="co">// error: cannot borrow `x` as mutable because it is also borrowed as immutable</span></a>
<a class="sourceLine" id="cb88-7" title="7">              <span class="pp">println!</span>(<span class="st">&quot;x_ref1 = {}&quot;</span>, x_ref1);</a>
<a class="sourceLine" id="cb88-8" title="8">          <span class="op">}</span></a></code></pre></div>
<p>References in function arguments also have lifetimes:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb89-1" title="1"></a>
<a class="sourceLine" id="cb89-2" title="2">          <span class="kw">fn</span> print(x: &amp;<span class="dt">i32</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb89-3" title="3">              <span class="co">// `x` is borrowed (from the outside) for the</span></a>
<a class="sourceLine" id="cb89-4" title="4">              <span class="co">// entire time this function is called.</span></a>
<a class="sourceLine" id="cb89-5" title="5">          <span class="op">}</span></a></code></pre></div>
<p>Functions with reference arguments can be called with borrows that have different lifetimes, so:</p>
<ul>
<li>All functions that take references are generic</li>
<li>Lifetimes are generic parameters</li>
</ul>
<p>Lifetimes' names start with a single quote, <code>'</code>:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb90-1" title="1"></a>
<a class="sourceLine" id="cb90-2" title="2">          <span class="co">// elided (non-named) lifetimes:</span></a>
<a class="sourceLine" id="cb90-3" title="3">          <span class="kw">fn</span> print(x: &amp;<span class="dt">i32</span>) <span class="op">{}</span></a>
<a class="sourceLine" id="cb90-4" title="4">          <span class="co">// named lifetimes:</span></a>
<a class="sourceLine" id="cb90-5" title="5">          <span class="kw">fn</span> print&lt;<span class="ot">&#39;a</span>&gt;(x: &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>) <span class="op">{}</span></a></code></pre></div>
<p>This allows returning references whose lifetime depend on the lifetime of the arguments:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb91-1" title="1"></a>
<a class="sourceLine" id="cb91-2" title="2">          <span class="kw">struct</span> Number <span class="op">{</span></a>
<a class="sourceLine" id="cb91-3" title="3">              value: <span class="dt">i32</span>,</a>
<a class="sourceLine" id="cb91-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb91-5" title="5">          <span class="kw">fn</span> number_value&lt;<span class="ot">&#39;a</span>&gt;(num: &amp;<span class="ot">&#39;a</span> Number) -&gt; &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb91-6" title="6">              &amp;num.value</a>
<a class="sourceLine" id="cb91-7" title="7">          <span class="op">}</span></a>
<a class="sourceLine" id="cb91-8" title="8">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb91-9" title="9">              <span class="kw">let</span> n = Number <span class="op">{</span> value: <span class="dv">47</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb91-10" title="10">              <span class="kw">let</span> v = number_value(&amp;n);</a>
<a class="sourceLine" id="cb91-11" title="11">              <span class="co">// `v` borrows `n` (immutably), thus: `v` cannot outlive `n`.</span></a>
<a class="sourceLine" id="cb91-12" title="12">              <span class="co">// While `v` exists, `n` cannot be mutably borrowed, mutated, moved, etc.</span></a>
<a class="sourceLine" id="cb91-13" title="13">          <span class="op">}</span></a></code></pre></div>
<p>When there is a <em>single</em> input lifetime, it doesn't need to be named, and everything has the same lifetime, so the two functions below are equivalent:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb92-1" title="1"></a>
<a class="sourceLine" id="cb92-2" title="2">          <span class="kw">fn</span> number_value&lt;<span class="ot">&#39;a</span>&gt;(num: &amp;<span class="ot">&#39;a</span> Number) -&gt; &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb92-3" title="3">              &amp;num.value</a>
<a class="sourceLine" id="cb92-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb92-5" title="5">          <span class="kw">fn</span> number_value(num: &amp;Number) -&gt; &amp;<span class="dt">i32</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb92-6" title="6">              &amp;num.value</a>
<a class="sourceLine" id="cb92-7" title="7">          <span class="op">}</span></a></code></pre></div>
<p>Structs can also be <em>generic over lifetimes</em>, which allows them to hold references:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb93-1" title="1"></a>
<a class="sourceLine" id="cb93-2" title="2">          <span class="kw">struct</span> NumRef&lt;<span class="ot">&#39;a</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb93-3" title="3">              x: &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>,</a>
<a class="sourceLine" id="cb93-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb93-5" title="5">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb93-6" title="6">              <span class="kw">let</span> x: <span class="dt">i32</span> = <span class="dv">99</span>;</a>
<a class="sourceLine" id="cb93-7" title="7">              <span class="kw">let</span> x_ref = NumRef <span class="op">{</span> x: &amp;x <span class="op">}</span>;</a>
<a class="sourceLine" id="cb93-8" title="8">              <span class="co">// `x_ref` cannot outlive `x`, etc.</span></a>
<a class="sourceLine" id="cb93-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>The same code, but with an additional function:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb94-1" title="1"></a>
<a class="sourceLine" id="cb94-2" title="2">          <span class="kw">struct</span> NumRef&lt;<span class="ot">&#39;a</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb94-3" title="3">              x: &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>,</a>
<a class="sourceLine" id="cb94-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb94-5" title="5">          <span class="kw">fn</span> as_num_ref&lt;<span class="ot">&#39;a</span>&gt;(x: &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>) -&gt; NumRef&lt;<span class="ot">&#39;a</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb94-6" title="6">              NumRef <span class="op">{</span> x: &amp;x <span class="op">}</span></a>
<a class="sourceLine" id="cb94-7" title="7">          <span class="op">}</span></a>
<a class="sourceLine" id="cb94-8" title="8">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb94-9" title="9">              <span class="kw">let</span> x: <span class="dt">i32</span> = <span class="dv">99</span>;</a>
<a class="sourceLine" id="cb94-10" title="10">              <span class="kw">let</span> x_ref = as_num_ref(&amp;x);</a>
<a class="sourceLine" id="cb94-11" title="11">              <span class="co">// `x_ref` cannot outlive `x`, etc.</span></a>
<a class="sourceLine" id="cb94-12" title="12">          <span class="op">}</span></a></code></pre></div>
<p>The same code, but with "elided" lifetimes:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb95-1" title="1"></a>
<a class="sourceLine" id="cb95-2" title="2">          <span class="kw">struct</span> NumRef&lt;<span class="ot">&#39;a</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb95-3" title="3">              x: &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span>,</a>
<a class="sourceLine" id="cb95-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb95-5" title="5">          <span class="kw">fn</span> as_num_ref(x: &amp;<span class="dt">i32</span>) -&gt; NumRef&lt;<span class="ot">&#39;_</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb95-6" title="6">              NumRef <span class="op">{</span> x: &amp;x <span class="op">}</span></a>
<a class="sourceLine" id="cb95-7" title="7">          <span class="op">}</span></a>
<a class="sourceLine" id="cb95-8" title="8">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb95-9" title="9">              <span class="kw">let</span> x: <span class="dt">i32</span> = <span class="dv">99</span>;</a>
<a class="sourceLine" id="cb95-10" title="10">              <span class="kw">let</span> x_ref = as_num_ref(&amp;x);</a>
<a class="sourceLine" id="cb95-11" title="11">              <span class="co">// `x_ref` cannot outlive `x`, etc.</span></a>
<a class="sourceLine" id="cb95-12" title="12">          <span class="op">}</span></a></code></pre></div>
<p><code>impl</code> blocks can be generic over lifetimes too:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb96-1" title="1"></a>
<a class="sourceLine" id="cb96-2" title="2">          <span class="kw">impl</span>&lt;<span class="ot">&#39;a</span>&gt; NumRef&lt;<span class="ot">&#39;a</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb96-3" title="3">              <span class="kw">fn</span> as_i32_ref(&amp;<span class="ot">&#39;a</span> <span class="kw">self</span>) -&gt; &amp;<span class="ot">&#39;a</span> <span class="dt">i32</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb96-4" title="4">                  <span class="kw">self</span>.x</a>
<a class="sourceLine" id="cb96-5" title="5">              <span class="op">}</span></a>
<a class="sourceLine" id="cb96-6" title="6">          <span class="op">}</span></a>
<a class="sourceLine" id="cb96-7" title="7">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb96-8" title="8">              <span class="kw">let</span> x: <span class="dt">i32</span> = <span class="dv">99</span>;</a>
<a class="sourceLine" id="cb96-9" title="9">              <span class="kw">let</span> x_num_ref = NumRef <span class="op">{</span> x: &amp;x <span class="op">}</span>;</a>
<a class="sourceLine" id="cb96-10" title="10">              <span class="kw">let</span> x_i32_ref = x_num_ref.as_i32_ref();</a>
<a class="sourceLine" id="cb96-11" title="11">              <span class="co">// neither ref can outlive `x`</span></a>
<a class="sourceLine" id="cb96-12" title="12">          <span class="op">}</span></a></code></pre></div>
<p>But you can do elision ("to elide") there too:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb97-1" title="1"></a>
<a class="sourceLine" id="cb97-2" title="2">          <span class="kw">impl</span>&lt;<span class="ot">&#39;a</span>&gt; NumRef&lt;<span class="ot">&#39;a</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb97-3" title="3">              <span class="kw">fn</span> as_i32_ref(&amp;<span class="kw">self</span>) -&gt; &amp;<span class="dt">i32</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb97-4" title="4">                  <span class="kw">self</span>.x</a>
<a class="sourceLine" id="cb97-5" title="5">              <span class="op">}</span></a>
<a class="sourceLine" id="cb97-6" title="6">          <span class="op">}</span></a></code></pre></div>
<p>You can elide even harder, if you never need the name:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb98-1" title="1"></a>
<a class="sourceLine" id="cb98-2" title="2">          <span class="kw">impl</span> NumRef&lt;<span class="ot">&#39;_</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb98-3" title="3">              <span class="kw">fn</span> as_i32_ref(&amp;<span class="kw">self</span>) -&gt; &amp;<span class="dt">i32</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb98-4" title="4">                  <span class="kw">self</span>.x</a>
<a class="sourceLine" id="cb98-5" title="5">              <span class="op">}</span></a>
<a class="sourceLine" id="cb98-6" title="6">          <span class="op">}</span></a></code></pre></div>
<p>There is a special lifetime, named <code>'static</code>, which is valid for the entire program's lifetime.</p>
<p>String literals are <code>'static</code>:</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb99-1" title="1"></a>
<a class="sourceLine" id="cb99-2" title="2">          <span class="kw">struct</span> Person <span class="op">{</span></a>
<a class="sourceLine" id="cb99-3" title="3">              name: &amp;<span class="ot">&#39;static</span> <span class="dt">str</span>,</a>
<a class="sourceLine" id="cb99-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb99-5" title="5">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb99-6" title="6">              <span class="kw">let</span> p = Person <span class="op">{</span></a>
<a class="sourceLine" id="cb99-7" title="7">                  name: <span class="st">&quot;fasterthanlime&quot;</span>,</a>
<a class="sourceLine" id="cb99-8" title="8">              <span class="op">}</span>;</a>
<a class="sourceLine" id="cb99-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>But <em>owned strings</em> are not static:</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb100-1" title="1"></a>
<a class="sourceLine" id="cb100-2" title="2">          <span class="kw">struct</span> Person <span class="op">{</span></a>
<a class="sourceLine" id="cb100-3" title="3">              name: &amp;<span class="ot">&#39;static</span> <span class="dt">str</span>,</a>
<a class="sourceLine" id="cb100-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb100-5" title="5">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb100-6" title="6">              <span class="kw">let</span> name = <span class="pp">format!</span>(<span class="st">&quot;fasterthan{}&quot;</span>, <span class="st">&quot;lime&quot;</span>);</a>
<a class="sourceLine" id="cb100-7" title="7">              <span class="kw">let</span> p = Person <span class="op">{</span> name: &amp;name <span class="op">}</span>;</a>
<a class="sourceLine" id="cb100-8" title="8">              <span class="co">// error: `name` does not live long enough</span></a>
<a class="sourceLine" id="cb100-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>In that last example, the local <code>name</code> is not a <code>&amp;'static str</code>, it's a <code>String</code>. It's been allocated dynamically, and it will be freed. Its lifetime is <em>less</em> than the whole program (even though it happens to be in <code>main</code>).</p>
<p>To store a non- <code>'static</code> string in <code>Person</code>, it needs to either:</p>
<p>A) Be generic over a lifetime:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb101-1" title="1"></a>
<a class="sourceLine" id="cb101-2" title="2">          <span class="kw">struct</span> Person&lt;<span class="ot">&#39;a</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb101-3" title="3">              name: &amp;<span class="ot">&#39;a</span> <span class="dt">str</span>,</a>
<a class="sourceLine" id="cb101-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb101-5" title="5">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb101-6" title="6">              <span class="kw">let</span> name = <span class="pp">format!</span>(<span class="st">&quot;fasterthan{}&quot;</span>, <span class="st">&quot;lime&quot;</span>);</a>
<a class="sourceLine" id="cb101-7" title="7">              <span class="kw">let</span> p = Person <span class="op">{</span> name: &amp;name <span class="op">}</span>;</a>
<a class="sourceLine" id="cb101-8" title="8">              <span class="co">// `p` cannot outlive `name`</span></a>
<a class="sourceLine" id="cb101-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>or</p>
<p>B) Take ownership of the string</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb102-1" title="1"></a>
<a class="sourceLine" id="cb102-2" title="2">          <span class="kw">struct</span> Person <span class="op">{</span></a>
<a class="sourceLine" id="cb102-3" title="3">              name: <span class="dt">String</span>,</a>
<a class="sourceLine" id="cb102-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb102-5" title="5">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb102-6" title="6">              <span class="kw">let</span> name = <span class="pp">format!</span>(<span class="st">&quot;fasterthan{}&quot;</span>, <span class="st">&quot;lime&quot;</span>);</a>
<a class="sourceLine" id="cb102-7" title="7">              <span class="kw">let</span> p = Person <span class="op">{</span> name: name <span class="op">}</span>;</a>
<a class="sourceLine" id="cb102-8" title="8">              <span class="co">// `name` was moved into `p`, their lifetimes are no longer tied.</span></a>
<a class="sourceLine" id="cb102-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>Speaking of: in a struct literal, when a field is set to a variable binding of the same name:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb103-1" title="1"></a>
<a class="sourceLine" id="cb103-2" title="2">              <span class="kw">let</span> p = Person <span class="op">{</span> name: name <span class="op">}</span>;</a></code></pre></div>
<p>It can be shortened like this:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb104-1" title="1"></a>
<a class="sourceLine" id="cb104-2" title="2">              <span class="kw">let</span> p = Person <span class="op">{</span> name <span class="op">}</span>;</a></code></pre></div>
<p>For many types in Rust, there are owned and non-owned variants:</p>
<ul>
<li>Strings: <code>String</code> is owned, <code>&amp;str</code> is a reference</li>
<li>Paths: <code>PathBuf</code> is owned, <code>&amp;Path</code> is a reference</li>
<li>Collections: <code>Vec&lt;T&gt;</code> is owned, <code>&amp;[T]</code> is a reference</li>
</ul>
<p>Rust has slices - they're a reference to multiple contiguous elements.</p>
<p>You can borrow a slice of a vector, for example:</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb105-1" title="1"></a>
<a class="sourceLine" id="cb105-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb105-3" title="3">              <span class="kw">let</span> v = <span class="pp">vec!</span><span class="op">[</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span><span class="op">]</span>;</a>
<a class="sourceLine" id="cb105-4" title="4">              <span class="kw">let</span> v2 = &amp;v<span class="op">[</span><span class="dv">2</span>..<span class="dv">4</span><span class="op">]</span>;</a>
<a class="sourceLine" id="cb105-5" title="5">              <span class="pp">println!</span>(<span class="st">&quot;v2 = {:?}&quot;</span>, v2);</a>
<a class="sourceLine" id="cb105-6" title="6">          <span class="op">}</span></a>
<a class="sourceLine" id="cb105-7" title="7">          <span class="co">// output:</span></a>
<a class="sourceLine" id="cb105-8" title="8">          <span class="co">// v2 = [3, 4]</span></a></code></pre></div>
<p>The above is not magical. The indexing operator ( <code>foo[index]</code>) is overloaded with the <code>Index</code> and <code>IndexMut</code> traits.</p>
<p>The <code>..</code> syntax is just range literals. Ranges are just a few structs defined in the standard library.</p>
<p>They can be open-ended, and their rightmost bound can be inclusive, if it's preceded by <code>=</code>.</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb106-1" title="1"></a>
<a class="sourceLine" id="cb106-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb106-3" title="3">              <span class="co">// 0 or greater</span></a>
<a class="sourceLine" id="cb106-4" title="4">              <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, (<span class="dv">0</span>..).contains(&amp;<span class="dv">100</span>)); <span class="co">// true</span></a>
<a class="sourceLine" id="cb106-5" title="5">              <span class="co">// strictly less than 20</span></a>
<a class="sourceLine" id="cb106-6" title="6">              <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, (..<span class="dv">20</span>).contains(&amp;<span class="dv">20</span>)); <span class="co">// false</span></a>
<a class="sourceLine" id="cb106-7" title="7">              <span class="co">// 20 or less than 20</span></a>
<a class="sourceLine" id="cb106-8" title="8">              <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, (..=<span class="dv">20</span>).contains(&amp;<span class="dv">20</span>)); <span class="co">// true</span></a>
<a class="sourceLine" id="cb106-9" title="9">              <span class="co">// only 3, 4, 5</span></a>
<a class="sourceLine" id="cb106-10" title="10">              <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, (<span class="dv">3</span>..<span class="dv">6</span>).contains(&amp;<span class="dv">4</span>)); <span class="co">// true</span></a>
<a class="sourceLine" id="cb106-11" title="11">          <span class="op">}</span></a></code></pre></div>
<p>Borrowing rules apply to slices.</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb107-1" title="1"></a>
<a class="sourceLine" id="cb107-2" title="2">          <span class="kw">fn</span> tail(s: &amp;<span class="op">[</span><span class="dt">u8</span><span class="op">]</span>) -&gt; &amp;<span class="op">[</span><span class="dt">u8</span><span class="op">]</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb107-3" title="3">            &amp;s<span class="op">[</span><span class="dv">1</span>..<span class="op">]</span> </a>
<a class="sourceLine" id="cb107-4" title="4">          <span class="op">}</span></a>
<a class="sourceLine" id="cb107-5" title="5">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb107-6" title="6">              <span class="kw">let</span> x = &amp;<span class="op">[</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span><span class="op">]</span>;</a>
<a class="sourceLine" id="cb107-7" title="7">              <span class="kw">let</span> y = tail(x);</a>
<a class="sourceLine" id="cb107-8" title="8">              <span class="pp">println!</span>(<span class="st">&quot;y = {:?}&quot;</span>, y);</a>
<a class="sourceLine" id="cb107-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>This is the same as:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb108-1" title="1"></a>
<a class="sourceLine" id="cb108-2" title="2">          <span class="kw">fn</span> tail&lt;<span class="ot">&#39;a</span>&gt;(s: &amp;<span class="ot">&#39;a</span> <span class="op">[</span><span class="dt">u8</span><span class="op">]</span>) -&gt; &amp;<span class="ot">&#39;a</span> <span class="op">[</span><span class="dt">u8</span><span class="op">]</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb108-3" title="3">            &amp;s<span class="op">[</span><span class="dv">1</span>..<span class="op">]</span> </a>
<a class="sourceLine" id="cb108-4" title="4">          <span class="op">}</span></a></code></pre></div>
<p>This is legal:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb109-1" title="1"></a>
<a class="sourceLine" id="cb109-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb109-3" title="3">              <span class="kw">let</span> y = <span class="op">{</span></a>
<a class="sourceLine" id="cb109-4" title="4">                  <span class="kw">let</span> x = &amp;<span class="op">[</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span><span class="op">]</span>;</a>
<a class="sourceLine" id="cb109-5" title="5">                  tail(x)</a>
<a class="sourceLine" id="cb109-6" title="6">              <span class="op">}</span>;</a>
<a class="sourceLine" id="cb109-7" title="7">              <span class="pp">println!</span>(<span class="st">&quot;y = {:?}&quot;</span>, y);</a>
<a class="sourceLine" id="cb109-8" title="8">          <span class="op">}</span></a></code></pre></div>
<p>...but only because <code>[1, 2, 3, 4, 5]</code> is a <code>'static</code> array.</p>
<p>So, this is illegal:</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb110-1" title="1"></a>
<a class="sourceLine" id="cb110-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb110-3" title="3">              <span class="kw">let</span> y = <span class="op">{</span></a>
<a class="sourceLine" id="cb110-4" title="4">                  <span class="kw">let</span> v = <span class="pp">vec!</span><span class="op">[</span><span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span><span class="op">]</span>;</a>
<a class="sourceLine" id="cb110-5" title="5">                  tail(&amp;v)</a>
<a class="sourceLine" id="cb110-6" title="6">                  <span class="co">// error: `v` does not live long enough</span></a>
<a class="sourceLine" id="cb110-7" title="7">              <span class="op">}</span>;</a>
<a class="sourceLine" id="cb110-8" title="8">              <span class="pp">println!</span>(<span class="st">&quot;y = {:?}&quot;</span>, y);</a>
<a class="sourceLine" id="cb110-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>...because a vector is heap-allocated, and it has a non- <code>'static</code> lifetime.</p>
<p><code>&amp;str</code> values are really slices.</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb111-1" title="1"></a>
<a class="sourceLine" id="cb111-2" title="2">          <span class="kw">fn</span> file_ext(name: &amp;<span class="dt">str</span>) -&gt; <span class="dt">Option</span>&lt;&amp;<span class="dt">str</span>&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb111-3" title="3">              <span class="co">// this does not create a new string - it returns</span></a>
<a class="sourceLine" id="cb111-4" title="4">              <span class="co">// a slice of the argument.</span></a>
<a class="sourceLine" id="cb111-5" title="5">              name.split(<span class="st">&quot;.&quot;</span>).last()</a>
<a class="sourceLine" id="cb111-6" title="6">          <span class="op">}</span></a>
<a class="sourceLine" id="cb111-7" title="7">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb111-8" title="8">              <span class="kw">let</span> name = <span class="st">&quot;Read me. Or don&#39;t.txt&quot;</span>;</a>
<a class="sourceLine" id="cb111-9" title="9">              <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(ext) = file_ext(name) <span class="op">{</span></a>
<a class="sourceLine" id="cb111-10" title="10">                  <span class="pp">println!</span>(<span class="st">&quot;file extension: {}&quot;</span>, ext);</a>
<a class="sourceLine" id="cb111-11" title="11">              <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb111-12" title="12">                  <span class="pp">println!</span>(<span class="st">&quot;no file extension&quot;</span>);</a>
<a class="sourceLine" id="cb111-13" title="13">              <span class="op">}</span></a>
<a class="sourceLine" id="cb111-14" title="14">          <span class="op">}</span></a></code></pre></div>
<p>...so the borrow rules apply here too:</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb112-1" title="1"></a>
<a class="sourceLine" id="cb112-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb112-3" title="3">              <span class="kw">let</span> ext = <span class="op">{</span></a>
<a class="sourceLine" id="cb112-4" title="4">                  <span class="kw">let</span> name = <span class="dt">String</span>::from(<span class="st">&quot;Read me. Or don&#39;t.txt&quot;</span>);</a>
<a class="sourceLine" id="cb112-5" title="5">                  file_ext(&amp;name).unwrap_or(<span class="st">&quot;&quot;</span>)</a>
<a class="sourceLine" id="cb112-6" title="6">                  <span class="co">// error: `name` does not live long enough</span></a>
<a class="sourceLine" id="cb112-7" title="7">              <span class="op">}</span>;</a>
<a class="sourceLine" id="cb112-8" title="8">              <span class="pp">println!</span>(<span class="st">&quot;extension: {:?}&quot;</span>, ext);</a>
<a class="sourceLine" id="cb112-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>Functions that can fail typically return a <code>Result</code>:</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb113-1" title="1"></a>
<a class="sourceLine" id="cb113-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb113-3" title="3">              <span class="kw">let</span> s = <span class="pp">std::</span><span class="dt">str</span>::from_utf8(&amp;<span class="op">[</span><span class="dv">240</span>, <span class="dv">159</span>, <span class="dv">141</span>, <span class="dv">137</span><span class="op">]</span>);</a>
<a class="sourceLine" id="cb113-4" title="4">              <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, s);</a>
<a class="sourceLine" id="cb113-5" title="5">              <span class="co">// prints: Ok(&quot;ðŸ‰&quot;)</span></a>
<a class="sourceLine" id="cb113-6" title="6">              <span class="kw">let</span> s = <span class="pp">std::</span><span class="dt">str</span>::from_utf8(&amp;<span class="op">[</span><span class="dv">195</span>, <span class="dv">40</span><span class="op">]</span>);</a>
<a class="sourceLine" id="cb113-7" title="7">              <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, s);</a>
<a class="sourceLine" id="cb113-8" title="8">              <span class="co">// prints: Err(Utf8Error { valid_up_to: 0, error_len: Some(1) })</span></a>
<a class="sourceLine" id="cb113-9" title="9">          <span class="op">}</span></a></code></pre></div>
<p>If you want to panic in case of failure, you can <code>.unwrap()</code>:</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb114-1" title="1"></a>
<a class="sourceLine" id="cb114-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb114-3" title="3">              <span class="kw">let</span> s = <span class="pp">std::</span><span class="dt">str</span>::from_utf8(&amp;<span class="op">[</span><span class="dv">240</span>, <span class="dv">159</span>, <span class="dv">141</span>, <span class="dv">137</span><span class="op">]</span>).unwrap();</a>
<a class="sourceLine" id="cb114-4" title="4">              <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span>, s);</a>
<a class="sourceLine" id="cb114-5" title="5">              <span class="co">// prints: &quot;ðŸ‰&quot;</span></a>
<a class="sourceLine" id="cb114-6" title="6">              <span class="kw">let</span> s = <span class="pp">std::</span><span class="dt">str</span>::from_utf8(&amp;<span class="op">[</span><span class="dv">195</span>, <span class="dv">40</span><span class="op">]</span>).unwrap();</a>
<a class="sourceLine" id="cb114-7" title="7">              <span class="co">// prints: thread &#39;main&#39; panicked at &#39;called `Result::unwrap()`</span></a>
<a class="sourceLine" id="cb114-8" title="8">              <span class="co">// on an `Err` value: Utf8Error { valid_up_to: 0, error_len: Some(1) }&#39;,</span></a>
<a class="sourceLine" id="cb114-9" title="9">              <span class="co">// src/libcore/result.rs:1165:5</span></a>
<a class="sourceLine" id="cb114-10" title="10">          <span class="op">}</span></a></code></pre></div>
<p>Or <code>.expect()</code>, for a custom message:</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb115-1" title="1"></a>
<a class="sourceLine" id="cb115-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb115-3" title="3">              <span class="kw">let</span> s = <span class="pp">std::</span><span class="dt">str</span>::from_utf8(&amp;<span class="op">[</span><span class="dv">195</span>, <span class="dv">40</span><span class="op">]</span>).expect(<span class="st">&quot;valid utf-8&quot;</span>);</a>
<a class="sourceLine" id="cb115-4" title="4">              <span class="co">// prints: thread &#39;main&#39; panicked at &#39;valid utf-8: Utf8Error</span></a>
<a class="sourceLine" id="cb115-5" title="5">              <span class="co">// { valid_up_to: 0, error_len: Some(1) }&#39;, src/libcore/result.rs:1165:5</span></a>
<a class="sourceLine" id="cb115-6" title="6">          <span class="op">}</span></a></code></pre></div>
<p>Or, you can <code>match</code>:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb116-1" title="1"></a>
<a class="sourceLine" id="cb116-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb116-3" title="3">              <span class="kw">match</span> <span class="pp">std::</span><span class="dt">str</span>::from_utf8(&amp;<span class="op">[</span><span class="dv">240</span>, <span class="dv">159</span>, <span class="dv">141</span>, <span class="dv">137</span><span class="op">]</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb116-4" title="4">                  <span class="cn">Ok</span>(s) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, s),</a>
<a class="sourceLine" id="cb116-5" title="5">                  <span class="cn">Err</span>(e) =&gt; <span class="pp">panic!</span>(e),</a>
<a class="sourceLine" id="cb116-6" title="6">              <span class="op">}</span></a>
<a class="sourceLine" id="cb116-7" title="7">              <span class="co">// prints ðŸ‰</span></a>
<a class="sourceLine" id="cb116-8" title="8">          <span class="op">}</span></a></code></pre></div>
<p>Or you can <code>if let</code>:</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb117-1" title="1"></a>
<a class="sourceLine" id="cb117-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb117-3" title="3">              <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Ok</span>(s) = <span class="pp">std::</span><span class="dt">str</span>::from_utf8(&amp;<span class="op">[</span><span class="dv">240</span>, <span class="dv">159</span>, <span class="dv">141</span>, <span class="dv">137</span><span class="op">]</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb117-4" title="4">                  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, s);</a>
<a class="sourceLine" id="cb117-5" title="5">              <span class="op">}</span></a>
<a class="sourceLine" id="cb117-6" title="6">              <span class="co">// prints ðŸ‰</span></a>
<a class="sourceLine" id="cb117-7" title="7">          <span class="op">}</span></a></code></pre></div>
<p>Or you can bubble up the error:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb118-1" title="1"></a>
<a class="sourceLine" id="cb118-2" title="2">          <span class="kw">fn</span> main() -&gt; <span class="dt">Result</span>&lt;(), <span class="pp">std::</span><span class="dt">str</span>::Utf8Error&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb118-3" title="3">              <span class="kw">match</span> <span class="pp">std::</span><span class="dt">str</span>::from_utf8(&amp;<span class="op">[</span><span class="dv">240</span>, <span class="dv">159</span>, <span class="dv">141</span>, <span class="dv">137</span><span class="op">]</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb118-4" title="4">                  <span class="cn">Ok</span>(s) =&gt; <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, s),</a>
<a class="sourceLine" id="cb118-5" title="5">                  <span class="cn">Err</span>(e) =&gt; <span class="kw">return</span> <span class="cn">Err</span>(e),</a>
<a class="sourceLine" id="cb118-6" title="6">              <span class="op">}</span></a>
<a class="sourceLine" id="cb118-7" title="7">              <span class="cn">Ok</span>(())</a>
<a class="sourceLine" id="cb118-8" title="8">          <span class="op">}</span></a></code></pre></div>
<p>Or you can use <code>?</code> to do it the concise way:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb119-1" title="1"></a>
<a class="sourceLine" id="cb119-2" title="2">          <span class="kw">fn</span> main() -&gt; <span class="dt">Result</span>&lt;(), <span class="pp">std::</span><span class="dt">str</span>::Utf8Error&gt; <span class="op">{</span></a>
<a class="sourceLine" id="cb119-3" title="3">              <span class="kw">let</span> s = <span class="pp">std::</span><span class="dt">str</span>::from_utf8(&amp;<span class="op">[</span><span class="dv">240</span>, <span class="dv">159</span>, <span class="dv">141</span>, <span class="dv">137</span><span class="op">]</span>)?;</a>
<a class="sourceLine" id="cb119-4" title="4">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, s);</a>
<a class="sourceLine" id="cb119-5" title="5">              <span class="cn">Ok</span>(())</a>
<a class="sourceLine" id="cb119-6" title="6">          <span class="op">}</span></a></code></pre></div>
<p>The <code>*</code> operator can be used to <em>dereference</em>, but you don't need to do that to access fields or call methods:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb120-1" title="1"></a>
<a class="sourceLine" id="cb120-2" title="2">          <span class="kw">struct</span> Point <span class="op">{</span></a>
<a class="sourceLine" id="cb120-3" title="3">              x: <span class="dt">f64</span>,</a>
<a class="sourceLine" id="cb120-4" title="4">              y: <span class="dt">f64</span>,</a>
<a class="sourceLine" id="cb120-5" title="5">          <span class="op">}</span></a>
<a class="sourceLine" id="cb120-6" title="6">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb120-7" title="7">              <span class="kw">let</span> p = Point <span class="op">{</span> x: <span class="dv">1.0</span>, y: <span class="dv">3.0</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb120-8" title="8">              <span class="kw">let</span> p_ref = &amp;p;</a>
<a class="sourceLine" id="cb120-9" title="9">              <span class="pp">println!</span>(<span class="st">&quot;({}, {})&quot;</span>, p_ref.x, p_ref.y);</a>
<a class="sourceLine" id="cb120-10" title="10">          <span class="op">}</span></a>
<a class="sourceLine" id="cb120-11" title="11">          <span class="co">// prints `(1, 3)`</span></a></code></pre></div>
<p>And you can only do it if the type is <code>Copy</code>:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb121-1" title="1"></a>
<a class="sourceLine" id="cb121-2" title="2">          <span class="kw">struct</span> Point <span class="op">{</span></a>
<a class="sourceLine" id="cb121-3" title="3">              x: <span class="dt">f64</span>,</a>
<a class="sourceLine" id="cb121-4" title="4">              y: <span class="dt">f64</span>,</a>
<a class="sourceLine" id="cb121-5" title="5">          <span class="op">}</span></a>
<a class="sourceLine" id="cb121-6" title="6">          <span class="kw">fn</span> negate(p: Point) -&gt; Point <span class="op">{</span></a>
<a class="sourceLine" id="cb121-7" title="7">              Point <span class="op">{</span></a>
<a class="sourceLine" id="cb121-8" title="8">                  x: -p.x,</a>
<a class="sourceLine" id="cb121-9" title="9">                  y: -p.y,</a>
<a class="sourceLine" id="cb121-10" title="10">              <span class="op">}</span></a>
<a class="sourceLine" id="cb121-11" title="11">          <span class="op">}</span></a>
<a class="sourceLine" id="cb121-12" title="12">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb121-13" title="13">              <span class="kw">let</span> p = Point <span class="op">{</span> x: <span class="dv">1.0</span>, y: <span class="dv">3.0</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb121-14" title="14">              <span class="kw">let</span> p_ref = &amp;p;</a>
<a class="sourceLine" id="cb121-15" title="15">              negate(*p_ref);</a>
<a class="sourceLine" id="cb121-16" title="16">              <span class="co">// error: cannot move out of `*p_ref` which is behind a shared reference</span></a>
<a class="sourceLine" id="cb121-17" title="17">          <span class="op">}</span></a></code></pre></div>
<div class="sourceCode" id="cb122"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb122-1" title="1"></a>
<a class="sourceLine" id="cb122-2" title="2">          <span class="co">// now `Point` is `Copy`</span></a>
<a class="sourceLine" id="cb122-3" title="3">          <span class="at">#[</span>derive<span class="at">(</span><span class="bu">Clone</span><span class="at">,</span> <span class="bu">Copy</span><span class="at">)]</span></a>
<a class="sourceLine" id="cb122-4" title="4">          <span class="kw">struct</span> Point <span class="op">{</span></a>
<a class="sourceLine" id="cb122-5" title="5">              x: <span class="dt">f64</span>,</a>
<a class="sourceLine" id="cb122-6" title="6">              y: <span class="dt">f64</span>,</a>
<a class="sourceLine" id="cb122-7" title="7">          <span class="op">}</span></a>
<a class="sourceLine" id="cb122-8" title="8">          <span class="kw">fn</span> negate(p: Point) -&gt; Point <span class="op">{</span></a>
<a class="sourceLine" id="cb122-9" title="9">              Point <span class="op">{</span></a>
<a class="sourceLine" id="cb122-10" title="10">                  x: -p.x,</a>
<a class="sourceLine" id="cb122-11" title="11">                  y: -p.y,</a>
<a class="sourceLine" id="cb122-12" title="12">              <span class="op">}</span></a>
<a class="sourceLine" id="cb122-13" title="13">          <span class="op">}</span></a>
<a class="sourceLine" id="cb122-14" title="14">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb122-15" title="15">              <span class="kw">let</span> p = Point <span class="op">{</span> x: <span class="dv">1.0</span>, y: <span class="dv">3.0</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb122-16" title="16">              <span class="kw">let</span> p_ref = &amp;p;</a>
<a class="sourceLine" id="cb122-17" title="17">              negate(*p_ref); <span class="co">// ...and now this works</span></a>
<a class="sourceLine" id="cb122-18" title="18">          <span class="op">}</span></a></code></pre></div>
<p>Closures are just functions of type <code>Fn</code>, <code>FnMut</code> or <code>FnOnce</code> with some captured context.</p>
<p>Their parameters are a comma-separated list of names within a pair of pipes ( <code>|</code>). They don't <em>need</em> curly braces, unless you want to have multiple statements.</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb123-1" title="1"></a>
<a class="sourceLine" id="cb123-2" title="2">          <span class="kw">fn</span> for_each_planet&lt;F&gt;(f: F)</a>
<a class="sourceLine" id="cb123-3" title="3">              <span class="kw">where</span> F: <span class="bu">Fn</span>(&amp;<span class="ot">&#39;static</span> <span class="dt">str</span>)</a>
<a class="sourceLine" id="cb123-4" title="4">          <span class="op">{</span></a>
<a class="sourceLine" id="cb123-5" title="5">              f(<span class="st">&quot;Earth&quot;</span>);</a>
<a class="sourceLine" id="cb123-6" title="6">              f(<span class="st">&quot;Mars&quot;</span>);</a>
<a class="sourceLine" id="cb123-7" title="7">              f(<span class="st">&quot;Jupiter&quot;</span>);</a>
<a class="sourceLine" id="cb123-8" title="8">          <span class="op">}</span></a>
<a class="sourceLine" id="cb123-9" title="9">           </a>
<a class="sourceLine" id="cb123-10" title="10">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb123-11" title="11">              for_each_planet(|planet| <span class="pp">println!</span>(<span class="st">&quot;Hello, {}&quot;</span>, planet));</a>
<a class="sourceLine" id="cb123-12" title="12">          <span class="op">}</span></a>
<a class="sourceLine" id="cb123-13" title="13">          <span class="co">// prints:</span></a>
<a class="sourceLine" id="cb123-14" title="14">          <span class="co">// Hello, Earth</span></a>
<a class="sourceLine" id="cb123-15" title="15">          <span class="co">// Hello, Mars</span></a>
<a class="sourceLine" id="cb123-16" title="16">          <span class="co">// Hello, Jupiter</span></a></code></pre></div>
<p>The borrow rules apply to them too:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb124-1" title="1"></a>
<a class="sourceLine" id="cb124-2" title="2">          <span class="kw">fn</span> for_each_planet&lt;F&gt;(f: F)</a>
<a class="sourceLine" id="cb124-3" title="3">              <span class="kw">where</span> F: <span class="bu">Fn</span>(&amp;<span class="ot">&#39;static</span> <span class="dt">str</span>)</a>
<a class="sourceLine" id="cb124-4" title="4">          <span class="op">{</span></a>
<a class="sourceLine" id="cb124-5" title="5">              f(<span class="st">&quot;Earth&quot;</span>);</a>
<a class="sourceLine" id="cb124-6" title="6">              f(<span class="st">&quot;Mars&quot;</span>);</a>
<a class="sourceLine" id="cb124-7" title="7">              f(<span class="st">&quot;Jupiter&quot;</span>);</a>
<a class="sourceLine" id="cb124-8" title="8">          <span class="op">}</span></a>
<a class="sourceLine" id="cb124-9" title="9">           </a>
<a class="sourceLine" id="cb124-10" title="10">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb124-11" title="11">              <span class="kw">let</span> greeting = <span class="dt">String</span>::from(<span class="st">&quot;Good to see you&quot;</span>);</a>
<a class="sourceLine" id="cb124-12" title="12">              for_each_planet(|planet| <span class="pp">println!</span>(<span class="st">&quot;{}, {}&quot;</span>, greeting, planet));</a>
<a class="sourceLine" id="cb124-13" title="13">              <span class="co">// our closure borrows `greeting`, so it cannot outlive it</span></a>
<a class="sourceLine" id="cb124-14" title="14">          <span class="op">}</span></a></code></pre></div>
<p>For example, this would not work:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb125-1" title="1"></a>
<a class="sourceLine" id="cb125-2" title="2">          <span class="kw">fn</span> for_each_planet&lt;F&gt;(f: F)</a>
<a class="sourceLine" id="cb125-3" title="3">              <span class="kw">where</span> F: <span class="bu">Fn</span>(&amp;<span class="ot">&#39;static</span> <span class="dt">str</span>) + <span class="ot">&#39;static</span> <span class="co">// `F` must now have &quot;&#39;static&quot; lifetime</span></a>
<a class="sourceLine" id="cb125-4" title="4">          <span class="op">{</span></a>
<a class="sourceLine" id="cb125-5" title="5">              f(<span class="st">&quot;Earth&quot;</span>);</a>
<a class="sourceLine" id="cb125-6" title="6">              f(<span class="st">&quot;Mars&quot;</span>);</a>
<a class="sourceLine" id="cb125-7" title="7">              f(<span class="st">&quot;Jupiter&quot;</span>);</a>
<a class="sourceLine" id="cb125-8" title="8">          <span class="op">}</span></a>
<a class="sourceLine" id="cb125-9" title="9">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb125-10" title="10">              <span class="kw">let</span> greeting = <span class="dt">String</span>::from(<span class="st">&quot;Good to see you&quot;</span>);</a>
<a class="sourceLine" id="cb125-11" title="11">              for_each_planet(|planet| <span class="pp">println!</span>(<span class="st">&quot;{}, {}&quot;</span>, greeting, planet));</a>
<a class="sourceLine" id="cb125-12" title="12">              <span class="co">// error: closure may outlive the current function, but it borrows</span></a>
<a class="sourceLine" id="cb125-13" title="13">              <span class="co">// `greeting`, which is owned by the current function</span></a>
<a class="sourceLine" id="cb125-14" title="14">          <span class="op">}</span></a></code></pre></div>
<p>But this would:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb126-1" title="1"></a>
<a class="sourceLine" id="cb126-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb126-3" title="3">              <span class="kw">let</span> greeting = <span class="dt">String</span>::from(<span class="st">&quot;You&#39;re doing great&quot;</span>);</a>
<a class="sourceLine" id="cb126-4" title="4">              for_each_planet(<span class="kw">move</span> |planet| <span class="pp">println!</span>(<span class="st">&quot;{}, {}&quot;</span>, greeting, planet));</a>
<a class="sourceLine" id="cb126-5" title="5">              <span class="co">// `greeting` is no longer borrowed, it is *moved* into</span></a>
<a class="sourceLine" id="cb126-6" title="6">              <span class="co">// the closure.</span></a>
<a class="sourceLine" id="cb126-7" title="7">          <span class="op">}</span></a></code></pre></div>
<p>An <code>FnMut</code> needs to be mutably borrowed to be called, so it can only be called once at a time.</p>
<p>This is legal:</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb127-1" title="1"></a>
<a class="sourceLine" id="cb127-2" title="2">          <span class="kw">fn</span> foobar&lt;F&gt;(f: F)</a>
<a class="sourceLine" id="cb127-3" title="3">              <span class="kw">where</span> F: <span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span></a>
<a class="sourceLine" id="cb127-4" title="4">          <span class="op">{</span></a>
<a class="sourceLine" id="cb127-5" title="5">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, f(f(<span class="dv">2</span>))); </a>
<a class="sourceLine" id="cb127-6" title="6">          <span class="op">}</span></a>
<a class="sourceLine" id="cb127-7" title="7">           </a>
<a class="sourceLine" id="cb127-8" title="8">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb127-9" title="9">              foobar(|x| x * <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb127-10" title="10">          <span class="op">}</span></a>
<a class="sourceLine" id="cb127-11" title="11">          <span class="co">// output: 8</span></a></code></pre></div>
<p>This isn't:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb128-1" title="1"></a>
<a class="sourceLine" id="cb128-2" title="2">          <span class="kw">fn</span> foobar&lt;F&gt;(<span class="kw">mut</span> f: F)</a>
<a class="sourceLine" id="cb128-3" title="3">              <span class="kw">where</span> F: <span class="bu">FnMut</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span></a>
<a class="sourceLine" id="cb128-4" title="4">          <span class="op">{</span></a>
<a class="sourceLine" id="cb128-5" title="5">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, f(f(<span class="dv">2</span>))); </a>
<a class="sourceLine" id="cb128-6" title="6">              <span class="co">// error: cannot borrow `f` as mutable more than once at a time</span></a>
<a class="sourceLine" id="cb128-7" title="7">          <span class="op">}</span></a>
<a class="sourceLine" id="cb128-8" title="8">           </a>
<a class="sourceLine" id="cb128-9" title="9">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb128-10" title="10">              foobar(|x| x * <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb128-11" title="11">          <span class="op">}</span></a></code></pre></div>
<p>This is legal again:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb129-1" title="1"></a>
<a class="sourceLine" id="cb129-2" title="2">          <span class="kw">fn</span> foobar&lt;F&gt;(<span class="kw">mut</span> f: F)</a>
<a class="sourceLine" id="cb129-3" title="3">              <span class="kw">where</span> F: <span class="bu">FnMut</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span></a>
<a class="sourceLine" id="cb129-4" title="4">          <span class="op">{</span></a>
<a class="sourceLine" id="cb129-5" title="5">              <span class="kw">let</span> tmp = f(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb129-6" title="6">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, f(tmp)); </a>
<a class="sourceLine" id="cb129-7" title="7">          <span class="op">}</span></a>
<a class="sourceLine" id="cb129-8" title="8">           </a>
<a class="sourceLine" id="cb129-9" title="9">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb129-10" title="10">              foobar(|x| x * <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb129-11" title="11">          <span class="op">}</span></a>
<a class="sourceLine" id="cb129-12" title="12">          <span class="co">// output: 8</span></a></code></pre></div>
<p><code>FnMut</code> exists because some closures <em>mutably borrow</em> local variables:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb130-1" title="1"></a>
<a class="sourceLine" id="cb130-2" title="2">          <span class="kw">fn</span> foobar&lt;F&gt;(<span class="kw">mut</span> f: F)</a>
<a class="sourceLine" id="cb130-3" title="3">              <span class="kw">where</span> F: <span class="bu">FnMut</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span></a>
<a class="sourceLine" id="cb130-4" title="4">          <span class="op">{</span></a>
<a class="sourceLine" id="cb130-5" title="5">              <span class="kw">let</span> tmp = f(<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb130-6" title="6">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, f(tmp)); </a>
<a class="sourceLine" id="cb130-7" title="7">          <span class="op">}</span></a>
<a class="sourceLine" id="cb130-8" title="8">           </a>
<a class="sourceLine" id="cb130-9" title="9">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb130-10" title="10">              <span class="kw">let</span> <span class="kw">mut</span> acc = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb130-11" title="11">              foobar(|x| <span class="op">{</span></a>
<a class="sourceLine" id="cb130-12" title="12">                  acc += <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb130-13" title="13">                  x * acc</a>
<a class="sourceLine" id="cb130-14" title="14">              <span class="op">}</span>);</a>
<a class="sourceLine" id="cb130-15" title="15">          <span class="op">}</span></a>
<a class="sourceLine" id="cb130-16" title="16">          <span class="co">// output: 24</span></a></code></pre></div>
<p>Those closures cannot be passed to functions expecting <code>Fn</code>:</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb131-1" title="1"></a>
<a class="sourceLine" id="cb131-2" title="2">          <span class="kw">fn</span> foobar&lt;F&gt;(f: F)</a>
<a class="sourceLine" id="cb131-3" title="3">              <span class="kw">where</span> F: <span class="bu">Fn</span>(<span class="dt">i32</span>) -&gt; <span class="dt">i32</span></a>
<a class="sourceLine" id="cb131-4" title="4">          <span class="op">{</span></a>
<a class="sourceLine" id="cb131-5" title="5">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, f(f(<span class="dv">2</span>))); </a>
<a class="sourceLine" id="cb131-6" title="6">          <span class="op">}</span></a>
<a class="sourceLine" id="cb131-7" title="7">           </a>
<a class="sourceLine" id="cb131-8" title="8">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb131-9" title="9">              <span class="kw">let</span> <span class="kw">mut</span> acc = <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb131-10" title="10">              foobar(|x| <span class="op">{</span></a>
<a class="sourceLine" id="cb131-11" title="11">                  acc += <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb131-12" title="12">                  <span class="co">// error: cannot assign to `acc`, as it is a</span></a>
<a class="sourceLine" id="cb131-13" title="13">                  <span class="co">// captured variable in a `Fn` closure.</span></a>
<a class="sourceLine" id="cb131-14" title="14">                  <span class="co">// the compiler suggests &quot;changing foobar</span></a>
<a class="sourceLine" id="cb131-15" title="15">                  <span class="co">// to accept closures that implement `FnMut`&quot;</span></a>
<a class="sourceLine" id="cb131-16" title="16">                  x * acc</a>
<a class="sourceLine" id="cb131-17" title="17">              <span class="op">}</span>);</a>
<a class="sourceLine" id="cb131-18" title="18">          <span class="op">}</span></a></code></pre></div>
<p><code>FnOnce</code> closures can only be called once. They exist because some closure move out variables that have been moved when captured:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb132-1" title="1"></a>
<a class="sourceLine" id="cb132-2" title="2">          <span class="kw">fn</span> foobar&lt;F&gt;(f: F)</a>
<a class="sourceLine" id="cb132-3" title="3">              <span class="kw">where</span> F: <span class="bu">FnOnce</span>() -&gt; <span class="dt">String</span></a>
<a class="sourceLine" id="cb132-4" title="4">          <span class="op">{</span></a>
<a class="sourceLine" id="cb132-5" title="5">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, f()); </a>
<a class="sourceLine" id="cb132-6" title="6">          <span class="op">}</span></a>
<a class="sourceLine" id="cb132-7" title="7">           </a>
<a class="sourceLine" id="cb132-8" title="8">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb132-9" title="9">              <span class="kw">let</span> s = <span class="dt">String</span>::from(<span class="st">&quot;alright&quot;</span>);</a>
<a class="sourceLine" id="cb132-10" title="10">              foobar(<span class="kw">move</span> || s);</a>
<a class="sourceLine" id="cb132-11" title="11">              <span class="co">// `s` was moved into our closure, and our</span></a>
<a class="sourceLine" id="cb132-12" title="12">              <span class="co">// closures moves it to the caller by returning</span></a>
<a class="sourceLine" id="cb132-13" title="13">              <span class="co">// it. Remember that `String` is not `Copy`.</span></a>
<a class="sourceLine" id="cb132-14" title="14">          <span class="op">}</span></a></code></pre></div>
<p>This is enforced naturally, as <code>FnOnce</code> closures need to be <em>moved</em> in order to be called.</p>
<p>So, for example, this is illegal:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb133-1" title="1"></a>
<a class="sourceLine" id="cb133-2" title="2">          <span class="kw">fn</span> foobar&lt;F&gt;(f: F)</a>
<a class="sourceLine" id="cb133-3" title="3">              <span class="kw">where</span> F: <span class="bu">FnOnce</span>() -&gt; <span class="dt">String</span></a>
<a class="sourceLine" id="cb133-4" title="4">          <span class="op">{</span></a>
<a class="sourceLine" id="cb133-5" title="5">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, f()); </a>
<a class="sourceLine" id="cb133-6" title="6">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, f()); </a>
<a class="sourceLine" id="cb133-7" title="7">              <span class="co">// error: use of moved value: `f`</span></a>
<a class="sourceLine" id="cb133-8" title="8">          <span class="op">}</span></a></code></pre></div>
<p>And, if you need convincing that our closure <em>does</em> move <code>s</code>, this is illegal too:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb134-1" title="1"></a>
<a class="sourceLine" id="cb134-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb134-3" title="3">              <span class="kw">let</span> s = <span class="dt">String</span>::from(<span class="st">&quot;alright&quot;</span>);</a>
<a class="sourceLine" id="cb134-4" title="4">              foobar(<span class="kw">move</span> || s);</a>
<a class="sourceLine" id="cb134-5" title="5">              foobar(<span class="kw">move</span> || s);</a>
<a class="sourceLine" id="cb134-6" title="6">              <span class="co">// use of moved value: `s`</span></a>
<a class="sourceLine" id="cb134-7" title="7">          <span class="op">}</span></a></code></pre></div>
<p>But this is fine:</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb135-1" title="1"></a>
<a class="sourceLine" id="cb135-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb135-3" title="3">              <span class="kw">let</span> s = <span class="dt">String</span>::from(<span class="st">&quot;alright&quot;</span>);</a>
<a class="sourceLine" id="cb135-4" title="4">              foobar(|| s.clone());</a>
<a class="sourceLine" id="cb135-5" title="5">              foobar(|| s.clone());</a>
<a class="sourceLine" id="cb135-6" title="6">          <span class="op">}</span></a></code></pre></div>
<p>Here's a closure with two arguments:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb136-1" title="1"></a>
<a class="sourceLine" id="cb136-2" title="2">          <span class="kw">fn</span> foobar&lt;F&gt;(x: <span class="dt">i32</span>, y: <span class="dt">i32</span>, is_greater: F)</a>
<a class="sourceLine" id="cb136-3" title="3">              <span class="kw">where</span> F: <span class="bu">Fn</span>(<span class="dt">i32</span>, <span class="dt">i32</span>) -&gt; <span class="dt">bool</span></a>
<a class="sourceLine" id="cb136-4" title="4">          <span class="op">{</span></a>
<a class="sourceLine" id="cb136-5" title="5">              <span class="kw">let</span> (greater, smaller) = <span class="kw">if</span> is_greater(x, y) <span class="op">{</span></a>
<a class="sourceLine" id="cb136-6" title="6">                  (x, y)</a>
<a class="sourceLine" id="cb136-7" title="7">              <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb136-8" title="8">                  (y, x)</a>
<a class="sourceLine" id="cb136-9" title="9">              <span class="op">}</span>;</a>
<a class="sourceLine" id="cb136-10" title="10">              <span class="pp">println!</span>(<span class="st">&quot;{} is greater than {}&quot;</span>, greater, smaller);</a>
<a class="sourceLine" id="cb136-11" title="11">          <span class="op">}</span></a>
<a class="sourceLine" id="cb136-12" title="12">           </a>
<a class="sourceLine" id="cb136-13" title="13">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb136-14" title="14">              foobar(<span class="dv">32</span>, <span class="dv">64</span>, |x, y| x &gt; y);</a>
<a class="sourceLine" id="cb136-15" title="15">          <span class="op">}</span></a></code></pre></div>
<p>Here's a closure ignoring both its arguments:</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb137-1" title="1"></a>
<a class="sourceLine" id="cb137-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb137-3" title="3">              foobar(<span class="dv">32</span>, <span class="dv">64</span>, |_, _| <span class="pp">panic!</span>(<span class="st">&quot;Comparing is futile!&quot;</span>));</a>
<a class="sourceLine" id="cb137-4" title="4">          <span class="op">}</span></a></code></pre></div>
<p>Here's a slightly worrying closure:</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb138-1" title="1"></a>
<a class="sourceLine" id="cb138-2" title="2">          <span class="kw">fn</span> countdown&lt;F&gt;(count: <span class="dt">usize</span>, tick: F)</a>
<a class="sourceLine" id="cb138-3" title="3">              <span class="kw">where</span> F: <span class="bu">Fn</span>(<span class="dt">usize</span>)</a>
<a class="sourceLine" id="cb138-4" title="4">          <span class="op">{</span></a>
<a class="sourceLine" id="cb138-5" title="5">              <span class="kw">for</span> i <span class="kw">in</span> (<span class="dv">1</span>..=count).rev() <span class="op">{</span></a>
<a class="sourceLine" id="cb138-6" title="6">                  tick(i);</a>
<a class="sourceLine" id="cb138-7" title="7">              <span class="op">}</span></a>
<a class="sourceLine" id="cb138-8" title="8">          <span class="op">}</span></a>
<a class="sourceLine" id="cb138-9" title="9">           </a>
<a class="sourceLine" id="cb138-10" title="10">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb138-11" title="11">              countdown(<span class="dv">3</span>, |i| <span class="pp">println!</span>(<span class="st">&quot;tick {}...&quot;</span>, i));</a>
<a class="sourceLine" id="cb138-12" title="12">          <span class="op">}</span></a>
<a class="sourceLine" id="cb138-13" title="13">          <span class="co">// output:</span></a>
<a class="sourceLine" id="cb138-14" title="14">          <span class="co">// tick 3...</span></a>
<a class="sourceLine" id="cb138-15" title="15">          <span class="co">// tick 2...</span></a>
<a class="sourceLine" id="cb138-16" title="16">          <span class="co">// tick 1...</span></a></code></pre></div>
<p>And here's a toilet closure:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb139-1" title="1"></a>
<a class="sourceLine" id="cb139-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb139-3" title="3">              countdown(<span class="dv">3</span>, |_| ());</a>
<a class="sourceLine" id="cb139-4" title="4">          <span class="op">}</span></a></code></pre></div>
<p>Called thusly because <code>|_| ()</code> looks like a toilet.</p>
<p>Anything that is iterable can be used in a <code>for in</code> loop.</p>
<p>We've just seen a range being used, but it also works with a <code>Vec</code>:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb140-1" title="1"></a>
<a class="sourceLine" id="cb140-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb140-3" title="3">              <span class="kw">for</span> i <span class="kw">in</span> <span class="pp">vec!</span><span class="op">[</span><span class="dv">52</span>, <span class="dv">49</span>, <span class="dv">21</span><span class="op">]</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb140-4" title="4">                  <span class="pp">println!</span>(<span class="st">&quot;I like the number {}&quot;</span>, i);</a>
<a class="sourceLine" id="cb140-5" title="5">              <span class="op">}</span></a>
<a class="sourceLine" id="cb140-6" title="6">          <span class="op">}</span></a></code></pre></div>
<p>Or a slice:</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb141-1" title="1"></a>
<a class="sourceLine" id="cb141-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb141-3" title="3">              <span class="kw">for</span> i <span class="kw">in</span> &amp;<span class="op">[</span><span class="dv">52</span>, <span class="dv">49</span>, <span class="dv">21</span><span class="op">]</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb141-4" title="4">                  <span class="pp">println!</span>(<span class="st">&quot;I like the number {}&quot;</span>, i);</a>
<a class="sourceLine" id="cb141-5" title="5">              <span class="op">}</span></a>
<a class="sourceLine" id="cb141-6" title="6">          <span class="op">}</span></a>
<a class="sourceLine" id="cb141-7" title="7">          <span class="co">// output:</span></a>
<a class="sourceLine" id="cb141-8" title="8">          <span class="co">// I like the number 52</span></a>
<a class="sourceLine" id="cb141-9" title="9">          <span class="co">// I like the number 49</span></a>
<a class="sourceLine" id="cb141-10" title="10">          <span class="co">// I like the number 21</span></a></code></pre></div>
<p>Or an actual iterator:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb142-1" title="1"></a>
<a class="sourceLine" id="cb142-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb142-3" title="3">              <span class="co">// note: `&amp;str` also has a `.bytes()` iterator.</span></a>
<a class="sourceLine" id="cb142-4" title="4">              <span class="co">// Rust&#39;s `char` type is a &quot;Unicode scalar value&quot;</span></a>
<a class="sourceLine" id="cb142-5" title="5">              <span class="kw">for</span> c <span class="kw">in</span> <span class="st">&quot;rust&quot;</span>.chars() <span class="op">{</span></a>
<a class="sourceLine" id="cb142-6" title="6">                  <span class="pp">println!</span>(<span class="st">&quot;Give me a {}&quot;</span>, c);</a>
<a class="sourceLine" id="cb142-7" title="7">              <span class="op">}</span></a>
<a class="sourceLine" id="cb142-8" title="8">          <span class="op">}</span></a>
<a class="sourceLine" id="cb142-9" title="9">          <span class="co">// output:</span></a>
<a class="sourceLine" id="cb142-10" title="10">          <span class="co">// Give me a r</span></a>
<a class="sourceLine" id="cb142-11" title="11">          <span class="co">// Give me a u</span></a>
<a class="sourceLine" id="cb142-12" title="12">          <span class="co">// Give me a s</span></a>
<a class="sourceLine" id="cb142-13" title="13">          <span class="co">// Give me a t</span></a></code></pre></div>
<p>Even if the iterator items are filtered and mapped and flattened:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb143-1" title="1"></a>
<a class="sourceLine" id="cb143-2" title="2">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb143-3" title="3">              <span class="kw">for</span> c <span class="kw">in</span> <span class="st">&quot;sHE&#39;S brOKen&quot;</span></a>
<a class="sourceLine" id="cb143-4" title="4">                  .chars()</a>
<a class="sourceLine" id="cb143-5" title="5">                  .filter(|c| c.is_uppercase() || !c.is_ascii_alphabetic())</a>
<a class="sourceLine" id="cb143-6" title="6">                  .flat_map(|c| c.to_lowercase())</a>
<a class="sourceLine" id="cb143-7" title="7">              <span class="op">{</span></a>
<a class="sourceLine" id="cb143-8" title="8">                  <span class="pp">print!</span>(<span class="st">&quot;{}&quot;</span>, c);</a>
<a class="sourceLine" id="cb143-9" title="9">              <span class="op">}</span></a>
<a class="sourceLine" id="cb143-10" title="10">              <span class="pp">println!</span>();</a>
<a class="sourceLine" id="cb143-11" title="11">          <span class="op">}</span></a>
<a class="sourceLine" id="cb143-12" title="12">          <span class="co">// output: he&#39;s ok</span></a></code></pre></div>
<p>You can return a closure from a function:</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb144-1" title="1"></a>
<a class="sourceLine" id="cb144-2" title="2">          <span class="kw">fn</span> make_tester(answer: <span class="dt">String</span>) -&gt; <span class="kw">impl</span> <span class="bu">Fn</span>(&amp;<span class="dt">str</span>) -&gt; <span class="dt">bool</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb144-3" title="3">              <span class="kw">move</span> |challenge| <span class="op">{</span></a>
<a class="sourceLine" id="cb144-4" title="4">                  challenge == answer</a>
<a class="sourceLine" id="cb144-5" title="5">              <span class="op">}</span></a>
<a class="sourceLine" id="cb144-6" title="6">          <span class="op">}</span></a>
<a class="sourceLine" id="cb144-7" title="7">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb144-8" title="8">              <span class="co">// you can use `.into()` to perform conversions</span></a>
<a class="sourceLine" id="cb144-9" title="9">              <span class="co">// between various types, here `&amp;&#39;static str` and `String`</span></a>
<a class="sourceLine" id="cb144-10" title="10">              <span class="kw">let</span> test = make_tester(<span class="st">&quot;hunter2&quot;</span>.into());</a>
<a class="sourceLine" id="cb144-11" title="11">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, test(<span class="st">&quot;******&quot;</span>));</a>
<a class="sourceLine" id="cb144-12" title="12">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, test(<span class="st">&quot;hunter2&quot;</span>));</a>
<a class="sourceLine" id="cb144-13" title="13">          <span class="op">}</span></a></code></pre></div>
<p>You can even move a reference to some of a function's arguments, into a closure it returns:</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb145-1" title="1"></a>
<a class="sourceLine" id="cb145-2" title="2">          <span class="kw">fn</span> make_tester&lt;<span class="ot">&#39;a</span>&gt;(answer: &amp;<span class="ot">&#39;a</span> <span class="dt">str</span>) -&gt; <span class="kw">impl</span> <span class="bu">Fn</span>(&amp;<span class="dt">str</span>) -&gt; <span class="dt">bool</span> + <span class="ot">&#39;a</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb145-3" title="3">              <span class="kw">move</span> |challenge| <span class="op">{</span></a>
<a class="sourceLine" id="cb145-4" title="4">                  challenge == answer</a>
<a class="sourceLine" id="cb145-5" title="5">              <span class="op">}</span></a>
<a class="sourceLine" id="cb145-6" title="6">          <span class="op">}</span></a>
<a class="sourceLine" id="cb145-7" title="7">          <span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb145-8" title="8">              <span class="kw">let</span> test = make_tester(<span class="st">&quot;hunter2&quot;</span>);</a>
<a class="sourceLine" id="cb145-9" title="9">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, test(<span class="st">&quot;*******&quot;</span>));</a>
<a class="sourceLine" id="cb145-10" title="10">              <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span>, test(<span class="st">&quot;hunter2&quot;</span>));</a>
<a class="sourceLine" id="cb145-11" title="11">          <span class="op">}</span></a>
<a class="sourceLine" id="cb145-12" title="12">          <span class="co">// output:</span></a>
<a class="sourceLine" id="cb145-13" title="13">          <span class="co">// false</span></a>
<a class="sourceLine" id="cb145-14" title="14">          <span class="co">// true</span></a></code></pre></div>
<p>Or, with elided lifetimes:</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb146-1" title="1"></a>
<a class="sourceLine" id="cb146-2" title="2">          <span class="kw">fn</span> make_tester(answer: &amp;<span class="dt">str</span>) -&gt; <span class="kw">impl</span> <span class="bu">Fn</span>(&amp;<span class="dt">str</span>) -&gt; <span class="dt">bool</span> + <span class="ot">&#39;_</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb146-3" title="3">              <span class="kw">move</span> |challenge| <span class="op">{</span></a>
<a class="sourceLine" id="cb146-4" title="4">                  challenge == answer</a>
<a class="sourceLine" id="cb146-5" title="5">              <span class="op">}</span></a>
<a class="sourceLine" id="cb146-6" title="6">          <span class="op">}</span></a></code></pre></div>
<p>And with that, we hit the 30-minute estimated reading time mark, and you should be able to read <em>most</em> of the Rust code you find online.</p>
<p>Writing Rust is a very different experience from reading Rust. On one hand, you're not reading the <em>solution</em> to a problem, you're actually solving it. On the other hand, the Rust compiler helps out a <em>lot</em>.</p>
<p>For all of the intentional mistakes made above ("this code is illegal", etc.), rustc always has very good error messages <em>and</em> insightful suggestions.</p>
<p>And when there's a hint missing, the compiler team is <a href="https://mobile.twitter.com/fasterthanlime/status/1219601989404954624">not afraid to add it</a>.</p>
<p>For more Rust material, you may want to check out:</p>
<p>I also <a href="/tags/rust/">blog about Rust</a> and <a href="https://twitter.com/fasterthanlime">tweet about Rust</a> a lot, so if you liked this article, you know what to do.</p>
<p>Have fun!</p>
<h2 id="references">References</h2>
<ol type="1">
<li><a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">A half-hour to learn Rust (fasterthanli.me)</a></li>
</ol>
</body>
</html>
