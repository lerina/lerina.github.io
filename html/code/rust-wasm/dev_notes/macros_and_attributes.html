<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>macros_and_attributes macros_and_attributes</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://lerina.github.io/css/styles_min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#macros-and-attributes"
id="toc-macros-and-attributes">Macros and Attributes</a>
<ul>
<li><a href="#macros" id="toc-macros">Macros</a></li>
<li><a href="#rust-macro-overiew" id="toc-rust-macro-overiew">Rust macro
overiew</a></li>
<li><a href="#attributes" id="toc-attributes">Attributes</a></li>
<li><a href="#procedural-macros-extra"
id="toc-procedural-macros-extra">Procedural macros: extra</a></li>
</ul></li>
</ul>
</nav>
<h1 id="macros-and-attributes">Macros and Attributes</h1>
<p>Learning objectives</p>
<pre><code>You know the different types of Rust macros
You know how create and use your own declarative Rust macros
You know the different types of Rust attributes and how to use them</code></pre>
<p>For those interested in a more detailed take on macros (or just
wanting more information and examples — it starts out simple), please
take a look at <a href="https://veykril.github.io/tlborm/">The Little
Book of Rust Macros</a> by Lukas Wirth.</p>
<h2 id="macros">Macros</h2>
<p>Macros are a powerful feature found in many programming languages
that allows generating code using rules or patterns at compile-time. In
other words, writing macros is metaprogramming: writing code that writes
code.</p>
<p>This allows for more concise and expressive code that can overcome
the limitations of a language’s own syntax, leading to increased
productivity and maintainability. Consider for instance the
#[derive(Trait)] attribute (which is actually a macro). It expands a
given struct or enum with code to implement one or more traits —
wouldn’t it be annoying to have to constantly write impl Debug for … for
each custom type you wish to debug print?</p>
<h3 id="expanding-macros">Expanding macros</h3>
<p>To see Rust macros in action, in a way that we actually can see what
happens upon a macro invocation, we can install the cargo-expand crate
which gives us the convenient cargo subcommand</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> expand</span></code></pre></div>
<p>The rest of this section assumes you have cargo-expand installed,
although it is actually just a convenient wrapper to the less convenient
rustc command</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> rustc <span class="at">--profile</span><span class="op">=</span>check <span class="at">--</span> <span class="at">-Zunpretty</span><span class="op">=</span>expanded</span></code></pre></div>
<p>Expand this:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    x<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    y<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> p <span class="op">=</span> Point <span class="op">{</span> x<span class="op">:</span> <span class="dv">1</span><span class="op">,</span> y<span class="op">:</span> <span class="dv">2</span> <span class="op">};</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> p)<span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The output of cargo expand should look like the following Rust
code.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>feature<span class="at">(</span>prelude_import<span class="at">)]</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>prelude_import<span class="at">]</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::prelude::rust_2021::</span><span class="op">*;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>macro_use<span class="at">]</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="kw">crate</span> std<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    x<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    y<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>automatically_derived<span class="at">]</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">::core::fmt::</span><span class="bu">Debug</span> <span class="cf">for</span> Point <span class="op">{</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> fmt(<span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span> f<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="pp">::core::fmt::</span>Formatter) <span class="op">-&gt;</span> <span class="pp">::core::fmt::</span><span class="dt">Result</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="pp">::core::fmt::Formatter::</span>debug_struct_field2_finish(</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>            f<span class="op">,</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;Point&quot;</span><span class="op">,</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;x&quot;</span><span class="op">,</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">&amp;</span><span class="kw">self</span><span class="op">.</span>x<span class="op">,</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;y&quot;</span><span class="op">,</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">&amp;&amp;</span><span class="kw">self</span><span class="op">.</span>y<span class="op">,</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> p <span class="op">=</span> Point <span class="op">{</span> x<span class="op">:</span> <span class="dv">1</span><span class="op">,</span> y<span class="op">:</span> <span class="dv">2</span> <span class="op">};</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        <span class="pp">::std::io::</span>_print(<span class="pp">format_args!</span>(<span class="st">&quot;{0:?}</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;</span><span class="op">,</span> p))<span class="op">;</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Running the code with cargo run won’t work right out of the bat
though. The expanded code uses nightly-only and unstable features so we
need to enable those first. We can run cargo run using the nightly build
with cargo +nightly run and the compiler suggests that we need the
attributes #[feature(fmt_helpers_for_derive)] and
#[feature(print_internals)] to enable the used unstable options. So add
those in to the top of the file and run</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> +nightly run</span></code></pre></div>
<p>and you should see the output</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">Point</span> { x: 1, y: 2 }</span></code></pre></div>
<h2 id="rust-macro-overiew">Rust macro overiew</h2>
<p>Macros in Rust fall into two categories.</p>
<ol type="1">
<li>Declarative macros aka macros by example, which produce code
according to a set of rules that match code patterns into code
output.</li>
<li>Procedural macros, which produce code by executing a Rust function
that takes code as input and produces new code as output.</li>
</ol>
<p>Macros can also be categorised by how they are invoked:</p>
<ol type="1">
<li>Function-like macros, which are invoked like a function, println! is
a prime example. Function-like macros can be created by both declarative
and procedural macros.</li>
<li>Attribute-like macros, which are invoked like an attribute. As an
example, we could create an attribute get, use e.g. #[get(“/”)] to map a
function into a route in a web API like in the rocket crate.
Attribute-like macros can be created with procedural macros.</li>
<li>Derive macros, which are macros that can be used with the derive
attribute to derive custom trait implementations. Derive macros can only
be created with procedural macros.</li>
</ol>
<p>Declarative macros are more common and much simpler to define than
procedural macros, which is why we’ll mainly focus on them here.</p>
<h3 id="declarative-macros">Declarative macros</h3>
<p>Declarative macros are macros that are defined by rules. They are
function-like macros, meaning that they are invoked like functions, such
as the familiar println! (e.g. println!(“🖨️”)) macro or the vec! macro
(e.g. vec[“🦀”, “🦀”] or vec!(“🦀”, “🦀”) or vec{“🦀”, “🦀”} — yes, the
type of parentheses use for invoking function-like macros doesn’t
matter). In contrast to functions, declarative macros take a token tree
as input instead of variables and their output is always a token tree.
Simply put, their input is parsed code and the output is also parsed
code.</p>
<p>But to get a basic idea, the code</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Hello, macros!&quot;</span>)<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>as a token tree would look like (a token is denoted by «<token>»)</p>
<pre><code>«fn» «main» «()» «{   }»
         ┌──────────┴────────────┐
         «println» «!» «(   )» «;»
                 ┌────────┴───────┐
                 «&quot;Hello, macros!&quot;»</code></pre>
<p>Luckily we hardly need to understand the details of token trees or
how Rust parses them to be able write our own macros. However, if your
interested to know more about how macro input is parsed, check out the
Source analysis section of The Little Book of Rust Macros.</p>
<p>Anyhow, let’s start creating some of our own syntax sugar with
macros!</p>
<p>The simplest example we can create is one that does not take any
input and just expands to some code. We can do this with the
macro_rules! macro.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> hello <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    () <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">hello!</span>()<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A declarative macro aka macro-by-example aka macro_rules macro (a
dear child has many names) is defined using the built-in macro
macro_rules!. It takes a name for the macro and a list of rules.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> <span class="op">&lt;</span>name<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;</span>rule1<span class="op">&gt;;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;</span>rule2<span class="op">&gt;;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;</span>ruleN<span class="op">&gt;;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Each rule consists of a pattern matcher and an expansion block.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> <span class="op">&lt;</span>name<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    () <span class="op">=&gt;</span> <span class="op">{</span> <span class="co">// empty matcher</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;</span>expansion<span class="op">&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;</span>matcher1<span class="op">&gt;</span>) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;</span>expansion<span class="op">&gt;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;</span>matcher2<span class="op">&gt;</span>) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;</span>expansion<span class="op">&gt;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;</span>matcherN<span class="op">&gt;</span>) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">&lt;</span>expansion<span class="op">&gt;</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The rules work like the match statement, the first matching rule is
invoked and the pattern expanded according to the rule’s expansion
block. If the input pattern does not match any of the matchers, the code
will not compile.</p>
<p>If we expand the above example with the hello! macro using the cargo
expand command, we should see the main function transformed into</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>feature<span class="at">(</span>print_internals<span class="at">)]</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">::std::io::</span>_print(<span class="pp">format_args!</span>(<span class="st">&quot;Hello, world!</span><span class="sc">\n</span><span class="st">&quot;</span>))<span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Compiling the expanded code requires once again running with the
nightly compiler and enabling any used unstable features. We won’t be
showing any more expansion results in the material, but suggest
expanding whenever you are unsure of the code should expand to.</p>
<p>Note also that cargo expand is not perfect and may not produce code
that behaves the same as the compiled original code, see for instance
the disclaimer at the end of the crate description.</p>
<p>Let’s then add another rule to our macro that takes a name as input
and prints a greeting to that name.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> hello <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    () <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>name<span class="op">:</span> expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Hello, {}!&quot;</span><span class="op">,</span> <span class="op">$</span>name)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">hello!</span>()<span class="op">;</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">hello!</span>(<span class="st">&quot;fellow human&quot;</span>)<span class="op">;</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice that the second rule has a matcher with a $name variable. The
$ indicates that the variable is a pattern variable, i.e. a fragment.
And : expr is a fragment specifier which indicates that the fragment
matches an expression. Both the $ and the fragment specifier are
required for fragments.</p>
<p>If we omit the $, the pattern matcher will be a literal matcher that
matches the input exactly as a stream of literal tokens.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> hello <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    () <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    (name<span class="op">:</span> expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Hello?&quot;</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">hello!</span>()<span class="op">;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">hello!</span>(name<span class="op">:</span> expr)<span class="op">;</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Unlike with match statements, the compiler isn’t able to notice if a
macro rule is unreachable.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> hello <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    () <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>name<span class="op">:</span> expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Hello, {}!&quot;</span><span class="op">,</span> <span class="op">$</span>name)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;Hello?&quot;</span>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">hello!</span>()<span class="op">;</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">hello!</span>(<span class="st">&quot;fellow human&quot;</span>)<span class="op">;</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">hello!</span>(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The third matcher will never be invoked because it only matches the
literal 1 (hello!(1)) and the previous matcher catches 1 before it.</p>
<p>Macros do nothing but expand their input to code, so the places where
we are able to use a macro depends on what the macro expands to. When we
have a macro that expands to an expression, we can place it in any place
we could place the expanded expression.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> hello_string <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    () <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Hello, world!&quot;</span><span class="op">.</span>to_string()</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>name<span class="op">:</span> expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">format!</span>(<span class="st">&quot;Hello, {}!&quot;</span><span class="op">,</span> <span class="op">$</span>name)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> HELLO<span class="op">:</span> <span class="dt">String</span> <span class="op">=</span> <span class="pp">hello_string!</span>()<span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a> <span class="co">// can&#39;t have a String here</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{HELLO}&quot;</span>)<span class="op">;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">hello_string!</span>())<span class="op">;</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> hellos <span class="op">=</span> <span class="pp">vec!</span>[<span class="st">&quot;hello?&quot;</span><span class="op">.</span>to_string()<span class="op">,</span> <span class="pp">hello_string!</span>()<span class="op">,</span> <span class="pp">hello_string!</span>(<span class="st">&quot;fellow human&quot;</span>)]<span class="op">;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{hellos:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="avoid-unexpected-behaviour">Avoid unexpected behaviour</h4>
<p>One important thing when writing macros, especially for bigger
macros, is hygiene. Macro hygiene is about ensuring that a macro does
not accidentally use or modify anything that is not intended to be used
or modified by the macro. It’s like hand hygiene, we wouldn’t want to
have our hands dirty when using our hands for example to greet a friend
with a handshake.</p>
<p>Let’s inspect a problem arising from a rather simple log! macro that
uses the chrono crate for logging expressions with a time stamp to
standard output.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> log <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>arg<span class="op">:</span> expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">chrono::</span>Local<span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;[{}] {:?}&quot;</span><span class="op">,</span> <span class="pp">Local::</span>now()<span class="op">.</span>format(<span class="st">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<span class="op">,</span> <span class="op">$</span>arg)<span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">log!</span>(<span class="st">&quot;📅+⌚&quot;</span>)<span class="op">;</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Now in this example all works fine, but what if we have a local
module chrono in the same module where we invoke macro?</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> log <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>arg<span class="op">:</span> expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">chrono::</span>Local<span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;[{}] {:?}&quot;</span><span class="op">,</span> <span class="pp">Local::</span>now()<span class="op">.</span>format(<span class="st">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<span class="op">,</span> <span class="op">$</span>arg)<span class="op">;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="kw">mod</span> chrono <span class="op">{</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="kw">mod</span> prelude <span class="op">{}</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">log!</span>(<span class="st">&quot;📅+⌚&quot;</span>)<span class="op">;</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We run into a conflict between the local chrono module and the
imported chrono module. We can fix the problem by prepending our import
with :: to ensure that we’re importing the external crate and not the
local module.</p>
<p>If we think we are out of the water now, we should hold our horses.
What would happen if we have a local enum named Local and try to use it
after calling log!?</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> log <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>arg<span class="op">:</span> expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">::chrono::</span>Local<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;[{}] {:?}&quot;</span><span class="op">,</span> <span class="pp">Local::</span>now()<span class="op">.</span>format(<span class="st">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<span class="op">,</span> <span class="op">$</span>arg)<span class="op">;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Local <span class="op">{</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    Person<span class="op">,</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    Time<span class="op">,</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    Place<span class="op">,</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">log!</span>(<span class="st">&quot;📅+⌚&quot;</span>)<span class="op">;</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> person <span class="op">=</span> <span class="pp">Local::</span>Person<span class="op">;</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">log!</span>(person)<span class="op">;</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Here when we try to log! Local::Person we get some compiler errors
for Local being defined multiple times and Local::Person not being found
in chrono::Local. This is because the import statement use
::chrono::Local; tries shadows the local Local enum with the
struct::chrono::Local and the that’s what we end up having in main too,
not the local Local (expand the code if unsure what’s goig on).</p>
<p>We can make the macro hygienic by wrapping the macro rule’s expanded
code in a block so that we don’t leak any imported items or defined
variables into the caller’s scope.</p>
<p>Now, we are not clear yet. What if we try to call log! with a Local
literal?</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> log <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>arg<span class="op">:</span> expr) <span class="op">=&gt;</span> <span class="op">{{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">use</span> <span class="pp">::chrono::</span>Local<span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;[{}] {:?}&quot;</span><span class="op">,</span> <span class="pp">Local::</span>now()<span class="op">.</span>format(<span class="st">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<span class="op">,</span> <span class="op">$</span>arg)<span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}};</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Local <span class="op">{</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    Person<span class="op">,</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    Time<span class="op">,</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    Place<span class="op">,</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">log!</span>(<span class="st">&quot;📅+⌚&quot;</span>)<span class="op">;</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">log!</span>(<span class="pp">Local::</span>Person)<span class="op">;</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This time we run into problems inside the macro because of the use
::chrono::Local; statement inside the macro. The Local enum is once
again shadowed by the chrono::Local struct and we get a similar error as
in the previous case.</p>
<p>Its best to avoid use statements inside macros to be clear of
accidental shadowing. To be extra careful, we should also consider that
someone may shadow the println! macro, so we should import it properly
within our own macro (even though it makes the code a bit harder to
read).</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> log <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>arg<span class="op">:</span> expr) <span class="op">=&gt;</span> <span class="op">{{</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">::std::println!</span>(<span class="st">&quot;[{}] {:?}&quot;</span><span class="op">,</span> <span class="pp">::chrono::Local::</span>now()<span class="op">.</span>format(<span class="st">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<span class="op">,</span> <span class="op">$</span>arg)<span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}};</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Local <span class="op">{</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    Person<span class="op">,</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    Time<span class="op">,</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    Place<span class="op">,</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">log!</span>(<span class="pp">Local::</span>Person)<span class="op">;</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Hygiene is especially important when writing macros that are intended
for use by others, e.g. in a library, as it ensures that the macro does
not accidentally break the code of the macro caller or cause unexpected
side-effects in the program. Optimally all macros should be
hygienic.</p>
<h3 id="repetitions">Repetitions</h3>
<p>Let’s then look at creating a macro that works like the vec! macro
but for HashMaps. This will require a bit more work, because we need to
be able to match multiple repetitions of the values that go inside map
like we have with e.g. vec[“🎿”, “🏂”].</p>
<p>This is also a good place to mention that the macro_rules! macros can
be invoked and defined with all three kinds of parentheses: (), [],
{}.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> exclamated <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>expr<span class="op">:</span> expr) <span class="op">=&gt;</span> (</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>      <span class="pp">format!</span><span class="op">{</span><span class="st">&quot;{}!&quot;</span><span class="op">,</span> <span class="op">$</span>expr<span class="op">}</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>[<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> <span class="pp">vec!</span>(<span class="st">&quot;🎿&quot;</span><span class="op">,</span> <span class="st">&quot;🏂&quot;</span>)]<span class="op">;</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span><span class="op">{</span><span class="st">&quot;{:?}&quot;</span><span class="op">,</span> <span class="pp">exclamated!</span>[<span class="dv">1337</span>]<span class="op">};</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Being able to write hash_map!{“one”: 1, “two”: 1} to initialize a
HashMap would be nice but unfortunately macro_rules! has limitations
that prevent writing rules for that (: has a special meaning in the
matcher). Running the below code shows which special characters are
allowed between expressions in a macro rule, which allows us to see what
alternatives we have.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> hash_map <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>( <span class="op">$</span>key<span class="op">:</span> expr<span class="op">:</span> <span class="op">$</span>val<span class="op">:</span> expr )<span class="op">,*</span>) <span class="op">=&gt;</span> <span class="op">{{</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> map <span class="op">=</span> <span class="pp">::std::collections::HashMap::</span>new()<span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">$</span>( map<span class="op">.</span>insert(<span class="op">$</span>key<span class="op">,</span> <span class="op">$</span>val)<span class="op">;</span> )<span class="op">*</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>        map</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}}</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> <span class="pp">hash_map!</span><span class="op">{</span><span class="st">&quot;one&quot;</span><span class="op">:</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;two&quot;</span><span class="op">:</span> <span class="dv">2</span><span class="op">}</span>)<span class="op">;</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> finnish_traditional_foods <span class="op">=</span> <span class="pp">hash_map!</span><span class="op">{</span> <span class="co">// not even remotely a complete list</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Etelä-Savo&quot;</span><span class="op">:</span> <span class="pp">vec!</span>[<span class="st">&quot;rättänä&quot;</span><span class="op">,</span> <span class="st">&quot;muikiainen&quot;</span>]<span class="op">,</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Etelä-Karjala&quot;</span><span class="op">:</span> <span class="pp">vec!</span>[<span class="st">&quot;särä&quot;</span>]<span class="op">,</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Häme&quot;</span><span class="op">:</span> <span class="pp">vec!</span>[<span class="st">&quot;piimäjuusto&quot;</span><span class="op">,</span> <span class="st">&quot;munajuusto&quot;</span>]<span class="op">,</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Kymenlaakso&quot;</span><span class="op">:</span> <span class="pp">vec!</span>[<span class="st">&quot;perunaleposka&quot;</span>]<span class="op">,</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Pirkanmaa&quot;</span><span class="op">:</span> <span class="pp">vec!</span>[<span class="st">&quot;mustamakkara&quot;</span>]<span class="op">,</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Pohjois-Pohjanmaa&quot;</span><span class="op">:</span> <span class="pp">vec!</span>[<span class="st">&quot;ruppana&quot;</span>]</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:#?}&quot;</span><span class="op">,</span> finnish_traditional_foods)<span class="op">;</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can however achieve something similar enough by using one of the
allowed expression separator symbols (=&gt;, ,, ;), for instance =&gt;,
instead of : to denote a key value relation — we could also simply omit
the separator since the repetition separator is optional.</p>
<p>Note that the repetition syntax is $( $key: expr =&gt; $val: expr
),<em>, i.e. $( … ) , </em> as in $(<repeated pattern>)
<optional separator> <repetition marker>.</p>
<p>Notice also how the repetition is used in the expansion part of the
rule: <span
class="math inline">(<em>m</em><em>a</em><em>p</em>.<em>i</em><em>n</em><em>s</em><em>e</em><em>r</em><em>t</em>(</span>key,
<span
class="math inline"><em>v</em><em>a</em><em>l</em>); ) * .<em>T</em><em>h</em><em>i</em><em>s</em><em>e</em><em>x</em><em>p</em><em>a</em><em>n</em><em>d</em><em>s</em><em>t</em><em>h</em><em>e</em><em>c</em><em>o</em><em>d</em><em>e</em>(<em>m</em><em>a</em><em>p</em>.<em>i</em><em>n</em><em>s</em><em>e</em><em>r</em><em>t</em>(</span>key,
$val)) as many times as the pattern is repeated in the matched input,
with $key and $val matching each iteration of the repetition one at a
time.</p>
<p>In total, there are three different repetition markers. If you know
your regular expressions, these should be familiar.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Repetition</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">*</td>
<td style="text-align: left;">0 or more repetitions</td>
</tr>
<tr class="even">
<td style="text-align: left;">+</td>
<td style="text-align: left;">1 or more repetitions</td>
</tr>
<tr class="odd">
<td style="text-align: left;">?</td>
<td style="text-align: left;">0 or 1 repetitions</td>
</tr>
</tbody>
</table>
<p>Our hashmap! macro still has a minor fault compared to the readily
available HashMap::from. We can’t have a trailing comma in the macro
invocation, which is an unnecessary restriction and can be a bit
annoying. To fix this, all we need is to match the separator with 0 or 1
repetitions at the end of the matcher.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> hash_map <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>( <span class="op">$</span>key<span class="op">:</span> expr <span class="op">=&gt;</span> <span class="op">$</span>val<span class="op">:</span> expr )<span class="op">,*</span>) <span class="op">=&gt;</span> <span class="op">{{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> <span class="kw">mut</span> map <span class="op">=</span> <span class="pp">::std::collections::HashMap::</span>new()<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>          <span class="op">$</span>( map<span class="op">.</span>insert(<span class="op">$</span>key<span class="op">,</span> <span class="op">$</span>val)<span class="op">;</span> )<span class="op">*</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>          map</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}}</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> <span class="pp">hash_map!</span><span class="op">{</span><span class="st">&quot;one&quot;</span> <span class="op">=&gt;</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;two&quot;</span> <span class="op">=&gt;</span> <span class="dv">2</span><span class="op">}</span>)<span class="op">;</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> finnish_traditional_foods <span class="op">=</span> <span class="pp">hash_map!</span><span class="op">{</span> <span class="co">// not even remotely a complete list</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Etelä-Savo&quot;</span> <span class="op">=&gt;</span> <span class="pp">vec!</span>[<span class="st">&quot;rättänä&quot;</span><span class="op">,</span> <span class="st">&quot;muikiainen&quot;</span>]<span class="op">,</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Etelä-Karjala&quot;</span> <span class="op">=&gt;</span> <span class="pp">vec!</span>[<span class="st">&quot;särä&quot;</span>]<span class="op">,</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Häme&quot;</span> <span class="op">=&gt;</span> <span class="pp">vec!</span>[<span class="st">&quot;piimäjuusto&quot;</span><span class="op">,</span> <span class="st">&quot;munajuusto&quot;</span>]<span class="op">,</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Kymenlaakso&quot;</span> <span class="op">=&gt;</span> <span class="pp">vec!</span>[<span class="st">&quot;perunaleposka&quot;</span>]<span class="op">,</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Pirkanmaa&quot;</span> <span class="op">=&gt;</span> <span class="pp">vec!</span>[<span class="st">&quot;mustamakkara&quot;</span>]<span class="op">,</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Pohjois-Pohjanmaa&quot;</span> <span class="op">=&gt;</span> <span class="pp">vec!</span>[<span class="st">&quot;ruppana&quot;</span>]<span class="op">,</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:#?}&quot;</span><span class="op">,</span> finnish_traditional_foods)<span class="op">;</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Another option, one that also prevents creating a new hash map with
hash_map!{,}, would be to leverage the first rule in another rule.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> hash_map <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>( <span class="op">$</span>key<span class="op">:</span> expr <span class="op">=&gt;</span> <span class="op">$</span>val<span class="op">:</span> expr )<span class="op">,*</span>) <span class="op">=&gt;</span> <span class="op">{{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> map <span class="op">=</span> <span class="pp">::std::collections::HashMap::</span>new()<span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">$</span>( map<span class="op">.</span>insert(<span class="op">$</span>key<span class="op">,</span> <span class="op">$</span>val)<span class="op">;</span> )<span class="op">*</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>        map</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}};</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>(<span class="op">$</span>key<span class="op">:</span> expr <span class="op">=&gt;</span> <span class="op">$</span>val<span class="op">:</span> expr)<span class="op">,+,</span>) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">hash_map!</span>(<span class="op">$</span>(<span class="op">$</span>key <span class="op">=&gt;</span> <span class="op">$</span>val)<span class="op">,+</span>)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> <span class="pp">hash_map!</span><span class="op">{</span><span class="st">&quot;one&quot;</span> <span class="op">=&gt;</span> <span class="dv">1</span><span class="op">,</span> <span class="st">&quot;two&quot;</span> <span class="op">=&gt;</span> <span class="dv">2</span><span class="op">}</span>)<span class="op">;</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> finnish_traditional_foods <span class="op">=</span> <span class="pp">hash_map!</span><span class="op">{</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Etelä-Savo&quot;</span> <span class="op">=&gt;</span> <span class="pp">vec!</span>[<span class="st">&quot;rättänä&quot;</span><span class="op">,</span> <span class="st">&quot;muikiainen&quot;</span>]<span class="op">,</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Etelä-Karjala&quot;</span> <span class="op">=&gt;</span> <span class="pp">vec!</span>[<span class="st">&quot;särä&quot;</span>]<span class="op">,</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Häme&quot;</span> <span class="op">=&gt;</span> <span class="pp">vec!</span>[<span class="st">&quot;piimäjuusto&quot;</span><span class="op">,</span> <span class="st">&quot;munajuusto&quot;</span>]<span class="op">,</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Kymenlaakso&quot;</span> <span class="op">=&gt;</span> <span class="pp">vec!</span>[<span class="st">&quot;perunaleposka&quot;</span>]<span class="op">,</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Pirkanmaa&quot;</span> <span class="op">=&gt;</span> <span class="pp">vec!</span>[<span class="st">&quot;mustamakkara&quot;</span>]<span class="op">,</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Pohjois-Pohjanmaa&quot;</span> <span class="op">=&gt;</span> <span class="pp">vec!</span>[<span class="st">&quot;ruppana&quot;</span>]<span class="op">,</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:#?}&quot;</span><span class="op">,</span> finnish_traditional_foods)<span class="op">;</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="impl-macro">Impl macro</h3>
<p>Function-like macros are not limited to expanding to blocks and
expression, but can produce arbitrary code. Below is a common use case
for declarative macros: implement a trait for a type — declarative
macros are much easier to conjure up than custom derive macros.</p>
<p>In the below example, we have the trait Exclamated with method
exclamated that returns a string with an exclamation mark appended to
it. We’ll create a macro to trivially implement the trait to any type
that implements the ToString trait or has a to_string() method.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Exclamated <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> exclamated(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">String</span><span class="op">;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>For the implementation generating macro, we’ll want to have the
matcher to match a type instead of an expression, so we’ll have give the
matcher fragment the specifier ty.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Exclamated <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> exclamated(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">String</span><span class="op">;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> impl_exclamated <span class="op">{</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>t<span class="op">:</span>ty) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span> <span class="kw">crate</span><span class="pp">::</span>Exclamated <span class="cf">for</span> <span class="op">$</span>t <span class="op">{</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> exclamated(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="pp">::std::string::</span><span class="dt">String</span> <span class="op">{</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>                <span class="pp">format!</span>(<span class="st">&quot;{}!&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>to_string())</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a><span class="pp">impl_exclamated!</span>(<span class="dt">String</span>)<span class="op">;</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="pp">impl_exclamated!</span>(<span class="op">&amp;</span><span class="dt">str</span>)<span class="op">;</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a><span class="pp">impl_exclamated!</span>(<span class="dt">i32</span>)<span class="op">;</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s <span class="op">=</span> <span class="st">&quot;Hello, world&quot;</span><span class="op">.</span>to_string()<span class="op">;</span></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> s<span class="op">.</span>exclamated())<span class="op">;</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="st">&quot;Hello, world&quot;</span><span class="op">.</span>exclamated())<span class="op">;</span></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">.</span>exclamated())<span class="op">;</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When a struct does not implement ToString, or we don’t want our
“default” implementation from the macro, we can simply implement the
trait manually.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Exclamated <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> exclamated(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">String</span><span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> impl_exclamated <span class="op">{</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>t<span class="op">:</span>ty) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span> <span class="kw">crate</span><span class="pp">::</span>Exclamated <span class="cf">for</span> <span class="op">$</span>t <span class="op">{</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> exclamated(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="pp">::std::string::</span><span class="dt">String</span> <span class="op">{</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>                <span class="pp">format!</span>(<span class="st">&quot;{}!&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>to_string())</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a><span class="pp">impl_exclamated!</span>(<span class="dt">String</span>)<span class="op">;</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="pp">impl_exclamated!</span>(<span class="op">&amp;</span><span class="dt">str</span>)<span class="op">;</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a><span class="pp">impl_exclamated!</span>(<span class="dt">i32</span>)<span class="op">;</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Person <span class="op">{</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>    name<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a><span class="pp">impl_exclamated!</span>(Person)<span class="op">;</span></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s <span class="op">=</span> <span class="st">&quot;Hello, world&quot;</span><span class="op">.</span>to_string()<span class="op">;</span></span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> s<span class="op">.</span>exclamated())<span class="op">;</span></span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="st">&quot;Hello, world&quot;</span><span class="op">.</span>exclamated())<span class="op">;</span></span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">.</span>exclamated())<span class="op">;</span></span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> p <span class="op">=</span> Person <span class="op">{</span> name<span class="op">:</span> <span class="st">&quot;John&quot;</span><span class="op">.</span>to_string() <span class="op">};</span></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> p<span class="op">.</span>exclamated())<span class="op">;</span></span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can take our macro a step further by adding another rule which
takes a field in addition to the type name. Then we can implement
Exclamated for the Person struct too with the macro, or for any other
struct that has a single field that should be exclamated.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">trait</span> Exclamated <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> exclamated(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">String</span><span class="op">;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> impl_exclamated <span class="op">{</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>t<span class="op">:</span>ty) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span> <span class="kw">crate</span><span class="pp">::</span>Exclamated <span class="cf">for</span> <span class="op">$</span>t <span class="op">{</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> exclamated(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="pp">::std::string::</span><span class="dt">String</span> <span class="op">{</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>                <span class="pp">format!</span>(<span class="st">&quot;{}!&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.</span>to_string())</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>t<span class="op">:</span>ty<span class="op">,</span> <span class="op">$</span>field<span class="op">:</span>ident) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">impl</span> <span class="kw">crate</span><span class="pp">::</span>Exclamated <span class="cf">for</span> <span class="op">$</span>t <span class="op">{</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>            <span class="kw">fn</span> exclamated(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="pp">::std::string::</span><span class="dt">String</span> <span class="op">{</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>                <span class="pp">format!</span>(<span class="st">&quot;{}!&quot;</span><span class="op">,</span> <span class="kw">self</span><span class="op">.$</span>field)</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a><span class="pp">impl_exclamated!</span>(<span class="dt">String</span>)<span class="op">;</span></span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a><span class="pp">impl_exclamated!</span>(<span class="op">&amp;</span><span class="dt">str</span>)<span class="op">;</span></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a><span class="pp">impl_exclamated!</span>(<span class="dt">i32</span>)<span class="op">;</span></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Person <span class="op">{</span></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>    name<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a><span class="pp">impl_exclamated!</span>(Person<span class="op">,</span> name)<span class="op">;</span></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> s <span class="op">=</span> <span class="st">&quot;Hello, world&quot;</span><span class="op">.</span>to_string()<span class="op">;</span></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> s<span class="op">.</span>exclamated())<span class="op">;</span></span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="st">&quot;Hello, world&quot;</span><span class="op">.</span>exclamated())<span class="op">;</span></span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="dv">42</span><span class="op">.</span>exclamated())<span class="op">;</span></span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> p <span class="op">=</span> Person <span class="op">{</span> name<span class="op">:</span> <span class="st">&quot;John&quot;</span><span class="op">.</span>to_string() <span class="op">};</span></span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> p<span class="op">.</span>exclamated())<span class="op">;</span></span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Notice the specifier for the $field, ident, which matches any
identifier or keyword.</p>
<p>The full list of available fragment specifier can be viewed in The
Little Book of Rust Macros. There’s for instance the lifetime and item
specifiers, or the more general tt specifier which matches any token
tree (a tree data structure of parsed tokens). Anyhow, we won’t be
needing other than the expr and ty and ident, so no need to stress out
about those for this course. We’ll be able to write plenty of useful
macros with just the simpler specifiers, and besides, tt matches all of
those and more</p>
<h3 id="visibility">Visibility</h3>
<p>Macros are items like any other, so they can be public or private,
shadowed, and are restricted to the scope they are declared in. There is
a difference though in exporting macros as we can’t just prepend
macro_rules! with pub to make it public. Instead, we need to add the
attribute #[macro_export] in front of the macro_rules! invocation. The
macro will be exported at the root of the crate, so we don’t need to
import from the module in the main file.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">mod</span> macros <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pub</span> <span class="pp">macro_rules!</span> exclamated <span class="op">{</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>        (<span class="op">$</span>arg<span class="op">:</span>expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>            <span class="pp">format!</span>(<span class="st">&quot;{}!&quot;</span><span class="op">,</span> <span class="op">$</span>arg)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">macros::</span>exclamated<span class="op">;</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> println <span class="op">{</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>arg<span class="op">:</span>expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>        <span class="pp">::std::println!</span>(<span class="st">&quot;{}!&quot;</span><span class="op">,</span> <span class="op">$</span>arg)</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="pp">exclamated!</span>(<span class="st">&quot;Hello, world&quot;</span>))<span class="op">;</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="pp">exclamated!</span>(<span class="dv">42</span>))<span class="op">;</span></span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Another quirk with declarative macros is that we can’t use them in
code that comes before the macro declaration.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">exclamated!</span>(<span class="st">&quot;Hello, world&quot;</span>))<span class="op">;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="pp">exclamated!</span>(<span class="dv">42</span>))<span class="op">;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="pp">macro_rules!</span> exclamated <span class="op">{</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span>arg<span class="op">:</span>expr) <span class="op">=&gt;</span> <span class="op">{</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>        <span class="pp">format!</span>(<span class="st">&quot;{}!&quot;</span><span class="op">,</span> <span class="op">$</span>arg)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>If we try that anyway, we’ll get an error saying that the macro is
not found in the scope and an outdated suggestion of using #[macro_use]
on the module/import — the #[macro_use] attribute is no longer needed in
Rust editions 2018+.</p>
<h2 id="attributes">Attributes</h2>
<p>Attributes are used to add metadata to Rust code. Attributes can be
either outer attributes or inner attributes.</p>
<p>Outer attributes affect only what comes right after the attribute. To
declare an outer attribute in Rust code, we write a # and the attribute
name and possible attribute parameters inside square brackets [] before
the item we want to add the attribute to. As a familiar example, we can
add the #[derive(Debug)] attribute (derive-attribute with parameter
Debug) to a struct, we write</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Person <span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    name<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> p <span class="op">=</span> Person <span class="op">{</span> name<span class="op">:</span> <span class="st">&quot;Elie&quot;</span><span class="op">.</span>to_string() <span class="op">};</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{p:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Inner attributes are declared like outer attributes except that they
are marked with a ! after the # (e.g. #[feature(print_internals)]).
Inner attributes apply to the whole item where the inner attribute is
declared in and are usually found at the top of a file (the attribute is
applied to the whole file).</p>
<p>As an example, we can disable warnings with the allow-attribute for a
whole module (file) by providing it warning we want to disable as an
argument — you’ve probably already seen your fair share of compiler
warnings. The compiler tells us the name of the warning by informing us
of the warn-attribute that caused the warning so that we know which
warning we may or may not want to allow (the defaults are quite good for
most use cases).</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::collections::</span>HashMap<span class="op">;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Todo<span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>To demonstrate the difference between outer and inner attributes (and
showcase some more linting attributes), we’ll set some inner deny and
forbid attributes that disallow any code that would generate a specific
warning (deny gives an error instead of a warning and forbid also
prevents overwriting the denial with an allow attribute). Then we’ll fix
the code by explicitly annotating each problematic item with a proper
allow attribute or fixing the issue in case of a forbidden linting
issue.</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>deny<span class="at">(</span>dead_code<span class="at">)]</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>forbid<span class="at">(</span>missing_docs<span class="at">)]</span> <span class="co">// applies only to public items</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>deny<span class="at">(</span>unused_results<span class="at">)]</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Todo<span class="op">;</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> miles_to_kilometers(miles<span class="op">:</span> <span class="kw">impl</span> <span class="bu">Into</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    miles<span class="op">.</span>into() <span class="op">*</span> <span class="dv">1.609</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>allow<span class="at">(</span>unused_variables<span class="at">)]</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">13</span><span class="op">;</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> vec <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>    vec<span class="op">.</span>remove(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{vec:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="different-kinds-of-attributes">Different kinds of
attributes</h3>
<p>Rust attributes can be classified into four different types.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Attribute type</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Examples</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Built-in attributes</td>
<td style="text-align: left;">Attributes that are built into the
compiler.</td>
<td style="text-align: left;">#[derive(Debug)],
#[warn(missing_docs)]</td>
</tr>
<tr class="even">
<td style="text-align: left;">Macro attributes</td>
<td style="text-align: left;">Attributes that are created by procedural
macros.</td>
<td style="text-align: left;">#[my_attribute],
#[my_attribute_with_params(param1, param2)]</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Derive macro helper attributes</td>
<td style="text-align: left;">Additional attributes in the scope of a
derive macro that can be used to customize t</td>
<td style="text-align: left;">he derive behavior, such as attributes
that determine how a field should be used for the derived trait.
#[derive(Derive)] enum Enum { #[default] DefaultEnumVariant,
OtherEnumVariant }</td>
</tr>
<tr class="even">
<td style="text-align: left;">Tool attributes</td>
<td style="text-align: left;">Attributes that are used by tools like
rustfmt and clippy.</td>
<td style="text-align: left;">#[rustfmt::skip],
#[clippy:cognitive_complexity = “10”]</td>
</tr>
</tbody>
</table>
<p>Albeit not much, this should already be enough for the basics of
attributes. As you have probably noticed by now, using attributes is
rather simple as long as you know what the attribute is doing. To see
more detailed info, more examples, as well as the full list of built-in
attributes, check the Rust reference.</p>
<p>Let’s anyway take a look at some custom made attributes in action.
Specifically, two derive attributes and some of their derive helper
attributes from the crate serde which provides serialization and
deserialization for Rust structs.</p>
<p>Serialization means transforming a data structure into a format that
can be saved (e.g. to a file) or transmitted (e.g. over a network) and
then reconstructed (i.e. deserialized) at a later time.</p>
<p>We’ll also be using the serde_json crate which uses serde to
serialize and deserialize Rust structs to and from JSON strings — the
most common data interchange format for web APIs nowadays.</p>
<p>As an example, a Point struct with float fields x and y could be
serialized to a JSON string like this:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;x&quot;</span><span class="fu">:</span> <span class="fl">5.0</span><span class="fu">,</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;y&quot;</span><span class="fu">:</span> <span class="fl">10.0</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p>To be able to serialize and deserialize a struct with serde, we need
to add its Serialize and Deserialize traits to the struct. We can do
this by with the derive attribute.</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">serde::</span><span class="op">{</span>Serialize<span class="op">,</span> Deserialize<span class="op">};</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> Serialize<span class="op">,</span> Deserialize<span class="at">)]</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    x<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    y<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> point <span class="op">=</span> Point <span class="op">{</span> x<span class="op">:</span> <span class="dv">5.0</span><span class="op">,</span> y<span class="op">:</span> <span class="dv">10.0</span> <span class="op">};</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> serialized <span class="op">=</span> <span class="pp">serde_json::</span>to_string(<span class="op">&amp;</span>point)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;serialized = {serialized}&quot;</span>)<span class="op">;</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> deserialized<span class="op">:</span> Point <span class="op">=</span> <span class="pp">serde_json::</span>from_str(<span class="op">&amp;</span>serialized)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;deserialized = {deserialized:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>To run this locally, we also need to add the serde and serde_json
crates to the project’s Cargo.toml file. We also need the serde’s
“derive” feature which does not come with default features.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode toml"><code class="sourceCode toml"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[</span><span class="dt">dependencies</span><span class="kw">]</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="dt">serde</span> <span class="op">=</span> <span class="op">{ </span><span class="dt">version</span><span class="op"> =</span> <span class="st">&quot;1.0.95&quot;</span><span class="op">, </span><span class="dt">features</span><span class="op"> =</span> <span class="op">[</span><span class="st">&quot;derive&quot;</span><span class="op">]</span> <span class="op">}</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="dt">serde_json</span> <span class="op">=</span> <span class="st">&quot;1.0.95&quot;</span></span></code></pre></div>
<p>The derive macro for Serialize and Deserialize has some useful helper
attributes by the name serde that we can use for instance to define
default values for fields, have different names for fields than in the
JSON or disallow fields not present in the struct.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">serde::</span><span class="op">{</span>Deserialize<span class="op">,</span> Serialize<span class="op">};</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> Serialize<span class="op">,</span> Deserialize<span class="at">)]</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>serde<span class="at">(</span>deny_unknown_fields<span class="at">)]</span> <span class="co">// disallow fields not present in the struct</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>serde<span class="at">(</span><span class="kw">default</span><span class="at">)]</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>serde<span class="at">(</span>rename <span class="op">=</span> <span class="st">&quot;a&quot;</span><span class="at">)]</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    x<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>serde<span class="at">(</span><span class="kw">default</span><span class="at">)]</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>serde<span class="at">(</span>rename <span class="op">=</span> <span class="st">&quot;b&quot;</span><span class="at">)]</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    y<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>serde<span class="at">(</span><span class="kw">default</span><span class="at">)]</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>serde<span class="at">(</span>rename <span class="op">=</span> <span class="st">&quot;c&quot;</span><span class="at">)]</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    z<span class="op">:</span> <span class="dt">f64</span><span class="op">,</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="op">,</span> Serialize<span class="op">,</span> Deserialize<span class="at">)]</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>serde<span class="at">(</span>rename_all <span class="op">=</span> <span class="st">&quot;camelCase&quot;</span><span class="at">)]</span></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> FullName <span class="op">{</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>serde<span class="at">(</span><span class="kw">default</span> <span class="op">=</span> <span class="st">&quot;default_first_name&quot;</span><span class="at">)]</span></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>    first_name<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>    last_name<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> default_first_name() <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Douglas&quot;</span><span class="op">.</span>to_string()</span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> json <span class="op">=</span> <span class="st">r#&quot;{</span></span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a><span class="st">        &quot;a&quot;: 5.0,</span></span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a><span class="st">        &quot;d&quot;: 15.0</span></span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a><span class="st">    }&quot;#</span><span class="op">;</span></span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> deserialized<span class="op">:</span> Point <span class="op">=</span> <span class="pp">serde_json::</span>from_str(json)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;deserialized = {deserialized:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> full_name <span class="op">=</span> FullName <span class="op">{</span></span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a>        first_name<span class="op">:</span> <span class="st">&quot;Douglas&quot;</span><span class="op">.</span>to_string()<span class="op">,</span></span>
<span id="cb39-39"><a href="#cb39-39" aria-hidden="true" tabindex="-1"></a>        last_name<span class="op">:</span> <span class="st">&quot;Crockford&quot;</span><span class="op">.</span>to_string()<span class="op">,</span></span>
<span id="cb39-40"><a href="#cb39-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb39-41"><a href="#cb39-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> serialized <span class="op">=</span> <span class="pp">serde_json::</span>to_string(<span class="op">&amp;</span>full_name)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb39-42"><a href="#cb39-42" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;serialized = {serialized}&quot;</span>)<span class="op">;</span></span>
<span id="cb39-43"><a href="#cb39-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In case you are interested in how the serde attributes are created,
you can always check out the code in the Serde GitHub repository. It’s
probably best to start to with some simpler procedural macros though,
links to materials with examples can be found in the next section.</p>
<h2 id="procedural-macros-extra">Procedural macros: extra</h2>
<p>Creating procedural macros can be quite a bit more complex than
creating declarative macros since writing them usually requires parsing
code as token trees. We’ll have only a super short intro for procedural
macros here but will provide links to external materials. There will be
no exercises (it’s not because the course grader does not support
testing such currently, we swear…).</p>
<p>Procedural macros are special functions that take a TokenStream or
two as input and return back a TokenStream as output. The TokenStream is
a stream of TokenTrees (remember the tt fragment specifier for token
tree in declarative macro matchers). The output TokenStream represents
the code that the macro will expand to.</p>
<p>In essence, procedural macros are Rust functions that manipulate Rust
code represented as token trees. Procedural macros can be used to create
all three kinds of macros:</p>
<pre><code>Function-like macros (macros that expand to code that looks like a function call, the same ones that can be generated with declarative macros), defined with #[proc_macro] attribute,
Derive macros (custom derive implementations for traits), defined with #[proc_macro_derive]
Attribute macros (custom attributes), defined with #[proc_macro_attribute]</code></pre>
<p>However, unlike declarative macros, we can’t just write a macro in a
file and start using it. Procedural macros can only be defined inside a
crate of the proc-macro type.</p>
<p>Instructions on how to create such a crate as well as a derive macro
can be found both in the Rust Book and in this LogRocket blog post. At
the end of the blog post you can find further links for example on how
to work with token streams to create procedural macros.</p>
<p>A short intro and simple examples for the different kinds of
procedural macros can be found in this other LogRocket blog post, and
the Rust reference. The Little Book of Rust Macros has a short chapter
on procedural macros also, but it is more bare-bones than the materials
in the blog or the Rust reference. Likewise, the Rust Book has only very
little info on the other types of macros at the end of its chapter on
macros.</p>
<p>In case you are itching for some exercises on procedural macros, the
Proc Macro workshop by David Tolnay has a few that are guided by tests.
They can be difficult though.</p>
</body>
</html>
