<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>loops_and_iteration loops_and_iteration</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://lerina.github.io/css/styles_min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#loops-and-iteration" id="toc-loops-and-iteration">Loops
and iteration</a>
<ul>
<li><a href="#looping" id="toc-looping">Looping</a></li>
<li><a href="#iterators-and-adapters"
id="toc-iterators-and-adapters">Iterators and adapters</a></li>
<li><a href="#closures" id="toc-closures">Closures</a></li>
</ul></li>
</ul>
</nav>
<h1 id="loops-and-iteration">Loops and iteration</h1>
<p><a
href="https://fitech101.aalto.fi/programming-languages/rust/7-loops-and-iteration/">source</a></p>
<h2 id="looping">Looping</h2>
<p>We often want to execute one or more statements in our code more than
once. Programming code instructions that allow us to repeatedly execute
parts of code are usually called loops. Rust provides us with three
types of loops: loop, while, and for.</p>
<h3 id="loop">Loop</h3>
<p>The simplest form of a loop in Rust is an infinite loop. By placing
the keyword loop in front of a block expression that serves as the body
of the loop, we can infinitely repeat executing the block
expression.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Waiting for a cosmic ray to hit the CPU and exit this loop...&quot;</span>)<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In many cases we don‚Äôt want to loop forever, but stop at some point.
Breaking a loop can be done with a break statement in the body of the
loop ‚Äî return would also work, but that would exit the enclosing
function too, not just the loop.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> p <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;The powers of 2:&quot;</span>)<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span> <span class="co">// infinite loop</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;2^{}={}&quot;</span><span class="op">,</span> i<span class="op">,</span> p)<span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> np <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> p<span class="op">;</span> <span class="co">// next p</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> np<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> p <span class="op">&gt;</span> <span class="dv">100</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// end of the body of the loop -&gt; jump to the beginning of the loop</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Like if statements, loops too can be used as expressions. The value
of the loop expression is the value specified with break <value>; (using
break works just like using return, only it returns from a surrounding
loop expression and not the surrounding function).</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> p <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> limit <span class="op">=</span> <span class="dv">99</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (v<span class="op">,</span> e) <span class="op">=</span> <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> np <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> p<span class="op">;</span> <span class="co">// next p</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np <span class="op">&gt;</span> limit <span class="op">{</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span> (p<span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span>)<span class="op">;</span> <span class="co">// break with value</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> np<span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;The biggest power of 2 below {limit} is 2^{e}={v}&quot;</span>)<span class="op">;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We may also want to skip the rest of the loop body and jump to the
beginning of the loop. This can be done with the continue statement.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> year <span class="op">=</span> <span class="dv">2023</span><span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        year <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> year <span class="op">%</span> <span class="dv">4</span> <span class="op">!=</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> year <span class="op">%</span> <span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> year <span class="op">%</span> <span class="dv">400</span> <span class="op">!=</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;The next leap year is {}&quot;</span><span class="op">,</span> year)<span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span><span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="while">While</h3>
The while loop, while very similar to loop, requires an additional
stopping condition in the form of while <boolean expression> {
<body of the loop>
<p>} ‚Äî loop is equivalent to while true. The body of the loop is
executed as long as the condition evaluates to true.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> p <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;The powers of 3:&quot;</span>)<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> p <span class="op">&lt;</span> <span class="dv">100</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;3^{}={}&quot;</span><span class="op">,</span> i<span class="op">,</span> p)<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        p <span class="op">*=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<blockquote>
<p>Cohersing a do_while</p>
</blockquote>
<p>The condition of a while-loop can be any expression (including one
with side effects such as mutating variables) as long as the expression
evaluates to a boolean value. Blocks are expressions in Rust, which
means that we can do a dirty trick to turn Rust‚Äôs ‚Äúwhile do‚Äù into a ‚Äúdo
while‚Äù loop.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> p <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;The powers of 3:&quot;</span>)<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// do</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;3^{}={}&quot;</span><span class="op">,</span> i<span class="op">,</span> p)<span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        p <span class="op">*=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// while</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        p <span class="op">&lt;</span> <span class="dv">2000</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="op">{</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// the actual body of the loop</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// do nothing here</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>While this works, it is heavily frowned upon because it is much less
readable than the Rust‚Äôs while when used normally. Please refrain from
using such hacks.</p>
<hr />
<p>The break and continue statements work in while loops just like with
loop.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> year <span class="op">=</span> <span class="dv">2000</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> leap_years <span class="op">=</span> <span class="pp">vec!</span>[]<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> year <span class="op">&lt;</span> <span class="dv">2023</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        year <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> year <span class="op">%</span> <span class="dv">4</span> <span class="op">!=</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> year <span class="op">%</span> <span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> year <span class="op">%</span> <span class="dv">400</span> <span class="op">!=</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        leap_years<span class="op">.</span>push(year)<span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;The leap years between 2000 and 2023 are {leap_years:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="for">For</h3>
<p>The third type of loop in Rust is the for loop that can be used to
iterate over a set of values. The for loop can be much more concise than
loop or while, for instance when we want to loop over a range of
values.</p>
<p>Similarly as we used ..= for a range pattern previously, we can use
the same syntax to create a range of values to iterate over with
for.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">0</span><span class="op">..=</span><span class="dv">9</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">print!</span>(<span class="st">&quot;{i}&quot;</span>)<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The same code using a while loop would look something like</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> i <span class="op">&lt;=</span> <span class="dv">9</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">print!</span>(<span class="st">&quot;{i}&quot;</span>)<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Leaving out the = in the range pattern would create a range that does
not include the last value, so 0..3 would iterate over the values 0, 1,
and 2.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="dv">0</span><span class="op">..</span><span class="dv">10</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">print!</span>(<span class="st">&quot;{i}&quot;</span>)<span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<p>Note: The ..= syntax is used for both ranges and patterns. In
patterns, however the = is required due to current compiler limitations
(overlap with slice syntax parsing). Trying to use an exclusive range as
a pattern causes an error.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">match</span> x <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span><span class="op">..</span><span class="dv">10</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;x is between 0 and 9&quot;</span>)<span class="op">,</span> <span class="co">// Cause error!</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// use  0..=9 =&gt; ... </span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        _ <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;x is not between 0 and 10&quot;</span>)<span class="op">,</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<p>Besides ranges, we can use a for loop to iterate over other sets of
values like vectors, arrays and hash maps.</p>
<p>The next example iterates over an array of degrees Celsius to create
a new vector of the degrees converted to Fahrenheit.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> celsius_to_fahrenheit(f<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    f <span class="op">*</span> <span class="dv">9.0</span> <span class="op">/</span> <span class="dv">5.0</span> <span class="op">+</span> <span class="dv">32.0</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> celsiuses <span class="op">=</span> [<span class="dv">1.0f64</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">10.0</span><span class="op">,</span> <span class="dv">100.0</span>]<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> fahrenheits <span class="op">=</span> <span class="pp">vec!</span>[]<span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> celsius <span class="kw">in</span> celsiuses <span class="op">{</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        fahrenheits<span class="op">.</span>push(celsius_to_fahrenheit(celsius))<span class="op">;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;C: {celsiuses:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;F: {fahrenheits:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Using for to iterate over a hash map gives a tuple of the key and
value of each entry.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::collections::</span>HashMap<span class="op">;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> map <span class="op">=</span> <span class="pp">HashMap::</span>from([</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;bear&quot;</span><span class="op">,</span> <span class="st">&quot;üêª&quot;</span>)<span class="op">,</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;wolf&quot;</span><span class="op">,</span> <span class="st">&quot;üê∫&quot;</span>)<span class="op">,</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;fox&quot;</span><span class="op">,</span> <span class="st">&quot;ü¶ä&quot;</span>)<span class="op">,</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    ])<span class="op">;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (animal<span class="op">,</span> emoji) <span class="kw">in</span> map <span class="op">{</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;:{animal}: -&gt; {emoji}&quot;</span>)<span class="op">;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="modifying-through-iteration">Modifying through iteration</h3>
<p>Using a for loop on an iterable collection implicitly calls the
into_iter method of the collection to get an iterator of immutable
values over the collection. The for loop then iterates over the values
in the iterator.</p>
<p>To be able to modify values in a mutable collection using a for loop,
we can call the iter_mut method to get an iterator over mutable
references to the collection values.</p>
<p>In the next example, the array of degrees Celsius are converted
in-place to degrees Fahrenheit.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> celsius_to_fahrenheit(f<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    f <span class="op">*</span> <span class="dv">9.0</span> <span class="op">/</span> <span class="dv">5.0</span> <span class="op">+</span> <span class="dv">32.0</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> temperatures <span class="op">=</span> [<span class="dv">1.0f64</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">10.0</span><span class="op">,</span> <span class="dv">100.0</span>]<span class="op">;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> temp <span class="kw">in</span> temperatures<span class="op">.</span>iter_mut() <span class="op">{</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>temp <span class="op">=</span> celsius_to_fahrenheit(<span class="op">*</span>temp)<span class="op">;</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{temperatures:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The HashMap collection has some more options that allow us to easily
iterate over just its values or keys (check out the documentation). For
instance, we can loop over mutable references to the values of the map
with the help of the values_mut method.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::collections::</span>HashMap<span class="op">;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> INFLATION_RATE<span class="op">:</span> <span class="dt">f32</span> <span class="op">=</span> <span class="dv">1.07</span><span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> inflate_prices(map<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> HashMap<span class="op">&lt;&amp;</span><span class="dt">str</span><span class="op">,</span> <span class="dt">f32</span><span class="op">&gt;,</span> years<span class="op">:</span> <span class="dt">i32</span>) <span class="op">{</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> price <span class="kw">in</span> map<span class="op">.</span>values_mut() <span class="op">{</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>price <span class="op">=</span> <span class="op">*</span>price <span class="op">*</span> (INFLATION_RATE<span class="op">.</span>powi(years))<span class="op">;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> food_prices <span class="op">=</span> <span class="pp">HashMap::</span>from([(<span class="st">&quot;beetroot&quot;</span><span class="op">,</span> <span class="dv">1.2</span>)<span class="op">,</span> (<span class="st">&quot;cabbage&quot;</span><span class="op">,</span> <span class="dv">1.1</span>)<span class="op">,</span> (<span class="st">&quot;carrot&quot;</span><span class="op">,</span> <span class="dv">1.0</span>)])<span class="op">;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;before inflation {food_prices:#?}&quot;</span>)<span class="op">;</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    inflate_prices(<span class="op">&amp;</span><span class="kw">mut</span> food_prices<span class="op">,</span> <span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;after 10 years of inflation {food_prices:#?}&quot;</span>)<span class="op">;</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The iter_mut method also would works on HashMap but it would give us
mutable references to both the keys and values instead of just the
values.</p>
<p>Remember that when passing a mutable value to a function as a
reference, the reference needs to be explicitly marked as mutable with
&amp;mut. Otherwise the function will receive an immutable reference and
the values cannot be modified therein. We also need to dereference the
references with the * operator.</p>
<h2 id="iterators-and-adapters">Iterators and adapters</h2>
<p>We already familiarized ourselves with iterators when working with
for to iterate over collections, but let‚Äôs now dive a bit deeper into
the topic.</p>
<p>Iterators are types that provide useful methods for inspecting and
processing iterable data structures like arrays and vectors. The
iterator methods come in two flavours: iterator adapters are methods
that return a new (possibly modified) iterator and iterator consumers
are methods that consume the iterator. With the help of iterator
adapters and consumers, iterators can often be used to do same things as
for loops but more expressively and concisely using functional
syntax.</p>
<p>Iterators in Rust are an example of zero-cost-abstractions. They
offer convenient functionality while posing no additional computational
overhead compared to operating directly on the collection.</p>
<p>Let‚Äôs look at how we can convert a list of degrees Celsius to degrees
Fahrenheit, like we did before, but this time using the iterator
consumer for_each.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> celsius_to_fahrenheit(f<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="dt">f64</span>) <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>f <span class="op">=</span> <span class="op">*</span>f <span class="op">*</span> <span class="dv">9.0</span> <span class="op">/</span> <span class="dv">5.0</span> <span class="op">+</span> <span class="dv">32.0</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> temperatures <span class="op">=</span> [<span class="dv">1.0f64</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">10.0</span><span class="op">,</span> <span class="dv">100.0</span>]<span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    temperatures</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>iter_mut() <span class="co">// .iter_mut() returns an Iterator that iterates over mutable references</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>for_each(celsius_to_fahrenheit)<span class="op">;</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{temperatures:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The for_each method of Iterator takes in a function and applies it on
each value in the iterator. Notice that we used the same iter_mut as
with the for loop. However, we needed to modify the
celsius_to_fahrenheit function to take in a mutable reference to the
value.</p>
<h3 id="consuming-iterators">Consuming iterators</h3>
<p>Let‚Äôs now take a look how we can use the adapter map to transform the
values from an iterator.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> miles_to_kilometers(miles<span class="op">:</span> <span class="op">&amp;</span><span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  miles <span class="op">*</span> <span class="dv">1.609344</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> miles <span class="op">=</span> [<span class="dv">1.0f64</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">10.0</span><span class="op">,</span> <span class="dv">100.0</span>]<span class="op">;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> kilometers <span class="op">=</span> miles</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>iter() <span class="co">// .iter() returns an Iterator over immutable references</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>map(miles_to_kilometers)<span class="op">;</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{kilometers:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>By running the code, we see that calling map didn‚Äôt actually apply
the given function but the values in the iterator appear to be the same
as original. This is because iterators are lazy and do not compute their
values until they are consumed. Iterator laziness has multiple benefits
in terms of performance, especially when chaining adapters or when
needing only some of the values from an iterator.</p>
<p>To get the values from the iterator, we can use the collect method of
the iterator. This method consumes the iterator and collects the values
into a collection. The solution to the above example shows how to
collect the values into a Vec<f64>.</p>
<p>When we want to iterate over owned values, we can use the into_iter
method. This moves or copies the values of a collection into the
returned iterator, depending on whether the collection is copiable. If
the collection owns the values (is not e.g.¬†a slice), the iterator
values are also owned.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> celsius_to_fahrenheit(f<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    f <span class="op">*</span> <span class="dv">9.0</span> <span class="op">/</span> <span class="dv">5.0</span> <span class="op">+</span> <span class="dv">32.0</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> celsiuses <span class="op">=</span> [<span class="dv">1.0f64</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">10.0</span><span class="op">,</span> <span class="dv">100.0</span>]<span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> fahrenheits <span class="op">=</span> celsiuses</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>into_iter()</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>map(celsius_to_fahrenheit)</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span><span class="pp">collect::</span><span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;&gt;</span>()<span class="op">;</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;degrees Celsius: {celsiuses:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;degrees Fahrenheit: {fahrenheits:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Here, instead of specifying the type of the fahrenheits variable, we
used the ‚Äúturbofish‚Äù syntax ::&lt;&gt; to specify the output type of the
collect method.</p>
<hr />
<blockquote>
<p>Generic function output and the turbo::fish</p>
</blockquote>
<p>Some methods, like String‚Äôs parse and Iterator‚Äôs collect, have
generic output types. Whenever they are used, the compiler requires us
to specify the target type of the output. This can be done either by
explicitly specifying a type of the output variable</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> number<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="st">&quot;42&quot;</span><span class="op">.</span>parse()<span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">r#&quot;Thus &quot;42&quot; becomes {number:?}&quot;#</span>)<span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>or by using the ‚Äúturbofish‚Äù syntax <code>::&lt;&gt;</code>.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> number <span class="op">=</span> <span class="st">&quot;42&quot;</span><span class="op">.</span><span class="pp">parse::</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span>()<span class="op">;</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">r#&quot;Thus &quot;42&quot; becomes {number:?}&quot;#</span>)<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In some cases, the type information can also be inferred from the
context, like when returning a value from a function.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> power_up(values<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">i32</span>]<span class="op">,</span> power<span class="op">:</span> <span class="dt">u32</span>) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    values</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>iter()</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>map(<span class="op">|</span>v<span class="op">|</span> v<span class="op">.</span>pow(power))</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>collect()</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> values <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> powers <span class="op">=</span> power_up(<span class="op">&amp;</span>values<span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{powers:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Sometimes some of the type information can be inferred, but not all
of it. In such cases, we can omit writing the whole type explicitly by
using the _ symbol for the inferrable part(s).</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> numbers <span class="op">=</span> [<span class="op">-</span><span class="dv">3i32</span><span class="op">,</span> <span class="op">-</span><span class="dv">2</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> absolutes <span class="op">=</span> numbers</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>into_iter()</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>map(<span class="dt">i32</span><span class="pp">::</span>abs)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span><span class="pp">collect::</span><span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>()<span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{absolutes:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In the example above, the iterator is collected to a Vec and the type
of the elements is inferred from the type of the iterator, which in turn
is inferred from the type of the array numbers.</p>
<hr />
<p>In case we need owned values, but into_iter returns references, we
can use the copied or cloned method (depending on the type) to get owned
copies of the values ‚Äî we could of course alternatively use map with a
function that calls to_owned() on its parameter.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> are_positive(numbers<span class="op">:</span> <span class="op">&amp;</span>[<span class="dt">i32</span>]) <span class="op">-&gt;</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    numbers</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>into_iter()</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>map(<span class="dt">i32</span><span class="pp">::</span>is_positive)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>collect()</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> numbers <span class="op">=</span> [<span class="op">-</span><span class="dv">2</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> numbers_positive <span class="op">=</span> are_positive(<span class="op">&amp;</span>numbers)<span class="op">;</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{numbers_positive:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Some other consuming methods than collect are for example the
for_each that works like for loop, nth to get the nth value, and count
that computes the amount of items in the iterator ‚Äî we used nth
previously to get the nth character in a string (in the ‚ÄúIndexing
strings?‚Äù info snippet in the slices section). Rust also provides
specialized consuming methods for numerical iterators, such as sum and
product.</p>
<p>The following example shows how we get an error if we try to use an
iterator after it has been consumed with count. To fix the example, we
can use iter() again to create a new iterator when one is needed.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>allow<span class="at">(</span>unused_mut<span class="at">)]</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> miles_to_kilometers(miles<span class="op">:</span> <span class="op">&amp;</span><span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  miles <span class="op">*</span> <span class="dv">1.609344</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> miles <span class="op">=</span> [<span class="dv">1.0f64</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">10.0</span><span class="op">,</span> <span class="dv">100.0</span>]<span class="op">;</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> miles_iter <span class="op">=</span> miles<span class="op">.</span>iter()<span class="op">;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> number_of_distances <span class="op">=</span> miles_iter<span class="op">.</span>count()<span class="op">;</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> total_kilometers <span class="op">=</span> miles_iter</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>map(miles_to_kilometers) <span class="co">// whoops?</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span><span class="pp">sum::</span><span class="op">&lt;</span><span class="dt">f64</span><span class="op">&gt;</span>()<span class="op">;</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{total_kilometers} kilometers in {number_of_distances} trips&quot;</span>)<span class="op">;</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The nth method does not consume the iterator fully, but only until
the nth value. This means that we can use the iterator again after
calling nth. We need to be careful though, as the iterator will continue
from where we left off.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> philosopher <span class="op">=</span> <span class="st">&quot;·ºàœÅŒπœÉœÑŒøœÑŒ≠ŒªŒ∑œÇ&quot;</span><span class="op">;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> chars <span class="op">=</span> philosopher<span class="op">.</span>chars()<span class="op">;</span> <span class="co">// chars() returns an iterator over the characters in a string</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> third <span class="op">=</span> chars</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>nth(<span class="dv">2</span>)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> number_of_chars <span class="op">=</span> chars<span class="op">.</span>count()<span class="op">;</span> <span class="co">// whoops, counts only the remaining chars</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;The length of {philosopher} is {}&quot;</span><span class="op">,</span> philosopher<span class="op">.</span>len())<span class="op">;</span> <span class="co">// number of bytes</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;The number of chars in {philosopher} is {number_of_chars}&quot;</span>)<span class="op">;</span> <span class="co">// number of chars</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;The third character of {philosopher} is {third}.&quot;</span>)<span class="op">;</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="iterating-one-at-a-time">Iterating one at a time</h3>
<p>All iterators have a method next which may or may not give back a
value. Let‚Äôs create an iterator to inspect an array using the next
method.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> arr <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>]<span class="op">;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> arr_iter <span class="op">=</span> arr<span class="op">.</span>iter()<span class="op">;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> one <span class="op">=</span> arr_iter<span class="op">.</span>next()<span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> two <span class="op">=</span> arr_iter<span class="op">.</span>next()<span class="op">;</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> three <span class="op">=</span> arr_iter<span class="op">.</span>next()<span class="op">;</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{one:?}, {two:?}, {three:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The next method yields values of type Option. After all, there might
not be a next value in the iterator. We can see this when calling next()
thrice for an array of size 2 in the above example.</p>
<p>Notice that we defined the arr_iter variable as mutable. This is
required even though the array itself doesn‚Äôt change ‚Äî the iterator does
change. The iterator ‚Äúkeeps getting smaller‚Äù each time we take the next
value from it. The next method immediately consumes a value from the
iterator, meaning that is is not lazy. The consuming iterator methods
like collect and nth work non-lazily, i.e.¬†eagerly, by calling next
repeatedly.</p>
<h2 id="closures">Closures</h2>
<p>Closures can be thought of as anonymous functions with concise
syntax. A closure is an expression which we can call like regular
functions. To create a closure, we write parameters inside pipes | and
follow them with the body of the closure.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="at">#![</span>allow<span class="at">(</span>unused<span class="at">)]</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> add <span class="op">=</span> <span class="op">|</span>a<span class="op">,</span> b<span class="op">|</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;1 + 1 = {}&quot;</span><span class="op">,</span> add(<span class="dv">1</span><span class="op">,</span> <span class="dv">1</span>))<span class="op">;</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The key difference to functions is that closures have access to
variables in the scope they are defined in. In other words, closure
capture their enclosing scope, hence closure. This gives closures a neat
advantage over ordinary functions. Notice how in the previous example we
didn‚Äôt have to specify the types of the parameters a and b or the return
type of the closure. The compiler is able infer the types from the
context and the body of the closure so we don‚Äôt have to specify them
explicitly.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span>  add   (a<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> b<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span> a <span class="op">+</span> b <span class="op">}</span> <span class="co">// Obligatory type annotations and braces</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add <span class="op">=</span> <span class="op">|</span>a<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> b<span class="op">:</span> <span class="dt">i32</span><span class="op">|</span> <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span> a <span class="op">+</span> b <span class="op">};</span> <span class="co">// Optional type annotations</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add <span class="op">=</span> <span class="op">|</span>a<span class="op">,</span> b<span class="op">|</span>                  <span class="op">{</span> a <span class="op">+</span> b <span class="op">};</span> <span class="co">// Optional braces</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> add <span class="op">=</span> <span class="op">|</span>a<span class="op">,</span> b<span class="op">|</span>                    a <span class="op">+</span> b  <span class="op">;</span></span></code></pre></div>
<p>Capturing the enclosing scope also means that we can use variables
from the enclosing scope in the body of the closure.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> base <span class="op">=</span> <span class="st">&quot;main&quot;</span><span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> with_file_extension <span class="op">=</span> <span class="op">|</span>extension<span class="op">|</span> <span class="op">{</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> base<span class="op">.</span>to_string()<span class="op">;</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>push_str(extension)<span class="op">;</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>        s</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> with_file_extension(<span class="st">&quot;.rs&quot;</span>))<span class="op">;</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> with_file_extension(<span class="st">&quot;.py&quot;</span>))<span class="op">;</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="closures-and-ownership">Closures and ownership</h3>
<p>When capturing variables in closures, we need take care to adhere to
Rust‚Äôs ownership rules like we do when defining and using variables.</p>
<p>A closure can capture variables in three ways: immutable borrow,
mutable borrow, or by move (take ownership). The compiler infers which
one to use based on the closure body. Imagine a function that decides
automatically whether it should take a mutable or immutable reference to
a variable based on the body of the function. That‚Äôs a closure for you.
It won‚Äôt solve all problem‚Äôs though.</p>
<p>In the example below, we double the value of variable i from the
enclosing scope in the body of the closure. It doesn‚Äôt compile however.
Check the compiler error message to see an error message about immutable
and mutable borrows that is familiar to what we saw when first looking
into ownership and borrowing.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> double_i <span class="op">=</span> <span class="op">||</span> i <span class="op">=</span> i <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// capture i by borrowing mutably</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    double_i()<span class="op">;</span> <span class="co">// use mutable borrow</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{i}&quot;</span>)<span class="op">;</span> <span class="co">// borrow immutably</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    double_i()<span class="op">;</span> <span class="co">// use mutable borrow again (not allowed)</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>As a comparison, what we did here with the closure is equivalent to
the following with just variables.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> j <span class="op">=</span> <span class="op">&amp;</span><span class="kw">mut</span> i<span class="op">;</span> <span class="co">// borrow i mutably</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>j <span class="op">=</span> <span class="op">*</span>j <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// use mutable borrow</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{i}&quot;</span>)<span class="op">;</span> <span class="co">// borrow i immutably</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>j <span class="op">=</span> <span class="op">*</span>j <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// use mutable borrow again (not allowed)</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note also that we needed the mut keyword for the closure to allow the
closure to modify the variable i from the enclosing scope. Like
variables, closures are immutable by default and won‚Äôt take mutable
references implicitly. We can also force a closure to take ownership
instead of borrowing with the move keyword. It is mostly used in
parallel computing with multiple execution threads so we won‚Äôt be
needing move for this course.</p>
<p>If the closure ownership handling feels like a lot to handle, no
worries! We‚Äôll mainly be using closures without capturing variables from
the enclosing scope, so there goes that problem</p>
<h3 id="iterator-methods-and-closures">Iterator methods and
closures</h3>
<p>Previously, we looked at an example, where degrees Celsius were
converted into degrees Fahrenheit using for_each. In the example, we had
to use a new version of the function that modified the floating point
numbers instead of returning the result of the computation. With
closures, we can still use the old non-mutating celsius_to_fahrenheit in
the call to for_each to mutate the values in a collection.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> celsius_to_fahrenheit(f<span class="op">:</span> <span class="dt">f64</span>) <span class="op">-&gt;</span> <span class="dt">f64</span> <span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>        f <span class="op">*</span> <span class="dv">9.0</span> <span class="op">/</span> <span class="dv">5.0</span> <span class="op">+</span> <span class="dv">32.0</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> temps <span class="op">=</span> [<span class="dv">1.0f64</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">10.0</span><span class="op">,</span> <span class="dv">100.0</span>]<span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    temps</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>iter_mut()</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>for_each(<span class="op">|</span>temp<span class="op">|</span> <span class="op">*</span>temp <span class="op">=</span> celsius_to_fahrenheit(<span class="op">*</span>temp))<span class="op">;</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{temps:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We haven‚Äôt used the for_each method before for printing, but always
resorted to the for loop. This is because the println! macro is not a
function, so we cannot pass it as an argument to for_each. However, we
can easily wrap the macro in a closure and pass it to for_each.</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> temps <span class="op">=</span> [<span class="dv">1.0f64</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">10.0</span><span class="op">,</span> <span class="dv">100.0</span>]<span class="op">;</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    temps</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>iter()</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>for_each(<span class="op">|</span>temp<span class="op">|</span> <span class="pp">println!</span>(<span class="st">&quot;{temp}‚ÑÉ&quot;</span>))<span class="op">;</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Likewise, we can use the map method together with a closure without
having to specify extra functions with parameter types and all.</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> miles <span class="op">=</span> [<span class="dv">1.0f64</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">10.0</span><span class="op">,</span> <span class="dv">100.0</span>]<span class="op">;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> kilometers <span class="op">=</span> miles<span class="op">.</span>iter()<span class="op">.</span>map(<span class="op">|</span>m<span class="op">|</span> m <span class="op">*</span> <span class="dv">1.609</span>)<span class="op">.</span><span class="pp">collect::</span><span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;&gt;</span>()<span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    miles</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>iter()</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>zip(kilometers<span class="op">.</span>iter())</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>for_each(<span class="op">|</span>(m<span class="op">,</span> k)<span class="op">|</span> <span class="pp">println!</span>(<span class="st">&quot;{m} miles equals {k} kilometers&quot;</span>))<span class="op">;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Here, we also used the zip method to iterate over two collections at
the same time. The zip adapter method takes in another iterator and
returns a new iterator that yields tuples of the values from the two
iterators</p>
<h3 id="filtering-and-finding">Filtering and finding</h3>
<p>Yet another useful iterator adaptor, filter, can be used effectively
in conjunction with closures. The filter method takes in a function that
returns true if the value should remain and false if it should be
skipped.</p>
<p>Let‚Äôs filter an array using a simple comparison predicate.</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> temps <span class="op">=</span> [<span class="dv">1.0f64</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">10.0</span><span class="op">,</span> <span class="dv">100.0</span>]<span class="op">;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> low_temps <span class="op">=</span> temps<span class="op">.</span>iter()<span class="op">.</span>filter(<span class="op">|</span>temp<span class="op">|</span> <span class="op">**</span>temp <span class="op">&lt;</span> <span class="dv">15.0</span>)<span class="op">;</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    low_temps<span class="op">.</span>for_each(<span class="op">|</span>low_temp<span class="op">|</span> <span class="op">{</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;It&#39;s {low_temp}¬∞C. So cold!&quot;</span>)<span class="op">;</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In the example above, the closure takes a double reference:
&amp;&amp;f64 so we need to dereference it twice with ** to get the
actual value. This is because, unlike the map adaptor, the filter
adaptor does not need ownership of the values it is filtering, in this
case the values have type &amp;f64. If filter took ownership of the
values, it would need to return them back too‚Ä¶</p>
<p>Let‚Äôs filter a map of country-population pairs next.</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::collections::</span>HashMap<span class="op">;</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> country_populations <span class="op">=</span> <span class="pp">HashMap::</span>from([</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;Finland&quot;</span><span class="op">,</span> <span class="dv">5_500_000</span>)<span class="op">,</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;Estonia&quot;</span><span class="op">,</span> <span class="dv">1_300_000</span>)<span class="op">,</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;Sweden&quot;</span><span class="op">,</span> <span class="dv">10_200_000</span>)<span class="op">,</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;Norway&quot;</span><span class="op">,</span> <span class="dv">5_300_000</span>)<span class="op">,</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;Denmark&quot;</span><span class="op">,</span> <span class="dv">5_800_000</span>)<span class="op">,</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;Iceland&quot;</span><span class="op">,</span> <span class="dv">400_000</span>)<span class="op">,</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>    ])<span class="op">;</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> over_5mil <span class="op">=</span> country_populations<span class="op">.</span>iter()</span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>filter(<span class="op">|</span>(_<span class="op">,</span> population)<span class="op">|</span> <span class="op">**</span>population <span class="op">&gt;=</span> <span class="dv">5_000_000</span>)<span class="op">;</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (country<span class="op">,</span> population) <span class="kw">in</span> over_5mil <span class="op">{</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{country} has population {population}&quot;</span>)<span class="op">;</span></span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Because the iterator yields tuples, we can conveniently destructure
them inside the pipes without needing to specify the types of the
components. The underscore variable _ is used to ignore the first unused
component of the tuple. The compiler warns about unused variables by
default, so we need to explicitly tell it to ignore the variable with
the underscore when we don‚Äôt want to see such warnings.</p>
<p>To find a value which matches a given predicate, we can use the find
method on an iterator.</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> sentence <span class="op">=</span> <span class="st">&quot;This is how we split strings by whitespace&quot;</span><span class="op">;</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> words <span class="op">=</span> sentence<span class="op">.</span>split_whitespace()<span class="op">;</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> three_letters <span class="op">=</span> words<span class="op">.</span>find(<span class="op">|</span>word<span class="op">|</span> word<span class="op">.</span>len() <span class="op">==</span> <span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">print!</span>(<span class="st">&quot;{three_letters:?}&quot;</span>)<span class="op">;</span> <span class="co">// Some(&quot;how&quot;)</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    words<span class="op">.</span>for_each(<span class="op">|</span>word<span class="op">|</span> <span class="pp">print!</span>(<span class="st">&quot; {word}&quot;</span>))<span class="op">;</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;!&quot;</span>)<span class="op">;</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The find method returns the first match, but the rest of the iterator
is left intact like with the nth method.</p>
<p>Remember that we could not remove from a vector directly by value but
only by index? Well, actually we can, but we need a function or a
closure. Vec has a retain method, which is very similar to the filter
method. It retains, i.e.¬†keeps, all the values from the vector that
match a given predicate. If we want to remove only a single value, we
can use Iterator‚Äôs position method to get the index of the first
matching value. Then remove with Vec‚Äôs remove based on the index.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> temps <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1.0f64</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">10.0</span><span class="op">,</span> <span class="dv">100.0</span>]<span class="op">;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    temps<span class="op">.</span>retain(<span class="op">|</span>temp<span class="op">|</span> <span class="op">*</span>temp <span class="op">&lt;</span> <span class="dv">15.0</span>)<span class="op">;</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{temps:?}&quot;</span>)<span class="op">;</span> <span class="co">// [1.0, 3.0, 10.0]</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">let</span> <span class="cn">Some</span>(index) <span class="op">=</span> temps</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>iter()</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>position(<span class="op">|</span>temp<span class="op">|</span> (<span class="op">*</span>temp <span class="op">-</span> <span class="dv">3.0</span>)<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dt">f64</span><span class="pp">::</span><span class="cn">EPSILON</span>)</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>        temps<span class="op">.</span>remove(index)<span class="op">;</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{temps:?}&quot;</span>)<span class="op">;</span> <span class="co">// [1.0, 10.0]</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<blockquote>
<p>Common iterators</p>
</blockquote>
<p>The Rust standard library provides us with plenty of other iterator
methods, for example reduce, fold, take_while, flatten, max_by_key. Here
are some examples of how to use them.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span>]<span class="op">;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Compute max value using reduce</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> max <span class="op">=</span> a<span class="op">.</span>iter()<span class="op">.</span>reduce(<span class="op">|</span>a<span class="op">,</span> b<span class="op">|</span> <span class="cf">if</span> a <span class="op">&gt;=</span> b <span class="op">{</span> a <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span> b <span class="op">}</span>)<span class="op">;</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(max<span class="op">,</span> <span class="cn">Some</span>(<span class="op">&amp;</span><span class="dv">5</span>))<span class="op">;</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Compute product using fold</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> product <span class="op">=</span> a<span class="op">.</span>iter()<span class="op">.</span>fold(<span class="dv">1</span><span class="op">,</span> <span class="op">|</span>accumulator<span class="op">,</span> a<span class="op">|</span> accumulator <span class="op">*</span> a)<span class="op">;</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(product<span class="op">,</span> <span class="dv">1</span> <span class="op">*</span> <span class="dv">5</span> <span class="op">*</span> <span class="dv">3</span> <span class="op">*</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Take all values until the first non-increasing value using take_while</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> prev <span class="op">=</span> <span class="dt">i32</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">;</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> increasing <span class="op">=</span> a</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>iter()</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>take_while(<span class="op">|</span>next<span class="op">|</span> <span class="op">{</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">**</span>next <span class="op">&gt;</span> prev <span class="op">{</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>                prev <span class="op">=</span> <span class="op">**</span>next<span class="op">;</span></span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>                <span class="cn">true</span> <span class="co">// keep taking</span></span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>                <span class="cn">false</span> <span class="co">// stop taking</span></span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span>)</span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span><span class="pp">collect::</span><span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;&amp;</span><span class="dt">i32</span><span class="op">&gt;&gt;</span>()<span class="op">;</span></span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(<span class="op">&amp;</span>increasing<span class="op">,</span> <span class="op">&amp;</span>[<span class="op">&amp;</span><span class="dv">1</span><span class="op">,</span> <span class="op">&amp;</span><span class="dv">5</span>])<span class="op">;</span></span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Flatten a vector of tuples using flatten</span></span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> flat <span class="op">=</span> a<span class="op">.</span>iter()<span class="op">.</span>map(<span class="op">|</span>num<span class="op">|</span> [<span class="op">*</span>num<span class="op">,</span> <span class="dv">0</span>])</span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>flatten()<span class="op">.</span><span class="pp">collect::</span><span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;&gt;</span>()<span class="op">;</span></span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(flat<span class="op">,</span> <span class="op">&amp;</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Find the longest word using max_by_key</span></span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> numbers <span class="op">=</span> [(<span class="dv">1</span><span class="op">,</span> <span class="st">&quot;one&quot;</span>)<span class="op">,</span> (<span class="dv">2</span><span class="op">,</span> <span class="st">&quot;two&quot;</span>)<span class="op">,</span> (<span class="dv">3</span><span class="op">,</span> <span class="st">&quot;three&quot;</span>)<span class="op">,</span> (<span class="dv">4</span><span class="op">,</span> <span class="st">&quot;four&quot;</span>)]<span class="op">;</span></span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> longest_number <span class="op">=</span> numbers<span class="op">.</span>iter()<span class="op">.</span>max_by_key(<span class="op">|</span>(_num<span class="op">,</span> word)<span class="op">|</span> word<span class="op">.</span>len())<span class="op">;</span></span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(longest_number<span class="op">,</span> <span class="cn">Some</span>(<span class="op">&amp;</span>(<span class="dv">3</span><span class="op">,</span> <span class="st">&quot;three&quot;</span>)))<span class="op">;</span></span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="enumerating-iterators">Enumerating iterators</h3>
<p>Sometimes we would like to access an element‚Äôs index in addition to
the element itself. Calling enumerate on an iterator returns a new
iterator which adds an incrementing counter to each item in the form of
a pair.</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a <span class="op">=</span> [<span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">,</span> <span class="st">&quot;c&quot;</span>]<span class="op">;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> e <span class="op">=</span> a<span class="op">.</span>iter()<span class="op">.</span>enumerate()<span class="op">;</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> e<span class="op">.</span>next())<span class="op">;</span> <span class="co">// Some((0, &quot;a&quot;))</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> e<span class="op">.</span>next())<span class="op">;</span> <span class="co">// Some((1, &quot;1&quot;))</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> e<span class="op">.</span>next())<span class="op">;</span> <span class="co">// Some((2, &quot;c&quot;))</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{:?}&quot;</span><span class="op">,</span> e<span class="op">.</span>next())<span class="op">;</span> <span class="co">// None</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Next, we‚Äôll use a for loop to iterate over the enumerated iterator
and print the indices and values stored in each pair.</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> a <span class="op">=</span> [<span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">,</span> <span class="st">&quot;c&quot;</span>]<span class="op">;</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i<span class="op">,</span> item) <span class="kw">in</span> a<span class="op">.</span>iter()<span class="op">.</span>enumerate() <span class="op">{</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{i} {item}&quot;</span>)<span class="op">;</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>For a slightly more practical example let‚Äôs use enumeration to split
a vector into two vectors pushing every other element to the same
vector.</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> split_adjacent(items<span class="op">:</span> <span class="op">&amp;</span><span class="dt">Vec</span><span class="op">&lt;&amp;</span><span class="dt">str</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> (<span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;,</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span>) <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> evens <span class="op">=</span> <span class="pp">vec!</span>[]<span class="op">;</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> odds <span class="op">=</span> <span class="pp">vec!</span>[]<span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i<span class="op">,</span> item) <span class="kw">in</span> items<span class="op">.</span>iter()<span class="op">.</span>enumerate() <span class="op">{</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>            evens<span class="op">.</span>push(item<span class="op">.</span>to_string())<span class="op">;</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>            odds<span class="op">.</span>push(item<span class="op">.</span>to_string())<span class="op">;</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>    (evens<span class="op">,</span> odds)</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> letters <span class="op">=</span> <span class="pp">vec!</span>[<span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">,</span> <span class="st">&quot;c&quot;</span><span class="op">,</span> <span class="st">&quot;d&quot;</span><span class="op">,</span> <span class="st">&quot;e&quot;</span><span class="op">,</span> <span class="st">&quot;f&quot;</span><span class="op">,</span> <span class="st">&quot;g&quot;</span>]<span class="op">;</span></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (evens<span class="op">,</span> odds) <span class="op">=</span> split_adjacent(<span class="op">&amp;</span>letters)<span class="op">;</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{evens:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{odds:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Here in split_adjacent function, instead of returning back
references, we push new Strings created from the given string slice
references to the corresponding vectors. If we wanted to directly push
the &amp;str references to the vectors (returning a pair of
Vec&lt;&amp;str&gt;), we would have to deal with the advanced concept of
generic lifetimes. We will cover that option later in the course.</p>
<p>When collecting the results of enumerated string references, we
cannot use the cloned method to get owned copies from the references.
This is because cloned works only on iterators that yield references but
the iterator yields tuples (usize, &amp;String), which are not
references but owned values (only the second value of the tuple is a
reference). Instead, we can clone the &amp;Strings inside the tuple with
the map method.</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> strings <span class="op">=</span> [<span class="st">&quot;a&quot;</span><span class="op">.</span>to_string()<span class="op">,</span> <span class="st">&quot;b&quot;</span><span class="op">.</span>to_string()<span class="op">,</span> <span class="st">&quot;c&quot;</span><span class="op">.</span>to_string()]<span class="op">;</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> enumerated<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>(<span class="dt">usize</span><span class="op">,</span> <span class="dt">String</span>)<span class="op">&gt;</span> <span class="op">=</span> strings</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>iter()</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>enumerate()</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>cloned()</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{enumerated:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this example, we could also opt to clone the string references
using cloned prior to enumerating with enumerate, or use into_iter to
iterate over owned values instead of references. However, such options
are not always available, e.g.¬†when working with collections or
iterators as function parameters.</p>
<hr />
</body>
</html>
