<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>conditionals_and_error_handling conditionals_and_error_handling</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://lerina.github.io/css/styles_min.css" />
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#conditionals-and-error-handling">Conditionals and Error Handling</a>
<ul>
<li><a href="#if-else-if-and-else">If, else if and else</a>
<ul>
<li><a href="#ifs-are-expressions">Ifs are expressions</a></li>
<li><a href="#ternary-operator">Ternary operator?</a></li>
<li><a href="#early-returning-with-guards">Early returning with guards</a></li>
<li><a href="#comparison-operators">Comparison operators</a></li>
<li><a href="#floating-point-comparasionwith-epsilon">Floating-point comparasionwith epsilon</a></li>
</ul></li>
<li><a href="#matching-patterns">Matching patterns</a>
<ul>
<li><a href="#match-guards">Match guards</a></li>
</ul></li>
<li><a href="#handling-errors">Handling errors</a>
<ul>
<li><a href="#by-panicking">by panicking</a></li>
<li><a href="#optional-values">Optional values</a></li>
<li><a href="#handling-null-values">Handling null values</a></li>
<li><a href="#none-and-its-type">None and its type</a></li>
<li><a href="#destructuring-options-and-if-let">Destructuring Options and if let</a></li>
<li><a href="#recoverable-errors">Recoverable errors</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 id="conditionals-and-error-handling">Conditionals and Error Handling</h1>
<p><a href="https://fitech101.aalto.fi/programming-languages/rust/5-conditionals-and-error-handling/">source</a></p>
<p>Control flow is the order in which the computer executes statements in a program. We have already manipulated control flow through calling functions — the computation flow of the program jumps into the called function instead of directly continuing on the next line of the code.</p>
<p>For more fine-grained control, we can use conditional statements such as if statements, which we’ll look at next</p>
<h2 id="if-else-if-and-else">If, else if and else</h2>
<p>We can use if, else if and else keywords combined with conditions to control the flow of execution, or in other words, to decide what to execute and when. The syntax is similar to many other languages such as C, Java and Python.</p>
<p>As an example, the following code snippet prints out the polarity of the integer x.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="kw">if</span> x <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;positive&quot;</span>)<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> x <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;negative&quot;</span>)<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;neutral&quot;</span>)<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    <span class="op">};</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>The condition operand (e.g. x &gt; 0 in the example) is the expression after the if keyword which determines whether to enter or skip the if block. The condition operand must evaluate to a boolean value, i.e. true or false. Numbers 1 and 0 do not equal true and false in Rust like in the C language.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    <span class="kw">if</span> x <span class="op">{</span> <span class="co">// error: expected `bool`, found integer</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;x is true!&quot;</span>)<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>    <span class="op">};</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Note also that the condition operand is not surrounded by parentheses, since they are not necessary in Rust unlike in many other languages. The compiler will even warn if we add unnecessary parentheses around the condition operand.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="kw">let</span> velocity <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="kw">if</span> (velocity <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">{</span> <span class="co">// warning: unnecessary parentheses around `if` condition</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;Moving forward!&quot;</span>)<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    <span class="op">};</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>On the other hand, the curly braces for the if block are mandatory and the if block must contain at least one statement, lest we face the wrath of the compiler.</p>
<h3 id="ifs-are-expressions">Ifs are expressions</h3>
<p>Similarly to code blocks, an if statement is an expression like any other expression in Rust. Leaving out semicolons from each branch causes the if expression to evaluate into the value. When the branches end in semicolons, the if expression evaluates to the unit value ().</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dt">i32</span><span class="pp">::</span><span class="cn">MIN</span><span class="op">;</span>  <span class="co">// minimum value of i32 integer</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    <span class="kw">let</span> polarity <span class="op">=</span> <span class="kw">if</span> x <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>        <span class="st">&quot;positive&quot;</span><span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> x <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>        <span class="st">&quot;negative&quot;</span><span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        <span class="st">&quot;neutral&quot;</span><span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    <span class="op">};</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{x} is {polarity}&quot;</span>)<span class="op">;</span> <span class="co">// ()</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>By leaving out the semicolon from an if expression, we can return the value of the if expression as a value from a function just like any other value.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">fn</span> polarity(number<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span class="kw">if</span> number <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>        <span class="st">&quot;positive&quot;</span><span class="op">.</span>to_string()</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="kw">if</span> number <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>        <span class="st">&quot;negative&quot;</span><span class="op">.</span>to_string()</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>        <span class="st">&quot;neutral&quot;</span><span class="op">.</span>to_string()</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    <span class="op">};</span> <span class="co">// error: expected `String`, found `()`</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dt">i32</span><span class="pp">::</span><span class="cn">MAX</span><span class="op">;</span>  <span class="co">// minimum value of i32 integer</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>    <span class="kw">let</span> polarity <span class="op">=</span> polarity(x)<span class="op">;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{x} is {polarity}&quot;</span>)<span class="op">;</span>   <span class="co">// negative</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="ternary-operator">Ternary operator?</h3>
<p>A conditional ternary operator is a common feature in many programming languages that allows concise syntax for simple if-else expressions. Most commonly (for instance in C, JavaScript and Dart) the ternary operator is represented by a question mark (?) for the true condition and a colon (:) for the false condition. For example in C we could do the following.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="dt">int</span> main() {</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>  <span class="dt">int</span> age = <span class="dv">18</span>;</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>  <span class="dt">bool</span> canVote = (age &gt;= <span class="dv">18</span>) ? true : false;</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>  printf(<span class="st">&quot;Can vote: %s&quot;</span>, canVote ? <span class="st">&quot;true&quot;</span> : <span class="st">&quot;false&quot;</span>);</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>}</span></code></pre></div>
<p>Rust does not need such a ternary operator, since the if statements in Rust are expressions, we can achieve the same result almost as easily (but more expressively).</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    <span class="kw">let</span> age <span class="op">=</span> <span class="dv">18</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="kw">let</span> can_vote <span class="op">=</span> <span class="kw">if</span> age <span class="op">&gt;=</span> <span class="dv">18</span> <span class="op">{</span> <span class="cn">true</span> <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span> <span class="cn">false</span> <span class="op">};</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;Can vote: {can_vote}&quot;</span>)<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<hr />
<p>When if is used as an expression, all cases must be covered by the branches and the branches must evaluate to the same type (unless returning early, e.g. with the return keyword). Otherwise, the compiler will complain.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">fn</span> is_small(text<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  <span class="kw">let</span> length <span class="op">=</span> <span class="kw">if</span> text <span class="op">==</span> <span class="st">&quot;small&quot;</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="cn">true</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    text<span class="op">.</span>len()</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  <span class="op">};</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>  length <span class="op">&lt;</span> <span class="dv">5</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> is_small(<span class="st">&quot;small&quot;</span>))<span class="op">;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> is_small(<span class="st">&quot;smol&quot;</span>))<span class="op">;</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>  <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> is_small(<span class="st">&quot;smoll&quot;</span>))<span class="op">;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="early-returning-with-guards">Early returning with guards</h3>
<p>We can use the return keyword to return a value from a function early. The value after return will be the value of the function call and the function will exit immediately.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">fn</span> early_return() <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span class="kw">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    <span class="dv">2</span> <span class="co">// warning: unreachable expression</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> early_return())<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>In more complex code, returning early with guards can be a good way to keep the control flow readable by avoiding deeply nested blocks.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">fn</span> get_price(in_stock<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> price_per_kg<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> kg<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    <span class="kw">if</span> in_stock <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>        <span class="kw">if</span> price_per_kg <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>            <span class="kw">if</span> in_stock <span class="op">&gt;=</span> kg <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>                price_per_kg <span class="op">*</span> kg</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>            <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>                <span class="op">-</span><span class="dv">1</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>            <span class="op">}</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>        <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>            <span class="op">-</span><span class="dv">1</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>        <span class="op">-</span><span class="dv">1</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> get_price(<span class="dv">10</span><span class="op">,</span> <span class="dv">15</span><span class="op">,</span> <span class="dv">0</span>))<span class="op">;</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>The convention in Rust is to not use return keyword when same behavior is achieved by removing the semicolon from the lines that return a value.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">fn</span> collatz(a<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>    <span class="kw">if</span> a <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>        <span class="kw">return</span> a <span class="op">/</span> <span class="dv">2</span><span class="op">;</span>     <span class="co">// Clippy warning: unneeded return statement</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>        <span class="kw">return</span> <span class="dv">3</span> <span class="op">*</span> a <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Clippy warning: unneeded return statement</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> collatz(<span class="dv">15</span>))<span class="op">;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>By running the Rust linter Clippy with cargo clippy for the above code, we get a code style suggestion to remove the unnecessary return keywords.</p>
<p>After modifying the code as Clippy suggests, it will still behave in the exact same way.</p>
<p>Clippy will not suggest removing the return keyword when doing so would change the behavior of the program, such as when using early returns.</p>
<hr />
<h3 id="comparison-operators">Comparison operators</h3>
<p>An if statement need to be paired with a boolean expression (an expression that evaluates to either true or false) after the if keyword. We can write boolean expressions using comparison operators like we did in the previous examples.</p>
<p>The following table lists the comparison operators available in Rust.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Operator</th>
<th style="text-align: center;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">==</td>
<td style="text-align: center;">equals</td>
</tr>
<tr class="even">
<td style="text-align: left;">!=</td>
<td style="text-align: center;">not equals</td>
</tr>
<tr class="odd">
<td style="text-align: left;">&lt;</td>
<td style="text-align: center;">less than</td>
</tr>
<tr class="even">
<td style="text-align: left;">&gt;</td>
<td style="text-align: center;">greater than</td>
</tr>
<tr class="odd">
<td style="text-align: left;">&lt;=</td>
<td style="text-align: center;">less than or equals</td>
</tr>
<tr class="even">
<td style="text-align: left;">&gt;=</td>
<td style="text-align: center;">greater than or equals</td>
</tr>
</tbody>
</table>
<p>The logical operators ! (negation), &amp;&amp; (and) and || (or) may be applied to boolean expressions. The result will also be a boolean and thus valid for use in an if statement.</p>
<table>
<thead>
<tr class="header">
<th>Operator</th>
<th style="text-align: right;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>!</td>
<td style="text-align: right;">negation</td>
</tr>
<tr class="even">
<td>&amp;&amp;</td>
<td style="text-align: right;">and</td>
</tr>
<tr class="odd">
<td>||</td>
<td style="text-align: right;">or</td>
</tr>
</tbody>
</table>
<p>As an example, we can use the logical and operator (&amp;&amp;) to reduce the number nesting levels.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">fn</span> get_price(in_stock<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> price_per_kg<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> kg<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>    <span class="kw">if</span> in_stock <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>        <span class="kw">if</span> price_per_kg <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>            <span class="kw">if</span> in_stock <span class="op">&gt;=</span> kg <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>                price_per_kg <span class="op">*</span> kg</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>            <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>                <span class="op">-</span><span class="dv">1</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>            <span class="op">}</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>        <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>            <span class="op">-</span><span class="dv">1</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>        <span class="op">}</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a>        <span class="op">-</span><span class="dv">1</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> get_price(<span class="dv">10</span><span class="op">,</span> <span class="dv">15</span><span class="op">,</span> <span class="dv">0</span>))<span class="op">;</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="floating-point-comparasionwith-epsilon">Floating-point comparasionwith epsilon</h3>
<p>Integer comparison works like we are used to and have already seen.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="dv">5</span> <span class="op">&lt;</span> <span class="dv">6</span>)<span class="op">;</span>      <span class="co">// true</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="dv">6</span> <span class="op">&lt;=</span> <span class="dv">6</span>)<span class="op">;</span>     <span class="co">// true</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span> <span class="op">==</span> <span class="dv">3</span>)<span class="op">;</span> <span class="co">// false</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Floating point comparison on the other hand might not work as we expect due to the way floating point numbers are encoded in bytes — floating point encoding is not a topic for this course but more info can be found here.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="dv">3.0</span> <span class="op">*</span> <span class="dv">0.15</span> <span class="op">==</span> <span class="dv">0.45</span>)<span class="op">;</span> <span class="co">// false</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="dv">3.0</span> <span class="op">*</span> <span class="dv">0.15</span> <span class="op">&lt;</span> <span class="dv">0.45</span>)<span class="op">;</span>  <span class="co">// true</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{} &lt; {}&quot;</span><span class="op">,</span> <span class="dv">3.0</span> <span class="op">*</span> <span class="dv">0.15</span><span class="op">,</span> <span class="dv">0.45</span>)<span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>The important thing to notice here is that floating point calculations are <strong>not always exact</strong>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> <span class="dv">0.09</span> <span class="op">+</span> <span class="dv">0.01</span>) <span class="co">// 0.0999...</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>For more reliable floating point comparison, we can use an error margin suitable for our purposes and see if the values are within the margin’s radius of each other. Rust provides a handy constant EPSILON that can be used as a baseline error margin.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>    <span class="kw">let</span> a <span class="op">=</span> <span class="dv">3.0</span> <span class="op">*</span> <span class="dv">0.15</span><span class="op">;</span> <span class="co">// type gets inferred as f64 from b</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    <span class="kw">let</span> b <span class="op">=</span> <span class="dv">0.45f64</span><span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{a} == {b} ± {}&quot;</span><span class="op">,</span> <span class="dt">f64</span><span class="pp">::</span><span class="cn">EPSILON</span>)<span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> (a <span class="op">-</span> b)<span class="op">.</span>abs() <span class="op">&lt;</span> <span class="dt">f64</span><span class="pp">::</span><span class="cn">EPSILON</span>)<span class="op">;</span> <span class="co">// (a - b).abs() evaluates to the absolute difference of the two values</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h2 id="matching-patterns">Matching patterns</h2>
<p>Besides the if expression for conditional control flow, Rust has a match expression that is based on pattern matching. The simplest pattern is a literal value, like the boolean value true. Matches are always exhaustive, meaning that all possible values of the type must be covered by the patterns.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>    <span class="kw">let</span> fact <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>    <span class="kw">match</span> fact <span class="op">{</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>        <span class="cn">true</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;fact&quot;</span>)<span class="op">,</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>        <span class="cn">false</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;not fact&quot;</span>)<span class="op">,</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>    <span class="op">};</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>The match syntax consists of the match keyword, a scrutinee expression, and match arms. The value of the scrutinee expression is compared to patterns in the arms, which are enclosed in braces {}. Each arm has a pattern, followed by a fat arrow =&gt; and a target expression. Like with if and else if conditions, the matching is done from top to bottom, and the first matching arm of the expression is evaluated.</p>
<p>The match expression in Rust is a lot like the switch statement you may have come across in other programming languages, but more functional and powerful as it is an expression and supports pattern matching.</p>
<p>As stated earlier, all values of the type must be covered by the patterns. For booleans it is enough for the patterns to cover the two values true and false. For integers, we need to match the full range an integer can take. We can achieve this by using range patterns with the .. operator. The pattern ..a matches all numbers from minimum (e.g. i32::MIN for i32) to a, a.. from a to maximum, and a..=b from a to b (inclusive range).</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>    <span class="kw">let</span> number <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>    <span class="kw">let</span> polarity <span class="op">=</span> <span class="kw">match</span> number <span class="op">{</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>        <span class="op">..=-</span><span class="dv">1</span> <span class="op">=&gt;</span> <span class="st">&quot;negative!&quot;</span><span class="op">,</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>        <span class="dv">0</span> <span class="op">=&gt;</span> <span class="st">&quot;neutral!&quot;</span><span class="op">,</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>        <span class="dv">1</span><span class="op">..=</span><span class="dt">i32</span><span class="pp">::</span><span class="cn">MAX</span> <span class="op">=&gt;</span> <span class="st">&quot;positive!&quot;</span><span class="op">,</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>    <span class="op">};</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{polarity}&quot;</span>)<span class="op">;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>We can use a variable name as the pattern in the final arm in case we don’t want to explicitly match all possible values (or it is impossible, like when working with values such as strings that can take an arbitrary number of values). Using a variable as a pattern will match any value and bind it to the variable name.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>    <span class="kw">let</span> number <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>    <span class="kw">match</span> number <span class="op">{</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>        <span class="dv">1</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;One!&quot;</span>)<span class="op">,</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>        <span class="dv">2</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Two!&quot;</span>)<span class="op">,</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>        <span class="dv">3</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Three!&quot;</span>)<span class="op">,</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>        n <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;{n} is not one, two or three!&quot;</span>)<span class="op">,</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>This leaves us a redundant variable though, since we might as well use the scrutinee instead of the new variable as in the above example. Also, in many cases we don’t need to do anything with the value that matched the pattern, but the compiler will warn us about any unused variables, as it should.</p>
<p>To get rid of the warning, we can use the underscore _ wildcard pattern. Like a variable name, this pattern will match any value but also ignore the value, thus keeping us safe from unused variable warnings.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="kw">fn</span> roman_numeral(num<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>    <span class="kw">match</span> num <span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>        <span class="dv">1</span><span class="op">..=</span><span class="dv">3</span> <span class="op">=&gt;</span> <span class="st">&quot;I&quot;</span><span class="op">.</span>repeat(num)<span class="op">,</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>        <span class="dv">4</span> <span class="op">|</span> <span class="dv">9</span> <span class="op">=&gt;</span> <span class="st">&quot;I&quot;</span><span class="op">.</span>to_string() <span class="op">+</span> <span class="op">&amp;</span>roman_numeral(num <span class="op">+</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>        <span class="dv">5</span><span class="op">..=</span><span class="dv">8</span> <span class="op">=&gt;</span> <span class="st">&quot;V&quot;</span><span class="op">.</span>to_string() <span class="op">+</span> <span class="op">&amp;</span>roman_numeral(num <span class="op">-</span> <span class="dv">5</span>)<span class="op">,</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>        <span class="dv">10</span><span class="op">..=</span><span class="dv">39</span> <span class="op">=&gt;</span> <span class="st">&quot;X&quot;</span><span class="op">.</span>to_string() <span class="op">+</span> <span class="op">&amp;</span>roman_numeral(num <span class="op">-</span> <span class="dv">10</span>)<span class="op">,</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>        _ <span class="op">=&gt;</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">,</span> <span class="co">// underscore is like else with if</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>    <span class="pp">println!</span>(</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>        <span class="st">&quot;{} + {} = {}&quot;</span><span class="op">,</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a>        roman_numeral(<span class="dv">14</span>)<span class="op">,</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>        roman_numeral(<span class="dv">19</span>)<span class="op">,</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a>        roman_numeral(<span class="dv">14</span> <span class="op">+</span> <span class="dv">19</span>)</span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a>    )<span class="op">;</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>The above example also shows how to combine patterns into one with |.</p>
<p>Match target expressions (which come after the =&gt;) work the same as branches in an if expression. The expressions can be any expression as long as they evaluate to a value of the correct type or return early from the function.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="kw">fn</span> is_big(text<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>    <span class="kw">let</span> len <span class="op">=</span> <span class="kw">match</span> text <span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>        <span class="st">&quot;big&quot;</span> <span class="op">=&gt;</span> <span class="kw">return</span> <span class="cn">true</span><span class="op">,</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>        text <span class="op">=&gt;</span> <span class="op">{</span> </span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>          <span class="kw">let</span> trimmed <span class="op">=</span> text<span class="op">.</span>trim()<span class="op">;</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>          trimmed<span class="op">.</span>len()</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>        <span class="op">},</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>    <span class="op">};</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>    len <span class="op">&gt;</span> <span class="dv">10</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> is_big(<span class="st">&quot;big&quot;</span>))<span class="op">;</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> is_big(<span class="st">&quot;small&quot;</span>))<span class="op">;</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> is_big(<span class="st">&quot;a very long text&quot;</span>))<span class="op">;</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<h3 id="match-guards">Match guards</h3>
<p>We can use match guards to add conditions for when to match arm patterns. A match guard is defined by adding an if keyword and a condition after the pattern in a match arm.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>    <span class="kw">let</span> polarity <span class="op">=</span> <span class="kw">match</span> x <span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>        <span class="dv">0</span> <span class="op">=&gt;</span> <span class="st">&quot;neutral&quot;</span><span class="op">,</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>        _ <span class="kw">if</span> x <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">=&gt;</span> <span class="st">&quot;positive&quot;</span><span class="op">,</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>        _ <span class="kw">if</span> x <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">=&gt;</span> <span class="st">&quot;negative&quot;</span><span class="op">,</span> <span class="co">// problem?</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>    <span class="op">};</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{polarity}&quot;</span>)<span class="op">;</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>The condition is evaluated after the pattern is matched, and the arm is only evaluated if the condition is true. The compiler isn’t however capable of determining whether a collection of guards cover all the possible cases of a pattern. To fix the above example, we can remove the final guard to have the wildcard _ capture all the remaining possible values.</p>
<h2 id="handling-errors">Handling errors</h2>
<h3 id="by-panicking">by panicking</h3>
<p>Errors are bound to happen in real-world programs and they need to be handled accordingly. Rust has a few mechanisms to handle errors, and one of them is panicking — panicking is the technical term used for crashing and stopping the execution of a Rust program.</p>
<p>A Rust program can panic in two ways, either by an action that leads to panic, such as integer division by zero, or by explicitly calling Rust’s panic! macro.</p>
<p>The panic! macro is used to indicate that something went wrong and the program will not continue. It takes a format string as its argument like the print and println macros, and the argument is printed as the error message when the program halts.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;What is the airspeed velocity of an unladen swallow?&quot;</span>)<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;What do you mean, an African or European swallow?&quot;</span>)<span class="op">;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>    <span class="pp">panic!</span>(<span class="st">&quot;I don&#39;t know that!&quot;</span>)<span class="op">;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>As a more practical example, consider a program responsible for handling the state of a drink machine that can only hold 50 drinks in total at a time. If the program states that the machine has more drinks than it can physically hold, it should panic and show an error message.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">fn</span> get_drink_count() <span class="op">-&gt;</span> <span class="dt">u8</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>    <span class="dv">51</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>    <span class="kw">let</span> drinks <span class="op">=</span> get_drink_count()<span class="op">;</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>    <span class="kw">if</span> drinks <span class="op">&gt;</span> <span class="dv">50</span> <span class="op">{</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>        <span class="pp">panic!</span>(<span class="st">&quot;Not possible to have {drinks} drinks, invalid state!&quot;</span>)<span class="op">;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<h3 id="optional-values">Optional values</h3>
<p>Many programming languages incorporate a special value called null to represent the absence of a value. Consider for example the previous example function that matched integers to their respective Roman numerals and returned an empty string when given an unsupported number. Assuming that we don’t want to panic instead of returning a value, the function behavior would be clearer if in such a case it would return an empty (null) value (an empty string is not an empty value).</p>
<p>Rust does not allow a value of a variable to be empty or null. Instead the possible absence of a value is represented by the Option type</p>
<h4 id="the-option-type">The Option type</h4>
<p>The Option type is an enum with two variants: Some and None. The Some variant indicates that the value is present, while the None variant indicates that the value is absent.</p>
<p>Using the Option for null values is Rust’s way of making the presence of null values explicit in the code. This allows null errors to be easily identified during compilation so that they can be quickly found and fixed before running the program.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="kw">pub</span> <span class="kw">fn</span> roman_numeral(num<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>    <span class="kw">match</span> num <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>        <span class="dv">1</span><span class="op">..=</span><span class="dv">3</span> <span class="op">=&gt;</span> <span class="st">&quot;I&quot;</span><span class="op">.</span>repeat(num)<span class="op">,</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>        <span class="dv">4</span> <span class="op">|</span> <span class="dv">9</span> <span class="op">=&gt;</span> <span class="st">&quot;I&quot;</span><span class="op">.</span>to_string() <span class="op">+</span> <span class="op">&amp;</span>roman_numeral(num <span class="op">+</span> <span class="dv">1</span>)<span class="op">,</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>        <span class="dv">5</span> <span class="op">=&gt;</span> <span class="st">&quot;V&quot;</span><span class="op">.</span>to_string()<span class="op">,</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>        <span class="dv">6</span><span class="op">..=</span><span class="dv">8</span> <span class="op">=&gt;</span> <span class="st">&quot;V&quot;</span><span class="op">.</span>to_string() <span class="op">+</span> <span class="op">&amp;</span>roman_numeral(num <span class="op">-</span> <span class="dv">5</span>)<span class="op">,</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>        <span class="dv">10</span> <span class="op">=&gt;</span> <span class="st">&quot;X&quot;</span><span class="op">.</span>to_string()<span class="op">,</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a>        <span class="dv">10</span><span class="op">..=</span><span class="dv">39</span> <span class="op">=&gt;</span> <span class="st">&quot;X&quot;</span><span class="op">.</span>to_string() <span class="op">+</span> <span class="op">&amp;</span>roman_numeral(num <span class="op">-</span> <span class="dv">10</span>)<span class="op">,</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true"></a>        _ <span class="op">=&gt;</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">,</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> roman_numeral(<span class="dv">24</span>))<span class="op">;</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> roman_numeral(<span class="dv">0</span>))<span class="op">;</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>With the Option type, the previous Roman numeral example can be rewritten as</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="kw">fn</span> roman_numeral(num<span class="op">:</span> <span class="dt">usize</span>) <span class="op">-&gt;</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>    <span class="kw">match</span> num <span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>        <span class="dv">1</span><span class="op">..=</span><span class="dv">3</span> <span class="op">=&gt;</span> <span class="cn">Some</span>(<span class="st">&quot;I&quot;</span><span class="op">.</span>repeat(num))<span class="op">,</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>        <span class="dv">4</span> <span class="op">|</span> <span class="dv">9</span> <span class="op">=&gt;</span> <span class="cn">Some</span>(<span class="st">&quot;I&quot;</span><span class="op">.</span>to_string() <span class="op">+</span> <span class="op">&amp;</span>roman_numeral(num <span class="op">+</span> <span class="dv">1</span>)<span class="op">.</span>unwrap_or_default())<span class="op">,</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>        <span class="dv">5</span><span class="op">..=</span><span class="dv">8</span> <span class="op">=&gt;</span> <span class="cn">Some</span>(<span class="st">&quot;V&quot;</span><span class="op">.</span>to_string() <span class="op">+</span> <span class="op">&amp;</span>roman_numeral(num <span class="op">-</span> <span class="dv">5</span>)<span class="op">.</span>unwrap_or_default())<span class="op">,</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>        <span class="dv">10</span><span class="op">..=</span><span class="dv">39</span> <span class="op">=&gt;</span> <span class="cn">Some</span>(<span class="st">&quot;X&quot;</span><span class="op">.</span>to_string() <span class="op">+</span> <span class="op">&amp;</span>roman_numeral(num <span class="op">-</span> <span class="dv">10</span>)<span class="op">.</span>unwrap_or_default())<span class="op">,</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>        _ <span class="op">=&gt;</span> <span class="cn">None</span><span class="op">,</span> </span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a>    <span class="pp">println!</span>(</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a>        <span class="st">&quot;{} + {} = {}&quot;</span><span class="op">,</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a>        roman_numeral(<span class="dv">14</span>)<span class="op">.</span>unwrap()<span class="op">,</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a>        roman_numeral(<span class="dv">19</span>)<span class="op">.</span>unwrap()<span class="op">,</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a>        roman_numeral(<span class="dv">14</span> <span class="op">+</span> <span class="dv">19</span>)<span class="op">.</span>unwrap()</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a>    )<span class="op">;</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>This makes it clear that the function can return a null value, and the caller of the function knows that the null value needs to be handled appropriately. In the example function, the null values are handled using the unwrap_or_default() method, which returns a default value for the given type — an empty string for a String in the example’s case.</p>
<p>The inner type of Option is generic, so Option can be used with any type. The inner type of the option needs to be included in Option’s type signature with angle brackets &lt;&gt;, like Option<String> in the above example.</p>
<h4 id="printing-an-option-and-debug-formatting">Printing an Option and debug formatting</h4>
<p>Some types in Rust cannot be printed out normally, but support debug formatting which is commonly used for printing more information about the value. Option is one such type.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>    <span class="kw">let</span> maybe_x<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="cn">Some</span>(<span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{maybe_x}&quot;</span>)<span class="op">;</span> <span class="co">// cannot be formatted with the default formatter</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>To print out such values, the debug formatting parameter ? can be used in the format string of the print(ln)! macros using {:?} instead of just the braces {}.</p>
<p>As a side note, printing a String with {:?} will allow us to see the more clearly if the string is empty.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>    <span class="kw">let</span> empty_string <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{empty_string:?}&quot;</span>)<span class="op">;</span> <span class="co">// &quot;&quot;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<hr />
<blockquote>
<p>dbg!() macro</p>
</blockquote>
<p>Sometimes we want to debug what’s happening. Writing println!(“{variable:?}”) every time is quite inconvenient — luckily Rust has a convenient macro for doing the same thing: dbg!.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="cn">Some</span>(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>    <span class="pp">dbg!</span>(x)<span class="op">;</span> <span class="co">// [src/main.rs:3] x = Some(1)</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a>    <span class="kw">let</span> y <span class="op">=</span> <span class="pp">dbg!</span>(x<span class="op">.</span>unwrap()) <span class="op">+</span> <span class="dv">6</span><span class="op">;</span> <span class="co">// x.unwrap() = 1</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a>    <span class="pp">dbg!</span>(y)<span class="op">;</span> <span class="co">// y = 7</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Not only does the dbg! macro print the filename, line number and debugged expression, it also returns the argument so that we can debug parts of expressions without having to extract them to a variable! Similar to the print macros is the format! macro that writes formatted text to a string. The format! macro is especially useful for concatenating strings and data types.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="cn">Some</span>(<span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>    <span class="kw">let</span> variable <span class="op">=</span> <span class="st">&quot;x&quot;</span><span class="op">;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>    <span class="kw">let</span> s <span class="op">=</span> <span class="pp">format!</span>(<span class="st">&quot;{} is {:?}&quot;</span><span class="op">,</span> variable<span class="op">,</span> x)<span class="op">;</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{s}&quot;</span>)<span class="op">;</span>  <span class="co">// x is Some(1)</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h3 id="handling-null-values">Handling null values</h3>
<p>A simple way to handle null errors is by explicitly causing the program to crash if the value is None. This can be done by unwrapping the Option using the method unwrap().</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>    <span class="kw">let</span> <span class="kw">mut</span> maybe3 <span class="op">=</span> <span class="cn">Some</span>(<span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a>    <span class="kw">let</span> three<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> maybe3<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{three}&quot;</span>)<span class="op">;</span> <span class="co">// 3</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a>    maybe3 <span class="op">=</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> maybe3<span class="op">.</span>unwrap())<span class="op">;</span> <span class="co">// panic, called unwrap() on a None value</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>When we want to avoid crashing, a common way to handle null values is to define a default value in case the Option is None — like in the Roman numerals example with the unwrap_or_default(), which returns a default value based on the Options inner type.</p>
<p>We can also provide a custom default value with the unwrap_or method.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>    <span class="kw">let</span> <span class="kw">mut</span> maybe_a_value <span class="op">=</span> <span class="cn">Some</span>(<span class="st">&quot;value&quot;</span>)<span class="op">;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> maybe_a_value<span class="op">.</span>unwrap_or(<span class="st">&quot;null&quot;</span>))<span class="op">;</span> <span class="co">// value</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>    maybe_a_value <span class="op">=</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> maybe_a_value<span class="op">.</span>unwrap_or(<span class="st">&quot;null&quot;</span>))<span class="op">;</span> <span class="co">// null</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Another useful method is expect, which causes panic like unwrap, but also allows us to specify a custom error message to be shown after the panic.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>    <span class="kw">let</span> bob<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> <span class="op">=</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> bob<span class="op">.</span>expect(<span class="st">&quot;bob does not have a value&quot;</span>))<span class="op">;</span> <span class="co">// thread &#39;main&#39; panicked at &#39;bob does not have a value&#39;</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<h3 id="none-and-its-type">None and its type</h3>
<p>While floating point values require explicit type information for certain operations, there are also cases where simply defining a variable is not allowed without explicit typing. For instance, if we try to assign None (a “null” value) to a variable, the compiler would not allow it, because it cannot infer the type of the None value nor the type of the variable.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="at">#![</span>allow<span class="at">(</span>unused<span class="at">)]</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="cn">None</span><span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Rust is able to hint that None is of type Option<T>, but it also needs to know what it is an option of — that’s the <T> part in the type. To fix the error, we need to define the data type of the variable in the code (to see the solution, press the red icon). In the solution, None was arbitrarily chosen to be an Option of i32.</p>
<h3 id="destructuring-options-and-if-let">Destructuring Options and if let</h3>
<p>Patterns can be used to destructure complex values such as enums. This enables capturing the possible inner value of an Option in a match arm with concise syntax.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>    <span class="kw">let</span> perhaps_a_value <span class="op">=</span> <span class="cn">Some</span>(<span class="st">&quot;to be or not be&quot;</span>)<span class="op">;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>    <span class="kw">match</span> perhaps_a_value <span class="op">{</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a>        <span class="cn">Some</span>(value) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;The value is {value}&quot;</span>)<span class="op">,</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a>        <span class="cn">None</span> <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;There is no value&quot;</span>)<span class="op">,</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>However, one does not simply assign a variable to the Some variant of an Option because the None case would not be covered.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>    <span class="kw">let</span> perhaps_destination <span class="op">=</span> <span class="cn">Some</span>(<span class="st">&quot;Mordor&quot;</span>)<span class="op">;</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>    <span class="kw">let</span> <span class="cn">Some</span>(destination) <span class="op">=</span> perhaps_destination<span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{destination}&quot;</span>)<span class="op">;</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>There can be times when we are only interested in a single pattern and want to ignore the rest. This can make using match cumbersome since it forces us to handle each possible case. Instead, we might resort to the if statement to check whether the value is Some or None and then use the unwrap method to get the value out of the Some variant.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>    <span class="kw">let</span> perhaps_a_value <span class="op">=</span> <span class="cn">Some</span>(<span class="st">&quot;to be or not to be&quot;</span>)<span class="op">;</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a>    <span class="kw">if</span> perhaps_a_value<span class="op">.</span>is_some() <span class="op">{</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a>        <span class="kw">let</span> value <span class="op">=</span> perhaps_a_value<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;The value is {value}&quot;</span>)<span class="op">;</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>To make things easier, Rust provides the if let expression. Using the if let syntax we can refactor the code into.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>    <span class="kw">let</span> perhaps_a_value <span class="op">=</span> <span class="cn">Some</span>(<span class="st">&quot;to be or not to be&quot;</span>)<span class="op">;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>    <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(value) <span class="op">=</span> perhaps_a_value <span class="op">{</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;The value is {value}&quot;</span>)<span class="op">;</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>The if let syntax takes the form if let $pattern = $expression. If the lefthand pattern matches the righthand expression, Rust can safely unwrap the expression some_value into value. The same logic works for all enums in Rust.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a>    <span class="kw">let</span> some_text <span class="op">=</span> <span class="cn">Some</span>(<span class="st">&quot;text&quot;</span>)<span class="op">;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true"></a>    <span class="kw">if</span> <span class="kw">let</span> <span class="cn">None</span> <span class="op">=</span> some_text <span class="op">{</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;The value is None&quot;</span>)<span class="op">;</span> <span class="co">// no match, no execution</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true"></a></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true"></a>    <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(<span class="st">&quot;other&quot;</span>) <span class="op">=</span> some_text <span class="op">{</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;The value is other&quot;</span>)<span class="op">;</span> <span class="co">// no match, no execution</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true"></a></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true"></a>    <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(<span class="st">&quot;text&quot;</span>) <span class="op">=</span> some_text <span class="op">{</span></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;The value is text&quot;</span>)<span class="op">;</span> <span class="co">// match, therefore execution</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true"></a>    <span class="kw">else</span> <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(value) <span class="op">=</span> some_text <span class="op">{</span></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;The value is {value}&quot;</span>)<span class="op">;</span> <span class="co">// match on previous branch, no execution</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Note that if let requires the lefthand and righthand sides to be the same type.</strong></p>
<div class="sourceCode" id="cb40"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a>    <span class="kw">let</span> some_money <span class="op">=</span> <span class="st">&quot;💰&quot;</span><span class="op">;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a>    <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(money) <span class="op">=</span> some_money <span class="op">{</span> <span class="co">// error: mismatched types</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;We got {money}!&quot;</span>)<span class="op">;</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<h3 id="recoverable-errors">Recoverable errors</h3>
<p>We have already been introduced to the Option type that is used to convey null values and resulting errors. Another error handling type in Rust is the Result type, which is encountered often in typical Rust code — Rust does not have a try-catch clause that is common in imperative languages, instead it has the Result type for handling recoverable (non-crashing) errors.</p>
<p>For example, trying to parse a string into a number with the parse method returns a Result type.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a>    <span class="co">// The compiler needs to know the type for parsing</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a>    <span class="co">// the wildcard _ can be used for the type when the compiler is able to infer it.</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a>    <span class="kw">let</span> number<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">i32</span><span class="op">,</span> _<span class="op">&gt;</span> <span class="op">=</span> <span class="st">&quot;20&quot;</span><span class="op">.</span>parse()<span class="op">;</span> </span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{number:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<h4 id="the-result-type">The Result type</h4>
<p>The Result type, much like Option with its variants Some and None, is an enum with two variants, Ok and Err. Unlike None, Err wraps a value which indicates some kind of an error. The compiler needs to always know the types of both Ok and Err variants.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a>      <span class="kw">let</span> result<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;&amp;</span><span class="dt">str</span><span class="op">,</span> ()<span class="op">&gt;</span> <span class="op">=</span> <span class="cn">Ok</span>(<span class="st">&quot;🦀&quot;</span>)<span class="op">;</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true"></a>      <span class="kw">let</span> error<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="cn">Err</span>(<span class="st">&quot;💥&quot;</span>)<span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true"></a>      <span class="pp">println!</span>(<span class="st">&quot;{result:?}, {error:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true"></a>  <span class="op">}</span></span></code></pre></div>
<p>Working with Results is similar to working with Options. We can use multiple methods to work with Results, such as unwrap (may panic), except (may panic), unwrap_or, is_ok, is_err, etc. Here, as well as for other types, the exhaustive list can be found in Rust’s documentation.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a>    <span class="kw">let</span> result<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;&amp;</span><span class="dt">str</span><span class="op">,</span> ()<span class="op">&gt;</span> <span class="op">=</span> <span class="cn">Ok</span>(<span class="st">&quot;🦀&quot;</span>)<span class="op">;</span> <span class="co">// The error type is unit, needs explicit type for compiler</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a>    <span class="kw">let</span> error <span class="op">=</span> <span class="cn">Err</span>(<span class="st">&quot;💥&quot;</span>)<span class="op">;</span> <span class="co">// No explicit type, both ok and err variant types can inferred from usage</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true"></a> </span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}, {}&quot;</span><span class="op">,</span> result<span class="op">.</span>unwrap()<span class="op">,</span> error<span class="op">.</span>unwrap_or(<span class="st">&quot;🦀&quot;</span>))<span class="op">;</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true"></a>    <span class="kw">if</span> result<span class="op">.</span>is_ok() <span class="op">{</span></span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;The result seems ok&quot;</span>)<span class="op">;</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true"></a>    <span class="kw">if</span> error<span class="op">.</span>is_err() <span class="op">{</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;The result seems not ok&quot;</span>)<span class="op">;</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true"></a>        error<span class="op">.</span>expect(<span class="st">&quot;💥💥&quot;</span>)<span class="op">;</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>As with Option variants, we can use the match expression to pattern match the Ok and Err variants and destructure the values inside. Likewise, the if let expression can be used to handle the Ok and Err variants.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true"></a>    <span class="kw">let</span> <span class="kw">mut</span> result<span class="op">:</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">=</span> <span class="cn">Ok</span>(())<span class="op">;</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true"></a>    <span class="kw">match</span> result <span class="op">{</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true"></a>        <span class="cn">Ok</span>(value) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;The value is {value:?}&quot;</span>)<span class="op">,</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true"></a>        <span class="cn">Err</span>(error) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;The error is {error}&quot;</span>)<span class="op">,</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true"></a></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true"></a>    result <span class="op">=</span> <span class="cn">Err</span>(<span class="st">&quot;💥&quot;</span><span class="op">.</span>to_string())<span class="op">;</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true"></a>    <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Ok</span>(value) <span class="op">=</span> result <span class="op">{</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;The value is {value:?}&quot;</span>)<span class="op">;</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true"></a>    <span class="kw">else</span> <span class="kw">if</span> <span class="kw">let</span> <span class="cn">Err</span>(error) <span class="op">=</span> result <span class="op">{</span></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true"></a>        <span class="pp">println!</span>(<span class="st">&quot;The error is {error}&quot;</span>)<span class="op">;</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
<p>Returning a Result from a function requires both Ok and Err to be explicitly defined. Below is an example in a program that mimics (poorly) a general artificial intelligence.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a><span class="kw">fn</span> agi9000(question<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> <span class="dt">String</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a>    <span class="kw">match</span> question <span class="op">{</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true"></a>        <span class="st">&quot;what is the meaning of life?&quot;</span> <span class="op">=&gt;</span> <span class="cn">Ok</span>(<span class="st">&quot;42&quot;</span><span class="op">.</span>to_string())<span class="op">,</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true"></a>        _ <span class="kw">if</span> question<span class="op">.</span>ends_with(<span class="st">&quot;?&quot;</span>) <span class="op">=&gt;</span> <span class="cn">Ok</span>(<span class="st">&quot;probably yes&quot;</span><span class="op">.</span>to_string())<span class="op">,</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true"></a>        _ <span class="op">=&gt;</span> <span class="cn">Err</span>(<span class="st">&quot;this is not a question!&quot;</span><span class="op">.</span>to_string())<span class="op">,</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true"></a>    <span class="op">}</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true"></a></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true"></a><span class="kw">fn</span> ask_computer(question<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">{</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true"></a>    <span class="pp">println!</span>(<span class="st">&quot;Asking the computer: {question}&quot;</span>)<span class="op">;</span></span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true"></a>    <span class="kw">let</span> answer <span class="op">=</span> agi9000(question)<span class="op">;</span></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true"></a>    <span class="kw">match</span> answer <span class="op">{</span></span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true"></a>        <span class="cn">Ok</span>(answer) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;Computer&#39;s answer: {answer}&quot;</span>)<span class="op">,</span></span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true"></a>        <span class="cn">Err</span>(message) <span class="op">=&gt;</span> <span class="pp">println!</span>(<span class="st">&quot;ERROR: {message}&quot;</span>)<span class="op">,</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true"></a>    <span class="op">};</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true"></a><span class="op">}</span></span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true"></a></span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb45-19"><a href="#cb45-19" aria-hidden="true"></a>    ask_computer(<span class="st">&quot;what is the meaning of life?&quot;</span>)<span class="op">;</span></span>
<span id="cb45-20"><a href="#cb45-20" aria-hidden="true"></a>    ask_computer(<span class="st">&quot;can I have a pet dragon?&quot;</span>)<span class="op">;</span></span>
<span id="cb45-21"><a href="#cb45-21" aria-hidden="true"></a>    ask_computer(<span class="st">&quot;all your codebase are belong to us.&quot;</span>)<span class="op">;</span></span>
<span id="cb45-22"><a href="#cb45-22" aria-hidden="true"></a><span class="op">}</span></span></code></pre></div>
</body>
</html>
