<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>97_s_2002_s_TDD_Style 97_s_2002_s_TDD_Style</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://lerina.github.io/css/styles_min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#starting-tdd" id="toc-starting-tdd">Starting TDD:</a></li>
</ul>
</nav>
<style>  
body {line-height: 1.2;}
pre {line-height: 90%;}
</style>
<main>
<h2 id="starting-tdd">Starting TDD:</h2>
<h3 id="tdd-in-rust">TDD in Rust</h3>
<p>Have a look at <a
href="https://rust-cli.github.io/book/tutorial/testing.html">Testing</a>
from the Command Line Applications in Rust book.</p>
<p>Testing the small units that you build your complete application
from, these are called “unit tests”.</p>
<h4 id="making-your-code-testable">Making your code testable</h4>
<p>To figure out what we should test, see what your program features
are. Write unit tests for what the program is supposed to do, to ensure
that your most important piece of logic works. Write the tests in a way
that is not dependent on any of the setup code you have around it.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">//main.rs</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> content<span class="op">.</span>lines() <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line<span class="op">.</span>contains(<span class="op">&amp;</span>args<span class="op">.</span>pattern) <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> line)<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Code in the main function can’t easily call it. This is easily fixed
by moving these piece of code into functions.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> find_matches(content<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> pattern<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> line <span class="kw">in</span> content<span class="op">.</span>lines() <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> line<span class="op">.</span>contains(pattern) <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>                <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> line)<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Then you can call these functions in your test, and assert what its
output are.</p>
<p>Functions that prints directly to stdout, i.e., the terminal are a
bugger. (It could also be a sign that you have written a function that
is firmly integrated in the context it is used in.)</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> find_a_match() <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    find_matches(<span class="st">&quot;lorem ipsum</span><span class="sc">\n</span><span class="st">dolor sit amet&quot;</span><span class="op">,</span> <span class="st">&quot;lorem&quot;</span>)<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>( <span class="co">// uhhhh</span></span></code></pre></div>
<p>How can we make this testable? We’ll need to capture the output
somehow. Rust’s standard library has some neat abstractions for dealing
with I/O (input/output) and we’ll make use of one called
<code>std::io::Write</code>. This is a trait that abstracts over things
we can write to, which includes strings but also
<code>stdout</code>.</p>
<p>The behavior that we abstract over is “write to it”. Examples for the
types that implement (“impl”) it include: The terminal’s standard
output, files, a buffer in memory, or TCP network connections.</p>
<p>With that knowledge, let’s change our function to accept a third
parameter. It should be of any type that implements Write. This way, we
can then supply a simple string in our tests and make assertions on it.
Here is how we can write this version of find_matches:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> find_matches(content<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> pattern<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span><span class="op">,</span> <span class="kw">mut</span> writer<span class="op">:</span> <span class="kw">impl</span> <span class="pp">std::io::</span><span class="bu">Write</span>) <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> line <span class="kw">in</span> content<span class="op">.</span>lines() <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> line<span class="op">.</span>contains(pattern) <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>            <span class="pp">writeln!</span>(writer<span class="op">,</span> <span class="st">&quot;{}&quot;</span><span class="op">,</span> line)<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The new parameter is mut writer, i.e., a mutable thing we call
“writer”. Its type is impl std::io::Write, which you can read as “a
placeholder for any type that implements the Write trait”. Also note how
we replaced the println!(…) we used earlier with writeln!(writer, …).
println! works the same as writeln! but always uses standard output.</p>
<p>Now we can test for the output:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> find_a_match() <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> result <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    find_matches(<span class="st">&quot;lorem ipsum</span><span class="sc">\n</span><span class="st">dolor sit amet&quot;</span><span class="op">,</span> <span class="st">&quot;lorem&quot;</span><span class="op">,</span> <span class="op">&amp;</span><span class="kw">mut</span> result)<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">assert_eq!</span>(result<span class="op">,</span> <span class="st">b&quot;lorem ipsum</span><span class="sc">\n</span><span class="st">&quot;</span>)<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note:<br />
Since stdout expects bytes (not strings), we use std::io::Write instead
of std::fmt::Write. As a result, we give an empty vector as “writer” in
our tests (its type will be inferred to Vec<u8>), in the assert_eq! we
use a b”foo”. (The b prefix makes this a byte string literal so its type
is going to be &amp;[u8] instead of &amp;str).</p>
<p>To now use this in our application code, we have to change the call
to <code>find_matches</code> in main by adding
<code>&amp;mut std::io::stdout()</code> as the third parameter. Here’s
an example of a main function that builds on what we’ve seen in the
previous chapters and uses our extracted find_matches function:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>()<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> args <span class="op">=</span> <span class="pp">Cli::</span>parse()<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> content <span class="op">=</span> <span class="pp">std::fs::</span>read_to_string(<span class="op">&amp;</span>args<span class="op">.</span>path)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>with_context(<span class="op">||</span> <span class="pp">format!</span>(<span class="st">&quot;could not read file `{}`&quot;</span><span class="op">,</span> args<span class="op">.</span>path<span class="op">.</span>display()))<span class="op">?;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    find_matches(<span class="op">&amp;</span>content<span class="op">,</span> <span class="op">&amp;</span>args<span class="op">.</span>pattern<span class="op">,</span> <span class="op">&amp;</span><span class="kw">mut</span> <span class="pp">std::io::</span>stdout())<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cn">Ok</span>(())</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Note:<br />
We could also make this function return a String, but that would change
its behavior. Instead of writing to the terminal directly, it would then
collect everything into a string, and dump all the results in one go at
the end.</p>
<p>Exercise for the reader:<br />
<code>writeln!</code> returns an <code>io::Result</code> because writing
can fail, for example when the buffer is full and cannot be expanded.
Add error handling to find_matches.</p>
<p>We’ve just seen how to make this piece of code easily testable. We
have</p>
<ul>
<li>identified one of the core pieces of our application,</li>
<li>put it into its own function,</li>
<li>and made it more flexible.</li>
</ul>
<p>Even though the goal was to make it testable, the result we ended up
with is actually a very idiomatic and reusable piece of Rust code.
That’s awesome!</p>
<h3 id="arrange-act-assert">Arrange-Act-Assert</h3>
<p>Unit tests are nothing mysterious. They’re just code, executable code
written in the same language that you write your application in. Each
unit test forms the first use of the code you want to write. It calls
the code just as it will be called in the real application. The test
executes that code, captures all the outputs that we care about, and
checks that they are what we expected them to be. Because the test uses
our code in the exact same way that the real application will, we get
instant feedback on how easy or difficult our code is to use. This might
sound obvious, and it is, but it is a powerful tool to help us write
clean and correct code.</p>
<ul>
<li>Arrange all necessary preconditions and inputs.</li>
<li>Act on the object or method under test. AKA Call the object.</li>
<li>Assert that the expected results have occurred.</li>
</ul>
<h3 id="basic-ttd-rules">Basic TTD rules:</h3>
<ul>
<li>Write only enough test code for the test to fail</li>
<li>Only write production code if you have a failing test</li>
<li>Write only enough production code to pass the test</li>
</ul>
<p>There are 5 steps in the TDD flow:</p>
<ol type="1">
<li>Read, understand, and process the feature or bug request. One by
One.</li>
<li>Translate the requirement by writing a unit test. Run the unit test
and let it fail as no code is implemented yet.</li>
<li>Write and implement the code that fulfills the requirement, one edit
at a time. Run all tests and they should pass, if not repeat this
step.</li>
<li>Clean up your code by refactoring.</li>
<li>Rinse, lather and repeat.</li>
</ol>
<p>Note:</p>
<p>A unit test is simply a test that covers a small portion of logic,
like an algorithm, for example. Unit tests should be deterministic. By
“deterministic” we mean that unit tests should never have side-effects
like calls to external APIs that deliver random or changing data.
Instead, you’d use mock data in place of data that could potentially
change over time.</p>
<p>How to write unit tests that fail</p>
<p>There are a couple different ways to write unit tests that fail.</p>
<ul>
<li><p>Write a test that references a function in the code that doesn’t
exist yet. Proceed with the reverse picasso system. start with the bare
minimum and gradually flesh-it-out.</p></li>
<li><p>Alter the assert statement to make it fail. An assert statement
says what value the code being tested is expected to return; this kind
of statement is a key aspect of a unit test. The assert statement should
reflect the feature or bug fix request.</p></li>
</ul>
<h3 id="working-backward-from-outcomes">Working backward from
outcomes</h3>
<p>One thing we notice right away is just how unimportant the actual
code that makes this test pass is. Everything in this test is about
defining the expectations of that code. We are setting boundaries around
why our code is useful and what we expect it to do. We are not
constraining how it does it in any way. We are taking an outside-in view
of code. Any implementation that makes our test pass is acceptable.</p>
<h3 id="the-first-principles">the FIRST principles</h3>
<p>These are a set of five principles that make tests more
effective:</p>
<ul>
<li><p>Fast</p></li>
<li><p>Isolated</p></li>
<li><p>Repeatable</p></li>
<li><p>Self-verifying</p></li>
<li><p>Timely</p></li>
<li><p>Unit tests need to run be fast, under 2 seconds, ideally
milliseconds.</p></li>
<li><p>Tests need to be isolated from one another. One test must not
depend on another test having been run before it.</p></li>
<li><p>Repeatable tests are vital to TDD. Whenever we run a test with
the same production code, that test must always return the same pass or
fail result. In this regard, three popular sources of misery are tests
involving the database, tests against time, and tests through the user
interface. Some techniques to handle these situations in are Test
Doubles –Stubs and Mocks.</p></li>
<li><p>Self-verifying means automated executable code to run and check
whether the outputs are as expected.</p></li>
<li><p>Timely tests are tests written at just the right time to be most
useful. The ideal time to write a test is just before writing the code
that makes that test pass. The design feedback is half of the point of
doing TDD. Anything else is BIG upfront design!</p></li>
<li><p>Try to write one assertion per test Tests provide the most useful
feedback when they are short and specific. Use one assert per test; This
prevents us from tackling too much in one test. This focuses on the
error messages we get during test failures and helps us control the
complexity of our code. It forces us to break things down a little
further.</p></li>
<li><p>The scope of a unit test What does a unit means in a unit test?
The unit refers to the test isolation itself – each test can be
considered a standalone unit. As a result, the size of the code under
test can vary a lot, as long as that test can run in isolation.</p></li>
<li><p>Catch common errors</p></li>
<li><p>Off-by-one errors</p></li>
<li><p>Inverted conditional logic</p></li>
<li><p>Missing conditions</p></li>
<li><p>Uninitialized data</p></li>
<li><p>The wrong algorithm</p></li>
<li><p>Broken equality checks</p></li>
<li><p>Verify error handling logic</p></li>
</ul>
<h3 id="principle-of-writing-unit-tests">Principle of writing unit
tests</h3>
<p>These principles give us maximum flexibility when implementing our
methods.</p>
<ul>
<li>Only testing public methods TDD is all about testing the behaviors
of components, not their implementations. We focus on what a component
does – not on the how it does it.</li>
</ul>
<p>Inside a test, this appears as calling public methods or functions on
public classes and packages. The public methods are the behaviors we
choose to expose to the wider application. Any private data or
supporting code in classes, methods, or functions remain hidden.</p>
<p>A common mistake that developers make when learning TDD is that they
make things public just to simplify testing. Resist the temptation. A
typical mistake here is to take a private data field and expose it for
testing using a public getter method. This weakens the encapsulation of
that class. It is now more likely that the getter will be misused.
Future developers may add methods to other classes that really belong in
this one. The design of our production code is important. Fortunately,
there is a simple way of preserving encapsulation without compromising
testing.</p>
<ul>
<li><p>KISS principle: Keep it Simple and/or Small Use the simplest code
that could possibly work: Using the simplest code is important. There
can be a temptation to use over-engineered algorithms, or perhaps use
the latest language feature just for an excuse to use it. Resist this
temptation. At this stage, our goal is to get the test to pass and
nothing more.</p></li>
<li><p>YAGNI principle: You ain’t gonna need it, until some fact proves
otherwise. Don’t overthink the implementation details: We don’t need to
overthink this. We don’t need to write the perfect code on our first
attempt. We can write a single line, a method, several methods, or
entirely new classes. We will improve this code in the next step. Just
remember to make the test pass and not go beyond what this test is
covering in terms of functionality.</p></li>
</ul>
<h3 id="learning-from-our-tests">Learning from our tests</h3>
<p>Our tests are a rich source of feedback on our design. As we make
decisions, we write them as test code. Seeing this code – the first
usage of our production code – brings into sharp focus how good our
proposed design is. When our design isn’t good, the AAA sections of our
test will reveal those design issues as code smells in the test.</p>
<ul>
<li><p>A messy Arrange step If the code in our Arrange step is messy,
our object may be difficult to create and configure. It may need too
many parameters in a constructor or too many optional parameters left as
null in the test. It may be that the object needs too many dependencies
injected, indicating that it has too many responsibilities or it might
need too many primitive data parameters to pass in a lot of
configuration items. These are signals that the way we create our object
might benefit from a redesign.</p></li>
<li><p>A messy Act step Calling the main part of the code in the Act
step is usually straightforward but it can reveal some basic design
errors. For example, we might have unclear parameters that we pass in,
signatures such as a list of Boolean or String objects. It is very hard
to know what each one means. We could redesign this by wrapping those
difficult parameters in an easy-to-understand new class, called a
configuration object. Another possible problem is if the Act step
requires multiple calls to be made in a specific order. That is
error-prone. It is easy to call them in the wrong order or forget one of
the calls. We could redesign to use a single method that wraps all of
this detail.</p></li>
<li><p>A messy Assert step The Assert step will reveal whether the
results of our code are difficult to use. Problem areas might include
having to call accessors in a specific order or perhaps returning some
conventional code smells, such as an array of results where every index
has a different meaning. We can redesign to use safer constructs in
either case.</p></li>
</ul>
<h3 id="the-refactor-phase">The refactor phase</h3>
<p><em>“In anything at all, perfection is finally attained not when
there is no longer anything to add, but when there is no longer anything
to take away,
<!-- when a body has been stripped down to its nakedness -->…”</em><br />
― Antoine de Saint-Exupéry</p>
<p>This is the phase where we go into software engineering mode. We have
some working, simple code with a test that passes. Now is the time to
refine that into clean code – meaning code that will be easy to read
later. With the confidence that a passing test provides, we are free to
apply any valid refactoring technique to our code. Some examples of
refactoring techniques we can use during this phase include the
following:</p>
<ul>
<li>Extracting a method to remove duplicated code</li>
<li>Renaming a method to express what it does better</li>
<li>Renaming a variable to express what it contains better</li>
<li>Splitting a long method into several smaller ones</li>
<li>Extracting a smaller code block, struct or class</li>
<li>Combining a long parameter list into its own struct or class …</li>
</ul>
<p>All these techniques have one goal: to make our code easier to
understand.</p>
<h3 id="limitations-of-unit-tests">Limitations of unit tests</h3>
<p>One very important idea is that an automated test can only prove the
presence of a defect, not the absence. What this means is that if we
think of a boundary condition, write a test for that, and the test
fails, we know we have a defect in our logic. However, if all our tests
pass, that does not and cannot mean our code is free of defects. It only
means that our code is free of all the defects that we have thought to
test for.</p>
<ul>
<li>Code coverage – an often-meaningless metric Code coverage is a
measure of how many lines of code have been executed in a given run. It
is measured by instrumenting the code and this is something that a code
coverage tool will do for us.</li>
</ul>
</main>
<p>SOURCE:<br />
These are the pages for a one-semester course at 67% speed on imperative
and object-oriented programming at the <a href="http://it.uu.se/"
target="_blank">department of Information Technology</a> at <a
href="http://www.uu.se/" target="_blank">Uppsala University</a>, ran by
<a href="http://wrigstad.com/" target="_blank">Tobias Wrigstad</a>.</p>
</body>
</html>
