<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FiT⁄Code FiT⁄Code</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://lerina.github.io/css/styles.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#fitcode" id="toc-fitcode">FiT⁄Code</a>
<ul>
<li><a href="#the-warehouse-demo" id="toc-the-warehouse-demo">The
warehouse demo</a></li>
<li><a href="#tips" id="toc-tips">Tips:</a></li>
</ul></li>
</ul>
</nav>
<style>  
body {line-height: 1.2;}
pre {line-height: 90%;}
</style>
<!-- 

Fraction Slash ⁄
unicode: U+2044 ⁄  ctrl+shift U 2044 <enter>
html: &#8260;  ⁄
css: \2044   ⁄

-->
<h1 id="fitcode">FiT⁄Code</h1>
<p>Get into the habit of Iterative, incremental software development
with <!-- Feedback informed Test/Code --> <strong>F</strong>eedback
<strong>i</strong>nformed
<strong>T</strong>est/<strong>C</strong>ode</p>
<p>Break Down the Problem into chunks that can be solved more
readily.</p>
<p>For non-trivial projects these additional prelimineries maybe
necessary.</p>
<ul>
<li><p>Descriptive Scope of Work.</p></li>
<li><p>Defines Features for the End User. User requirements cover the
different goals your users can achieve using the product and are
commonly documented in the form of user stories, use cases, and
scenarios.</p></li>
<li><p>Functional Requirements. Functional requirements are product
features that developers must implement to enable the users to achieve
their goals. They define the basic system behavior under specific
conditions.</p></li>
</ul>
<!--
Functional requirements examples

Functional requirements need to be clear, simple, and unambiguous. Here are some examples of well-written functional requirements:

    The system must send a confirmation email whenever an order is placed.

    The system must allow blog visitors to sign up for the newsletter by leaving their email.

    The system must allow users to verify their accounts using their phone number.

Contrary to a popular misconception, functional requirements are not analogous to user stories, but stories can be a useful tool for deriving requirements with the user in mind. For example:

User story: As an existing user, I want to be able to log into my account.

    Functional requirements:

        The system must allow users to log into their account by entering their email and password.

        The system must allow users to log in with their Google accounts.

        The system must allow users to reset their password by clicking on "I forgot my password" and receiving a link to their verified email address.


Every functional requirement typically has a set of related non-functional requirements, for example:

    Functional requirement: "The system must allow the user to submit feedback through a contact form in the app."

    Non-functional requirement: "When the submit button is pressed, the confirmation screen must load within 2 seconds."



-->
<p>This also helps to increase understanding of issues and makes them
easier to tackle.</p>
<ol type="1">
<li>First feedback: From Requirement to test<br />
Can the developer write a test for the selected requirement? If not
requirements are not clear and/or understood. What is the behavioral
intent?</li>
</ol>
<p>The <code>T</code> in FiTCode is TDD. In Tdd test are actually the
<em>requirements as tests</em>. This is different from <em>unit
tests</em> which is basically function testing.</p>
<ol start="2" type="1">
<li>Second feedback: Failing test first<br />
Is the failing test succint? Have you encoded the behavioral expectation
within your assertion. Does the error indicate the most proximate
missing feature?</li>
</ol>
<p>Start by writing a test that calls a function and the output should
match the specifications. To write this test, you don’t need to consider
any sort of implementation; the function is a black box. Focus on
understanding the most important aspect: the expected output.</p>
<ol start="3" type="1">
<li>Third feedback: Code Interface<br />
Can the test easily use the code? Testable code is a must. Take some
time to think of function signature and design of the interface to the
code.</li>
</ol>
<p>Focus on understanding the 2nd most important aspect: the intended
inputs.</p>
<p>We build the code from the inside-out:</p>
<ul>
<li>Core interface</li>
<li>Calculations and blranches</li>
<li>Loops and generalization</li>
<li>Special cases and error handling</li>
</ul>
<ol start="4" type="1">
<li><p>Fourth feedback: The right code works write<br />
Does the test pass? The code that makes a test pass is a response to a
particular requirement. YAGNI is built-in. It does the job and thats
all.</p></li>
<li><p>Fifth feedback: DRY, SOLID, put best practices acronyms
here<br />
Is it time for a refactor session? FiT code is readable, clean,
lean.</p></li>
</ol>
<h3 id="from-requirement-to-test">From Requirement to test</h3>
<p>The answers to the “blank page”; Where to start? You start with the
requirements. Select a requirement.</p>
<blockquote>
<p>Can the developer write a test for the selected requirement?</p>
</blockquote>
<p>If not requirements are not clear and/or understood. What is the
behavioral intent? Understanding the requirements is the responsability
of the developer. What do we want? What do we have? How do we go from
what we have to what we want.</p>
<p>Invest time in data design, domain design, and the interaction
between entities.</p>
<h3 id="failing-test-first">Failing test first</h3>
<p>Is the failing test succint? Have you encoded the behavioral
expectation within your assertion. Does the error indicate the most
proximate missing feature?</p>
<p>Focus is shifted to how can I test this rather than how can I write
this.</p>
<h3 id="code-interface">Code Interface</h3>
<p>Can the test easily use the code? Testable code is a must. Take some
time to think of function signature and design of the interface to the
code. Design code for testability means paying attention to inputs and
output. Dependency injection is the norm.</p>
<h4 id="function-design-recipe">Function Design Recipe</h4>
<h3 id="the-right-code-works-write">The right code works write</h3>
<p>Does the test pass? The code that makes a test pass is a response to
a particular requirement. YAGNI is built-in. It does the job and thats
all.</p>
<h3 id="dry-solid-put-best-practices-acronyms-here">DRY, SOLID, put best
practices acronyms here</h3>
<p>Is it time for a refactor session? FiT code is readable, clean,
lean.</p>
<ul>
<li>Are the tests covering all of the functionality expected?</li>
<li>Are the tests descriptive enough to allow others to understand when
there are failures?</li>
<li>Are the tests independent of each other?</li>
<li>Are there any places in the code or tests where duplication can be
eliminated?</li>
<li>Can something in the test or code be written more simply, clearly or
efficiently?</li>
</ul>
<h2 id="the-warehouse-demo">The warehouse demo</h2>
<h3
id="problem-statement-here-is-the-cop-challenge-opportunity-problem.">Problem
Statement: Here is the COP (Challenge, Opportunity, Problem).</h3>
<blockquote>
<p>The simple warehouse program is an information system for managing
the contents of a storage facility for different kinds of wares. Every
ware in the warehouse has a name, a description, a storage location, a
pricetag, information about the number of items of the particular ware
stored in the warehouse, and the cost of each item. A storage location
is a “section” (a single letter a-z), plus a shelf (an integer).</p>
</blockquote>
<h3 id="expected-operations">Expected operations</h3>
<p>The simple warehouse program manages a database of wares and supports
the following operations:</p>
<ul>
<li>Adding a ware</li>
<li>Removing a ware</li>
<li>Editing the information about a ware</li>
<li>Printing the information for a specific ware</li>
<li>Listing all wares in the database</li>
<li>Undoing the last action</li>
<li>Quitting the program</li>
</ul>
<p>When <strong>starting</strong> the program, the user is presented
with the main menu with the above alternatives and picks a choice by
entering the first letter of each alternative, i.e., <code>A</code>,
<code>R</code>, <code>E</code>, <code>P</code>, <code>L</code>,
<code>U</code>, or <code>Q</code>.</p>
<p>When choosing to <strong>quit</strong>, the user is prompted with a
yes/no question: do you really want to quit? If the answer is
<code>Y</code>, the program exits. If the answer is <code>N</code>, the
program displays the main menu again. If the answer is anything other
than <code>Y</code> or <code>N</code>, an error message is printed and
the question repeated.</p>
<p>When choosing to <strong>add</strong> a ware, the user is prompted
with five consecutive dialogues asking her to enter the required
information for a ware:</p>
<ul>
<li>Name</li>
<li>Description</li>
<li>Storage location</li>
<li>Price</li>
<li>Amount</li>
</ul>
<p>The program then displays the information back to the user and asks
whether this is correct or not. The user has three options:</p>
<ul>
<li><code>E</code>dit the information</li>
<li><code>S</code>ave the information</li>
<li><code>A</code>bort</li>
</ul>
<p>The choice is indicated by entering the first character of each
option. The <em>first alternative</em> allows the user to re-enter one
piece of the required information for a ware after which the editer ware
is displayed again with the same question as above.<br />
The <em>save alternative</em> saves the information to the database and
then returns to the main menu.<br />
The <em>abort alternative</em> returns to the main menu without
saving.</p>
<p>The rest of the actions on the main menu should be fairly
self-explanatory.</p>
<hr />
<h2 id="tips">Tips:</h2>
<ul>
<li><p>Read more than you write:</p></li>
<li><p>When reading code, it’s not crucial to understand the whole
project or the ins and outs of the entire design. Read the code. Look at
the comments, see what the authors are doing, and how they went about
it.</p></li>
<li><p>Develop an aesthetic appreciation for code. Read the source code
of famous open-source tools and frameworks. Train yourself to know what
great code looks like and what bad code “smells” like.</p></li>
<li><p>Get used to Basic TDD</p></li>
<li><p>Guidelines for names</p></li>
<li><p>Functions/Method – Say what it does. What is the outcome? Why
would I call this?</p></li>
<li><p>Variable – Say what it contains. Why would I access
this?</p></li>
<li><p>Testable code</p></li>
<li><p>Printing is detestable to tests. To make a function to be
testable, Rather than print the item, have the function simply return
the data we want. Now, we can test it.</p></li>
<li><p>Avoid Functional Complexities Simplicity is important. Break down
tasks into manageable units, focusing on one function or feature at a
time.</p></li>
<li><p>Tests should be atomic, focusing on specific behaviors and
functionalities. Keep them short, enhancing readability and
maintainability and easing the debugging process. Atomic tests pinpoint
issues more precisely, facilitating quicker resolutions.</p></li>
<li><p>Write tests to test behavior, not implementation.</p></li>
<li><p>Write the Simplest Test Case first. Begin with the basics baby
steps. Write the simplest test case that reflects the expected behavior.
This sets a solid foundation, allowing you to build upon it and
gradually handle more complex scenarios.</p></li>
<li><p>Refactor Regularly</p></li>
<li><p>Test failures is Development Feedback. Analyze the failure,
pinpoint the root cause, and let it inform your development
decisions.</p></li>
<li><p>Compiler error are Development Feedback.</p></li>
</ul>
</body>
</html>
