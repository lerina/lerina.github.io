<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>80_s_Style 80_s_Style</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://lerina.github.io/css/styles_min.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#simple-a-minimalistic-programming-methodology"
id="toc-simple-a-minimalistic-programming-methodology">SIMPLE – A
Minimalistic Programming Methodology</a>
<ul>
<li><a href="#problem-solving-methodology"
id="toc-problem-solving-methodology">0 Problem-Solving
Methodology</a></li>
<li><a href="#simple-a-programming-methodology"
id="toc-simple-a-programming-methodology">1 SIMPLE: A Programming
Methodology</a></li>
<li><a href="#example-a-simple-warehouse"
id="toc-example-a-simple-warehouse">2 Example: A Simple
Warehouse</a></li>
<li><a href="#the-simple-approach" id="toc-the-simple-approach">3 The
SIMPLE Approach</a></li>
<li><a href="#a-summary-of-simple-in-ten-steps"
id="toc-a-summary-of-simple-in-ten-steps">4 A Summary of SIMPLE in Ten
Steps</a></li>
<li><a href="#tickets-tasks-and-post-it-stacks"
id="toc-tickets-tasks-and-post-it-stacks">5 Tickets, Tasks and Post-it
Stacks</a></li>
<li><a href="#the-three-rules-of-passing_the_buck"
id="toc-the-three-rules-of-passing_the_buck">6 The Three Rules of
passing_the_buck</a></li>
<li><a href="#dodging-not-quite-passing_the_buck"
id="toc-dodging-not-quite-passing_the_buck">7 Dodging: Not Quite
passing_the_buck</a></li>
</ul></li>
</ul>
</nav>
<style>  

pre.sourceCode {line-height: 1.20; font-size: 92%; font-weight:bold;}
</style>
<main>
<h1 id="simple-a-minimalistic-programming-methodology">SIMPLE – A
Minimalistic Programming Methodology</h1>
<p>“The best programs are written so that computing machines can perform
them quickly and so that human beings can understand them
clearly.”<br />
_ Donald Knuth</p>
<p>” Inside every large program is a small program struggling to get
out.”<br />
_ Tony Hoare</p>
<h2 id="problem-solving-methodology">0 Problem-Solving Methodology</h2>
<p>From Structured Programming we got Problem-Solving Methodology
suitable for writing computer programs</p>
<p>The process for problem-solving has five steps:</p>
<ol type="1">
<li>State the problem clearly.</li>
<li>Describe the input and output information.</li>
<li>Work the problem by hand (or with a calculator) for a simple set of
data.</li>
<li>Develop an algorithm and convert it to a computer program. The
algorithm can be listed as operations that are performed one after
another.</li>
<li>Test the program with a variety of data.</li>
</ol>
<p>To describe the process of solving a problem with sequential logic,
we use the top-down design.</p>
<p>Decomposition outline: is written sequentially and represents an
ordered set of steps. Example: Compute the straight-line distance
between two points in a plane. Decomposition outline: 1. Give values to
the two points. 2. Compute the lengths of the two sides of the right
triangle generated by the two points. 3. Compute the distance between
the two points, which is equal to the length of the hypotenuse of the
triangle. 4. Print the distance between the two points</p>
<p>Principle of Step-wise Refinement</p>
<p>A program is developed via a sequence of passes and through a series
of versions. Each version is a further refinement of the previous one.
Each version must be able to compile and run correctly. Note: • Always
have a working version • Identify errors as they appear</p>
<h2 id="simple-a-programming-methodology">1 SIMPLE: A Programming
Methodology</h2>
<p>The following describes’ a framework for programming with ease and
“flow”. It is not a design methodology. This is for the time when actual
code writing is performed.</p>
<p>The principles are:</p>
<ul>
<li>Don’t strive for perfection and scalability for an hypothetical
future when writing software. Strive to deliver code that works, is
readable, and maintainable.</li>
<li>Take a complex problem, break it down into smaller pieces, solve
each of those pieces, and then put everything back together to solve the
initial problem.</li>
<li>Plan your code away from the computer. It will help you build a
clear mental model before you start.</li>
<li>Learn the most important libraries for your use cases. The more
libraries you’re aware of for your language, the less likely you are to
try reinventing the wheel.</li>
<li>Have large chunks of time set aside for focused coding. Distraction
and coding are not a match.</li>
<li>“Emotionally detach from your code. Don’t be afraid to share your
unfinished work with others.</li>
<li>Make mistakes, and keep it compiling</li>
</ul>
<!-- ref https://techbeacon.com/app-dev-testing/50-tips-improving-your-software-development-game -->
<p>The rules are:</p>
<ul>
<li>Use the specification in a structured manner to do both function
design and data design.</li>
<li>Work in an incremental fashion, by solving many simple problems
instead of few complex ones.</li>
<li>Always have a working program that you can run and test.</li>
<li>Compile continuously (aka after each edit).</li>
<li>Test continuously, preferably automated but at least manually.</li>
<li>Write straight-line code first, before complicated branches and
loops.</li>
<li>Use stand-ins – fakes, stubs and mocking – to keep programming
simple, flowing, and push problems into the future, when you have more
context, data and natural solutions.</li>
</ul>
<h2 id="example-a-simple-warehouse">2 Example: A Simple Warehouse</h2>
<p>“Programming is usually taught by examples.</p>
<p>Experience shows that the success of a programming course critically
depends on the choice of these examples.” _ Niklaus Wirth</p>
<p>Problem Statement: Here is the COP (Challenge, Opportunity,
Problem).</p>
<blockquote>
<p>The simple warehouse program is an information system for managing
the contents of a storage facility for different kinds of wares. Every
ware in the warehouse has a name, a description, a storage location, a
pricetag, information about the number of items of the particular ware
stored in the warehouse, and the cost of each item. A storage location
is a “section” (a single letter a-z), plus a shelf (an integer).</p>
</blockquote>
<p>The simple warehouse program manages a database of wares and supports
the following operations:</p>
<ul>
<li>Adding a ware</li>
<li>Removing a ware</li>
<li>Editing the information about a ware</li>
<li>Printing the information for a specific ware</li>
<li>Listing all wares in the database</li>
<li>Undoing the last action</li>
<li>Quitting the program</li>
</ul>
<p>When <strong>starting</strong> the program, the user is presented
with the main menu with the above alternatives and picks a choice by
entering the first letter of each alternative, i.e., <code>A</code>,
<code>R</code>, <code>E</code>, <code>P</code>, <code>L</code>,
<code>U</code>, or <code>Q</code>.</p>
<p>When choosing to <strong>quit</strong>, the user is prompted with a
yes/no question: do you really want to quit? If the answer is
<code>Y</code>, the program exits. If the answer is <code>N</code>, the
program displays the main menu again. If the answer is anything other
than <code>Y</code> or <code>N</code>, an error message is printed and
the question repeated.</p>
<p>When choosing to <strong>add</strong> a ware, the user is prompted
with five consecutive dialogues asking her to enter the required
information for a ware:</p>
<ul>
<li>Name</li>
<li>Description</li>
<li>Storage location</li>
<li>Price</li>
<li>Amount</li>
</ul>
<p>The program then displays the information back to the user and asks
whether this is correct or not. The user has three options:</p>
<ul>
<li><code>E</code>dit the information</li>
<li><code>S</code>ave the information</li>
<li><code>A</code>bort</li>
</ul>
<p>The choice is indicated by entering the first character of each
option. The <em>first alternative</em> allows the user to re-enter one
piece of the required information for a ware after which the editer ware
is displayed again with the same question as above.<br />
The <em>save alternative</em> saves the information to the database and
then returns to the main menu.<br />
The <em>abort alternative</em> returns to the main menu without
saving.</p>
<p>The rest of the actions on the main menu should be fairly
self-explanatory.</p>
<h2 id="the-simple-approach">3 The SIMPLE Approach</h2>
<p>“You need to get one thing done well, or else you don’t have
permission to do anything else.”<br />
_ Larry Page</p>
<p>The most fundamental principle of SIMPLE is to <strong>always have a
working program.</strong></p>
<p>By a working program is meant a program that compiles without
warnings or errors, and runs. In the beginning, the program is not going
to do anything useful, which is fine.</p>
<p>Commit your code in small, working chunks with commit messages that
summarizes what you did and why you did it.</p>
<p>“Program construction consists of a sequence of refinement
steps.”<br />
_ Niklaus Wirth</p>
<p>The SIMPLE approach is all about adding functions to the program
little by little until it suddenly is finished.</p>
<p>In essence at first programming is the reverse of Picasso</p>
<figure>
<img src="./pix/reverse_me.gif" alt="the bull" />
<figcaption aria-hidden="true">the bull</figcaption>
</figure>
<p>By always having a working program, it is easier to test the program,
and the most shallow bugs can often be caught by just running the
program and spotting the error.</p>
<p>Furthermore, working with a program that runs is rewarding and avoids
the scary feeling of “not having anything” for a long while until
finally the individual pieces are connected and a program magically
appears.</p>
<p>“Simplicity is about subtracting the obvious and adding the
meaningful” _ John Maeda “The laws of Simplicity”</p>
<p>Secondly,<br />
We strive to keep it simple (the focus of our effort) and runnable.
Compile after each edit. Commit after each running build.</p>
<p>Simplicity implies code that is</p>
<p>” - Ease to understand - Easy to change - Easier to debug - Flexible
* API policy * location ” _ Rich Hickey (Closure creator)</p>
<p><strong>I am supposed to write a program. Where do I
start?</strong></p>
<figure>
<img
src="https://s.abcnews.com/images/Entertainment/GTY_janet_leigh_kab_150916_12x5_992.jpg"
class="moz-reader-block-img" data-moz-reader-center="true"
alt="janet_leigh: Psyco" />
<figcaption aria-hidden="true">janet_leigh: Psyco</figcaption>
</figure>
<p>This is exactly the question SIMPLE is trying to answer.<br />
Along with the question, when am I done?</p>
<p>We will now proceed by walking through a number of steps, and
stopping and recapping once in a while.</p>
<h3 id="step-1.-think-a-little.">3.1 Step 1. Think a little.</h3>
<p>“Thinking doesn’t guarantee that we won’t make mistakes. But not
thinking guarantees that we will.”<br />
_ Leslie Lamport</p>
<p>Where you should <strong>not</strong> start? The code editor!</p>
<p><strong>UNDERSTAND</strong></p>
<p>Before we start to code, we should make sure to understand something
more about the program. The goal is to make sure we have a basic
understanding of what the program is supposed to accomplish, but not yet
care about how it should accomplish it.</p>
<p><strong>Textual Analysis</strong></p>
<p>To get a feeling for what the program is trying to accomplish, we
mine the specification. This means re-reading it, looking for some
particular kind of information. To understand the program’s <strong>core
behaviour</strong>, we pay close attention to the verbs and actions.
Using a pen to underline or highlight them is not a bad idea.</p>
<p>For concreteness, I am copying in parts of the specification from
above, <strong>highlighting</strong> as I go.</p>
<blockquote>
<p>The simple warehouse program is an for … letter a-z), plus a shelf
(an integer).</p>
<p>The simple warehouse program manages a database of wares and supports
the following operations:</p>
<ol type="1">
<li><strong>Adding</strong> a ware</li>
<li><strong>Removing</strong> a ware</li>
<li><strong>Editing</strong> the information about a ware</li>
<li><strong>Printing</strong> the information for a specific ware</li>
<li><strong>Listing</strong> all wares in the database</li>
<li><strong>Undoing</strong> the last action</li>
<li><strong>Quitting</strong> the program</li>
</ol>
<p>When <strong>starting</strong> the program, the user is
<strong>presented</strong> with the main menu with the above
alternatives and <strong>picks a choice</strong> by entering the first
letter of each alternative, i.e., <code>A</code>, <code>R</code>,
<code>E</code>, <code>P</code>, <code>L</code>, <code>U</code>, or
<code>Q</code>.</p>
<p>When <strong>choosing to quit</strong>, the user <strong>is prompted
with a yes/no question</strong>: …</p>
</blockquote>
<p>Looking at the text above, I have a pretty good overview of what the
program is supposed to do at a high-level. Of course, this specification
is extremely simple by listing the main menu with a lot of actions, but
even if it didn’t, picking the actions probably would not be that much
harder.</p>
<p>Now, I take a piece of paper and write these things down. A <a
href="http://en.wikipedia.org/wiki/Mind_map">mindmap</a> is usually a
good way to capture hierarchical structures.</p>
<figure>
<img src="http://wrigstad.com/ioopm/img1.png"
class="moz-reader-block-img" data-moz-reader-center="true"
alt="Figure 2: Initial mind map of actions in the program" />
<figcaption aria-hidden="true">Figure 2: Initial mind map of actions in
the program</figcaption>
</figure>
<p>The mind-map tells me what actions that the program should support,
but so-far nothing about how they should be implemented. So far, that’s
fine.</p>
<p><strong>Divide &amp; Conquer</strong> We are abstracting and
compartmentalising. If we tried to understand the entire system before
starting to code, we would probably never start to code, because it is
very hard to know when you truly understand something. The key is to not
get into a situation where this matters. At least not yet.</p>
<blockquote>
<p>We are going to alternate between thinking a little and coding a
little.</p>
</blockquote>
<p>We are going to think just enough so that we understand what is a
plausible next step forward.</p>
<p>Then we are going to write some comments that describe the first
immideate thing that we want to have.</p>
<p>Next we write code that tests’ the result of the described but not
yet written code that is supposed to produce such result. - Only write
enough of a unit test to fail</p>
<p>Now in a very tight feedback loop, we are going to actually write the
simplest code that would make the test succeed. - Only write enough code
to help a failing unit test pass.</p>
<p>That is make the test pass doing the simplest thing possible such as:
- return the expected value hard coded, - return a computed hard coded
values, - return the dynamically computed value, and so forth.</p>
<p>Now we evaluate whether that was a good step or not by comparing what
we wanted in the description with what we coded. If we are satisfyed
withthe solution, <strong>refactor</strong>. - clean up (optimize if
applicable) the code. * remove code duplication * simplify nested code
structures * switch to a functional “oneliner”</p>
<p>Once you are done, you move on to the next feature and start all over
again. - Write minimal test, minimal code, refactor, …</p>
<p>This is good, because <a
href="http://web.media.mit.edu/%7Eminsky/papers/Why%20programming%20is--.html">coding
is a good way to understand sloppily formulated ideas</a>. By forcing us
to concretise, coding challenges us to understand what it is we
understand.</p>
<h3 id="step-2-code-a-little.">3.2 Step 2: Code a little.</h3>
<p>“Talk is cheap. Show me the code.”<br />
_ Linus Torvalds</p>
<p>Following the most fundamental principle of SIMPLE, we start with the
minimal working program. If we are using C, we would probably write
something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      puts<span class="op">(</span><span class="st">&quot;Welcome to my warehouse program!&quot;</span><span class="op">);</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>If we are using Rust, we would write:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Welcome to my warehouse program!&quot;</span>)<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This program is pretty much hello world, but it <strong>compiles and
runs</strong>.</p>
<p>NOTE:</p>
<p>In order to do Test_as_you_Code we need a solution to <em>test</em>
console/terminal output.</p>
<p>A very simple way is indirection</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> msg(s<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span>) <span class="op">-&gt;</span> <span class="op">&amp;</span><span class="dt">str</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    s</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> msg(<span class="st">&quot;Welcome to my warehouse program!&quot;</span>))<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co">//----------------------------</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> greeting() <span class="op">{</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> welcome_msg <span class="op">=</span> msg(<span class="st">&quot;Welcome to my warehouse program!&quot;</span>)<span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(welcome_msg<span class="op">,</span> <span class="st">&quot;Welcome to my warehouse program!&quot;</span>)<span class="op">;</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><em>3.2 test001</em></p>
<p>Now, we take the actions from the mind-map and turn them into
functions. For example, for “add”, we do:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> add_action<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>      puts<span class="op">(</span><span class="st">&quot;Add action is not implemented yet&quot;</span><span class="op">);</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>rust</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> add_action() <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> msg(<span class="st">&quot;Add action is not implemented yet&quot;</span>)<span class="op">};</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Rust has a todo!() macro for non-implemented code</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">//&gt; 1.  **Adding** a ware</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> add_action() <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">todo!</span>()<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>And similar functions for all the other actions. We do this in order
to have placeholders for code that we are going to write.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode numberSource rust numberLines"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">//&gt; 2.  **Removing** a ware</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">fn</span> remove_action() <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="pp">todo!</span>()<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="op">}</span></span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="co">//&gt; 3.  **Editing** the information about a ware</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="kw">fn</span> edit_action() <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>    <span class="pp">todo!</span>()<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="co">//&gt; 4.  **Printing** the information for a specific ware</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="kw">fn</span> print_action() <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>    <span class="co">//todo!();</span></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15"></a></span>
<span id="cb7-16"><a href="#cb7-16"></a><span class="co">//&gt; 5.  **Listing** all wares in the database</span></span>
<span id="cb7-17"><a href="#cb7-17"></a><span class="kw">fn</span> list_all_action() <span class="op">{</span></span>
<span id="cb7-18"><a href="#cb7-18"></a>    <span class="pp">todo!</span>()<span class="op">;</span></span>
<span id="cb7-19"><a href="#cb7-19"></a><span class="op">}</span></span>
<span id="cb7-20"><a href="#cb7-20"></a></span>
<span id="cb7-21"><a href="#cb7-21"></a><span class="co">//&gt; 6.  **Undoing** the last action</span></span>
<span id="cb7-22"><a href="#cb7-22"></a><span class="kw">fn</span> undo_action() <span class="op">{</span></span>
<span id="cb7-23"><a href="#cb7-23"></a>    <span class="pp">todo!</span>()<span class="op">;</span></span>
<span id="cb7-24"><a href="#cb7-24"></a><span class="op">}</span></span>
<span id="cb7-25"><a href="#cb7-25"></a></span>
<span id="cb7-26"><a href="#cb7-26"></a><span class="co">//&gt; 7.  **Quitting** the program </span></span>
<span id="cb7-27"><a href="#cb7-27"></a><span class="kw">fn</span> quit_action() <span class="op">{</span></span>
<span id="cb7-28"><a href="#cb7-28"></a>    <span class="pp">todo!</span>()<span class="op">;</span></span>
<span id="cb7-29"><a href="#cb7-29"></a><span class="op">}</span></span></code></pre></div>
<p>Again we want to compartmentalise as much as possible: by focusing on
just one small thing at a time, each problem is going to not just seem
simple, but be simple.</p>
<p>You do not move on to another function until the program compiles.
That is the test passes and you can run the program (even if it still
does nothing)</p>
<p>Tip: <strong>Compile Early. Compile Often.</strong></p>
<p>You really want to compile your code.</p>
<p>When you are new to a programming language, make a habit to compile
after each edit. After a while, you will be able to go up to a few
lines. Then a bit more, etc.</p>
<p>The reason for this is to compartmentalise your errors too! If you
write 100 lines of code before you try to compile, you are likely to get
50 errors. Unless you are hardened by experience, this can be an
insurmountable and cause you to give up.</p>
<p>The nastiest compiler errors always happen in the code you wrote more
than one hour ago. Not because you were a worse programmer then, but
because it was one hour ago! You probably don’t remember what you were
thinking back then, so you have to work hard at retracing your
steps.</p>
<p>If you try to make sure the code compiles every two minutes, <a
href="https://www.theobjectivestandard.com/2013/09/spocks-illogic-the-needs-of-the-many-outweigh-the-needs-of-the-few/"
target="_blank">logic dictates</a> that solving these bugs is way way
easier. Good programmers likes easy.</p>
<p>Tip <strong>The Compiler Errors are your friends</strong></p>
<p>If for some reason you do get a whole page of compiler errors there
are four important things to do, two of which are really hard even for a
seasoned programmer:</p>
<ul>
<li>Don’t panic!</li>
<li>Read the error messages!</li>
<li>Address the errors <strong>one by one</strong> and <strong>in the
order they were printed on the screen</strong>.</li>
<li>Recompile all the time, and always after addressing each error.</li>
</ul>
<p>Compilers are usually really bad at printing readable error messages.
Get used to reading them. Some compilers are more helpful than others.
The Rust compiler is a gem and getting better.</p>
<p>Often an error on line N cause one or more errors on lines N+X and
N+Y, and since the compiler in the general case cannot rule out that the
errors are unrelated, it prints all of them. Consequently, if the
compiler says you have 10 errors, it is more likely less than 10,
sometimes just one. The error that appears closest to your cursor on the
prompt after compiling is therefore more likely to be a “faux error”
than the first error that the compiler printed. Don’t waste time fixing
something that does not need fixing. Jump to the first reported
error.</p>
<p>Since one error often create “faux errors” later in the code,
recompile all the time while fixing compile errors. It may be that
fixing the first reported error closes all of the remaining ones.</p>
<p>Also, it is not uncommon to introduce a new error while you are
fixing another one, so recompile often to make sure that the error
number goes down steadily.</p>
<h3 id="step-3-think-a-little-more.">3.3 Step 3: Think a little
more.</h3>
<p>We now have a working program that does absolutely nothing. Let’s
start adding some functionality to our program following the
specification.</p>
<p>The first six action all require either that there is some data in
the program, or that we are able to add some data. We haven’t done any
data design yet, so if we want to start with these, we should that.
However, the last action, quitting, is very simple and does not do much
so that is a good starting point.</p>
<p>We now go back to our mind-map and extend the specification of
quit.</p>
<figure>
<img src="http://wrigstad.com/ioopm/img2.png"
class="moz-reader-block-img" data-moz-reader-full-width="true"
data-moz-reader-center="true"
alt="Figure 3: Second mindmap of the program" />
<figcaption aria-hidden="true">Figure 3: Second mindmap of the
program</figcaption>
</figure>
<p>Re-reading the specification, we now know that triggering quit should
enter into a confirmation dialogue, and if the user replies
<code>Y</code>, then we quit, if <code>N</code> we return to the main
menu, otherwise repeat the question.</p>
<h3 id="step-4-code-a-little-more.">3.4 Step 4: Code a little more.</h3>
<p>To keep the program as simple as possible, we are not going to add
functionality for choosing an action in the main menu just yet. That’s
not needed, because the only thing we are going to implement is
quit.</p>
<p>So, although it is futile, let’s extend the program so that when we
run it, it asks if we want to quit.</p>
<p>To this end, we will add a <code>while</code> loop that loops forever
and that in each turn of the loop asks us whether we want to quit. This
will allow us to test both the yes and no answers.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">while</span> <span class="op">(</span>true<span class="op">)</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>          puts<span class="op">(</span><span class="st">&quot;Welcome to my warehouse program!&quot;</span><span class="op">);</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> <span class="op">(</span>quit_action<span class="op">())</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>In Rust</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> msg(<span class="st">&quot;Welcome to my warehouse program!&quot;</span>))<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> quit_action() <span class="op">==</span> <span class="cn">true</span> <span class="op">{</span> <span class="cf">break</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="at">#[</span>cfg<span class="at">(</span>test<span class="at">)]</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="kw">mod</span> tests <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="kw">super</span><span class="pp">::</span><span class="op">*;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">...</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> quit() <span class="op">{</span> <span class="co">//3.4 </span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> quitting<span class="op">:</span> <span class="dt">bool</span> <span class="op">=</span> quitting_action()<span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert!</span>(quitting <span class="op">==</span> <span class="cn">false</span>)<span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><em>3.4: test002</em></p>
<p>Once this edit is done, we run the tests and/or compile and run the
program. Just to be sure we did not break anything. But oh, it does! And
it wont even compile in Rust. <code>quit_action()</code> must first be
updated to return a <code>bool</code>. We fix this with the simplest
code to pass the test by adding a return false; as the default return
and also include <code>stdbool.h</code> at the top of the file.</p>
<p>Moving on, we now have a function <code>quit_action()</code> that
looks like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> quit_action<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>      puts<span class="op">(</span><span class="st">&quot;Quit action is not implemented yet&quot;</span><span class="op">);</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>In Rust</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: not finished</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> quit_action() <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>       <span class="co">//todo()! </span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>       <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> msg(<span class="st">&quot;Quit action not finished yet&quot;</span>))<span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>       <span class="cn">false</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Our goal now is to implement the behaviour of the specification which
was just re-iterated above. We are going to do this in a few small
increments.</p>
<ul>
<li>Print confirmation question</li>
<li>Read input</li>
<li>Handle <code>Y</code> case</li>
<li>Handle <code>N</code> case</li>
<li>Handle remaining cases</li>
</ul>
<p>Increment 1 is easy. Just change the existing
<code>puts()</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> quit_action<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      puts<span class="op">(</span><span class="st">&quot;Do you want to quit? [Y/N]&quot;</span><span class="op">);</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>In Rust</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> quit_action() <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>       <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> msg(<span class="st">&quot;Do you want to quit? [Y/N]&quot;</span>))<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>       <span class="cn">false</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Increment 2 is much harder.</p>
<p>It requires us to know how to read input from a user in C. This is
actually pretty complicated and there are many opportunities for errors.
Therefore, <strong>temporarily write-out problems caused by
hard-to-write code</strong> just by delegating it to a yet to be written
function. In effect pass the buck: <strong>assume the existence of a
function that solves the problem.</strong></p>
<p>This makes increment 2 really simple:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> quit_action<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>      puts<span class="op">(</span><span class="st">&quot;Do you want to quit? [Y/N]&quot;</span><span class="op">);</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">char</span> input <span class="op">=</span> get_char_input<span class="op">();</span> <span class="co">// &lt;---- This line was added</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>In Rust</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> quit_action() <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>       <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> msg(<span class="st">&quot;Do you want to quit? [Y/N]&quot;</span>))<span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>       <span class="kw">let</span> input<span class="op">:</span> <span class="dt">String</span> <span class="op">=</span> get_char_input()<span class="op">;</span> <span class="co">// &lt;---- This line was added</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>       <span class="cn">false</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><strong>You really need to understand that</strong> passing_the_buck
is one of the best tools in the programming toolbox. You should use it
all the time.</p>
<p>The first rule of passing_the_buck is this:</p>
<blockquote>
<p><em>If you don’t know immediately how to solve a problem, assume the
existence of a function that solves this problem for you, and call that
function.</em></p>
</blockquote>
<p>This is great because usually when you are programming, you are going
somewhere and you have a particular <a
href="http://en.wikipedia.org/wiki/Control_flow">control flow</a> in
mind. Getting stuck implementing one step of this flow usually means
your train of thought is interrupted and because your mind is now
focused on solving the current step, you will have a harder time
continuing where you got stuck once you are unstuck.</p>
<p>Aside: <em>This is actually not so different from tricks used by
surrealist authors experimenting with automatic text. There a standard
trick is to choose a word or a first letter of a word that you revert to
whenever your brain gets stuck. Here our actions are slightly more
sensible. (At least to some.)</em></p>
<p>Like we did with the empty action functions from the start, we add a
dummy function to the file called <code>get_char_input()</code> to stay
true to the ideal of always having a working program:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> get_char_input<span class="op">()</span> <span class="co">// &lt;-- return type derived from the call-site</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="ch">&#39;Y&#39;</span><span class="op">;</span> <span class="co">// &lt;-- a good default because of how increment 3 is specified</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>In Rust as per TDD style we add a test first</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>    <span class="at">#[</span>test<span class="at">]</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> quit_input() <span class="op">{</span> <span class="co">// 3.4</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> input<span class="op">:</span> <span class="dt">String</span> <span class="op">=</span> get_char_input()<span class="op">;</span> <span class="co">//</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="pp">assert_eq!</span>(input<span class="op">,</span> <span class="st">&quot;Y&quot;</span>)<span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p><em>3.4 test004</em></p>
<p>Can’t compile: <em>cannot find function <code>get_char_input</code>
in this scope</em></p>
<p>Now we can implement the simple code to makethe test pass.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> get_char_input() <span class="op">-&gt;</span> <span class="dt">String</span> <span class="op">{</span> <span class="co">// &lt;-- return type derived from the call-site</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;Y&quot;</span><span class="op">.</span>to_string() <span class="co">// &lt;-- a good default because of how increment 3 is specified</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<blockquote>
<p>We can now compile and run our program as a kind of minimal
testing.</p>
</blockquote>
<p>Back to our increment 3, which is dealing with the base case of the
user entering a <code>Y</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> quit_action<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>      puts<span class="op">(</span><span class="st">&quot;Do you want to quit? [Y/N]&quot;</span><span class="op">);</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">char</span> input <span class="op">=</span> get_char_input<span class="op">();</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>input <span class="op">==</span> <span class="ch">&#39;Y&#39;</span><span class="op">)</span> <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>In Rust</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> quit_action() <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>       <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> msg(<span class="st">&quot;Do you want to quit? [Y/N]&quot;</span>))<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>       <span class="kw">let</span> input<span class="op">:</span> <span class="dt">String</span> <span class="op">=</span> get_char_input()<span class="op">;</span> <span class="co">// &lt;---- This line was added</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> input <span class="op">==</span> <span class="st">&quot;Y&quot;</span> <span class="op">{</span> <span class="cf">return</span> <span class="cn">true</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>       <span class="cn">false</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Increment 4 is dealing with the case of the user inputting a
<code>N</code>. Turns out it is already handled, as the function returns
<code>false</code> as a default.</p>
<p>This leaves us with increment 5, which is the user replying with
something other than <code>Y</code> or <code>N</code>.</p>
<p>The reason why I left this case until now is because this is the case
that removes some of the simplicity of the code we have been working on
so far: we must now add a loop to this function to be able to repeat the
question.</p>
<p>We start by wrapping the entire function inside a <code>while</code>.
The exit condition of the <code>while</code> is that input is either
<code>Y</code> or <code>N</code>.</p>
<p>Otherwise, the specification dictates’, an error message shall be
printed and the question shall be asked again indefinitely. Here is a
first attempt at doing this:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> quit_action<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>      <span class="cf">while</span> <span class="op">(</span>true<span class="op">)</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>          puts<span class="op">(</span><span class="st">&quot;Do you want to quit? [Y/N]&quot;</span><span class="op">);</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>          <span class="dt">char</span> input <span class="op">=</span> get_char_input<span class="op">();</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> <span class="op">(</span>input <span class="op">==</span> <span class="ch">&#39;Y&#39;</span><span class="op">)</span> <span class="cf">return</span> true<span class="op">;</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> <span class="op">(</span>input <span class="op">==</span> <span class="ch">&#39;N&#39;</span><span class="op">)</span> <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>          puts<span class="op">(</span><span class="st">&quot;Only Y or N are valid answers!&quot;</span><span class="op">);</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> false<span class="op">;</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>In Rust</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// </span><span class="al">TODO</span><span class="co">: implement</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> quit_action() <span class="op">-&gt;</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>       <span class="cf">loop</span> <span class="op">{</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>           <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> msg(<span class="st">&quot;Do you want to quit? [Y/N]&quot;</span>))<span class="op">;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>           <span class="kw">let</span> input<span class="op">:</span> <span class="dt">String</span> <span class="op">=</span> get_char_input()<span class="op">;</span> <span class="co">// &lt;---- This line was added</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>           </span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>           <span class="cf">if</span> input <span class="op">==</span> <span class="st">&quot;Y&quot;</span> <span class="op">{</span> <span class="cf">return</span> <span class="cn">true</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>           <span class="cf">if</span> input <span class="op">==</span> <span class="st">&quot;N&quot;</span> <span class="op">{</span> <span class="cf">return</span> <span class="cn">false</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>           <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> msg(<span class="st">&quot;Only Y or N are valid answers!&quot;</span>))<span class="op">;</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>       <span class="op">}</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>       <span class="cn">false</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Note how I insert “paragraph breaks” into the code to capture what
belongs together, and to help the reader “breathe”. Asking the question
and getting the reply feels like two related concepts. The two checks of
the exit conditions are clearly also related. Thus, I group these
together by separating them with a paragraph, and also put another
paragraph before the error which is the logical conclusion of the
function.</p>
<p>Also note that I removed the <code>// TODO: implement</code> comment
since the function is now properly implemented, modulo the cheat – the
call to the (yet) non-existent function.</p>
<h3 id="intermission-developing-in-increments">3.5 Intermission:
Developing in Increments</h3>
<p>The <code>quit_action()</code> function was developed in a series of
steps. The choice of the steps was very deliberate. Here are the rules
to follow:</p>
<dl>
<dt>If there is any kind of branching, start with the most basic
interesting case first</dt>
<dd>
In our example, <code>Y</code> and <code>N</code> are equally basic but
only <code>Y</code> leads to something interesting, i.e., exits the
program. The non yes or no cases require retrying which is more
complicated, so we delay those even further. In the end, the order is
<code>Y</code>, <code>N</code>, and “the rest”.
</dd>
<dt>Always finish a straight-line version first</dt>
<dd>
This means that any code that involves loops, you start by focusing on
getting one iteration of the loop working in the working program. Once
that is done, you can more easily wrap the working code inside a loop.
Note that by this rule, the Y case would still be implemented before
“the rest” even if Y called some other functions to save the database
etc.
</dd>
<dt>Each increment should accomplish something sensible</dt>
<dd>
Each increment should result in a working program.
</dd>
</dl>
<p>Each increment should ideally have a test that drives the coding or
at the very least; Each increment should ideally have a testable outcome
: For example, when we implemented (skipped…) increment 4, we should
also have changed the <code>get_char_input()</code> to return N to test
this. And similar for increment 5.</p>
<p>Now: back to the running example.</p>
<h3 id="step-5-remove-the-cheats">3.6 Step 5: Remove the Cheats</h3>
<p>We have finished <code>quit_action()</code>, but mostly because we
cheated. To finish implementing this part of the program, we will now
remove the cheat by implementing <code>get_char_input()</code>.</p>
<p>However, the reason why we didn’t write this piece of code down
immediately from the start was because we thought it was complicated and
did not know exactly how to do it.</p>
<p>So, how do we proceed now?</p>
<p>Well, we cannot magically suddenly grasp how to read user input. This
knowledge generally comes from somewhere. Let’s cover the three most
basic cases:</p>
<ol type="1">
<li>Google/Stack Exchange</li>
<li>A text book</li>
<li>Man pages</li>
</ol>
<h4 id="man-pages">3.6.1 Man Pages</h4>
<p>Posix compliant operating systems have a <code>man</code> command
that brings up the manual for a certain topic. For example, if you write
<code>man printf</code>, you will get the manual page for
<code>printf</code> <em>and associated functions</em>. The associated
functions bit is key – often you know how to do something related, but
maybe not this particular case. For example, you may know how to read
formatted data from the terminal with <code>scanf</code>, and then you
can use man <code>scanf</code> to find out about <code>fscanf</code>
that reads formatted data from a file. The man pages are a great tool to
know because they are such quick access to information, usually at a
much higher quality (but less specific) than Stack Exchange etc.</p>
<h4 id="a-text-book">3.6.2 A Text Book</h4>
<p>You may have a text book on the subject. If so, great. Figuring out
what to look for might be tricky. You first have to make the connection
to I/O, and then you must go through 50 pages to find a mention of the
specific functionality you are looking for. However, if you do, a text
book usually gets you there. As long as you are doing something quite
basic.</p>
<h4 id="google-stack-exchange">3.6.3 Google / Stack Exchange</h4>
<p>This is usually the easiest option. And a really good one at that. A
problem with code from Stack Exchange or random blogs is that you may
not always understand exactly what the code does, and why. You normally
end up with 40+ suggested solutions to your problem, 10 of which use
libraries that you don’t have or know how to include, another 10 that
you cannot get to compile because of reasons, leaving another 20 which
you must somehow chose between.</p>
<p>So how do you do that? Actually, in the same way as with the text
book or examples from man pages: you try it out.</p>
<p>Here is the golden rule of trying code out: <strong>start with a new
empty file that just tests the code you’re trying to get to
run.</strong></p>
<p>The reason for this is <strong>compartmentalising</strong>. It may be
that the reason why you are stuck on something is because there is an
error in your code somewhere that breaks some part. Pasting random code
into the place where you believe that the error is, will probably not
uncover anything. It will just cause you to go through all 20 versions
and (erroneously) conclude that none of them works.</p>
<p>Also, by isolating the code you are looking at in a single file,
there is a lot less disturbance. You want to be working at all times
with the smallest possible thing that can work. Remember: <strong>good
programmers like lazy.</strong></p>
<p>If the problem is getting user input, then writing a small test
program for that is easy. To simplify copying the solution across to the
“real program” you can even name the functions right from the start:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> get_char_input<span class="op">()</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">// paste code here</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>      printf<span class="op">(</span><span class="st">&quot;You pressed: &#39;%c&#39;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> get_char_input<span class="op">());</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb24"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> get_char_input() <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>        <span class="pp">todo!</span>()<span class="op">;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main () <span class="op">{</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}{}&quot;</span><span class="op">,</span> msg(<span class="st">&quot;You pressed: &#39;{}&#39;&quot;</span>)<span class="op">,</span> get_char_input())<span class="op">;</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>This program will call <code>get_char_input()</code> and print out
the character between single quotes to avoid confusion. We can now spend
the next 15 minutes on getting the code that we are finding online to
work in this file, and then simply copy <code>get_char_input()</code>
across to our other C file.</p>
<p>Tip <strong>Make it Easy to Write Small Test Programs</strong></p>
<p>The easiest way to understand how something works in programming is
generally to test it out. To that end, make it really easy to start with
an empty file, compile and run it. This could be hacking your editor,
downloading a plugin to your IDE, or saving an empty file plus <a
href="http://mrbook.org/tutorials/make/" target="_blank">makefile</a> in
a directory that you simply copy to make a new “testbed” for
something.</p>
<p>Understand that testing something out simplifies life tremendously,
and that all minutes spent on simplifying simplification simplifies even
more.</p>
<h3 id="step-6-think-a-little-code-a-little-seems-familiar">3.7 Step 6:
Think a little – Code a little (Seems familiar?)</h3>
<p>Now that we are done with quitting the program, it is time to move on
to the next action. However, in order to get to the next action, we must
first extend the main loop of the program so that the user can choose
between whatever action we choose to implement next, and quitting.</p>
<p>Looking at the specification, the user’s input is again by reading a
character. Great that we have already implemented
<code>get_char_input()</code> to do exactly that. (If we hadn’t, we
could just rely on the existing cheat, but eventually we would have to
implement it of course.)</p>
<p>Following the instructions on how to develop in increments, etc. and
looking at how we implemented the dialogue in
<code>quit_action()</code>, we can relatively quickly write something
like this:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">bool</span> should_quit <span class="op">=</span> false<span class="op">;</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">while</span> <span class="op">(!</span>should_quit<span class="op">)</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>          puts<span class="op">(</span><span class="st">&quot;Main menu:&quot;</span><span class="op">);</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>          puts<span class="op">(</span><span class="st">&quot;[A]dd ware&quot;</span><span class="op">);</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>          <span class="co">// ... &lt;--- remaining actions, or just omit them for now</span></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>          puts<span class="op">(</span><span class="st">&quot;[Q]uit&quot;</span><span class="op">);</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>          <span class="dt">char</span> input <span class="op">=</span> get_char_input<span class="op">();</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>          <span class="co">// Hmmm ... code formatting?</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> <span class="op">(</span>input <span class="op">==</span> <span class="ch">&#39;A&#39;</span><span class="op">)</span>      <span class="op">{</span> add_action<span class="op">();</span> <span class="op">}</span></span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>input <span class="op">==</span> <span class="ch">&#39;Q&#39;</span><span class="op">)</span> <span class="op">{</span> should_quit <span class="op">=</span> quit_action<span class="op">();</span> <span class="op">}</span></span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span>                   <span class="op">{</span> puts<span class="op">(</span><span class="st">&quot;Invalid choice!&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>In Rust</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> <span class="kw">mut</span> should_quit <span class="op">=</span> <span class="cn">false</span><span class="op">;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>      <span class="cf">while</span> should_quit <span class="op">==</span> <span class="cn">false</span> <span class="op">{</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>          <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> msg(<span class="st">&quot;Main menu:&quot;</span>))<span class="op">;</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>          <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> msg(<span class="st">&quot;[A]dd ware&quot;</span>))<span class="op">;</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>          <span class="co">// ... &lt;--- remaining actions, or just omit them for now</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>          <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> msg(<span class="st">&quot;[Q]uit&quot;</span>))<span class="op">;</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> input<span class="op">:</span> <span class="dt">String</span> <span class="op">=</span> get_char_input()<span class="op">;</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>          <span class="co">// Hmmm ... code formatting?</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> input <span class="op">==</span> <span class="ch">&#39;A&#39;</span>        <span class="op">{</span> add_action()<span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span> <span class="cf">if</span> input <span class="op">==</span> <span class="ch">&#39;Q&#39;</span>   <span class="op">{</span> should_quit <span class="op">=</span> quit_action()<span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>          <span class="cf">else</span>                   <span class="op">{</span> <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> msg(<span class="st">&quot;Invalid choice!&quot;</span>))<span class="op">;</span> <span class="op">}</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Here, I added printing of (part of) the main menu, a call to
<code>get_char_input()</code>, and I also changed the code a little to
make use of a <code>should_quit</code> variable to control whether the
main loop should continue or not. The reason for this is simply because
code with fewer exit points is simpler to understand.</p>
<p>However, looking at this code and the code for
<code>quit_action()</code>, I notice that there is a small modicum of
repetition. In both cases, I have to handle the failure mode, i.e., when
the user presses something that isn’t part of the protocol.</p>
<p>Now <strong>refactoring</strong> enters into the picture. What I want
to do now is to improve the code for <code>get_char_input()</code> so
that it can handle the failure for me. A simple way to do that is to
pass both the question and the valid alternatives to the
<code>get_char_input()</code> function:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> input <span class="op">=</span> get_char_input<span class="op">(</span><span class="st">&quot;Do you want to quit?&quot;</span><span class="op">,</span> <span class="st">&quot;YN&quot;</span><span class="op">);</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> input <span class="op">=</span> get_char_input<span class="op">(</span><span class="st">&quot;Choose menu item!&quot;</span><span class="op">,</span> <span class="st">&quot;AREPLUQ&quot;</span><span class="op">);</span></span></code></pre></div>
<p>In Rust</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> input <span class="op">=</span> get_char_input(msg(<span class="st">&quot;Do you want to quit?&quot;</span>)<span class="op">,</span> msg(<span class="st">&quot;YN&quot;</span>))<span class="op">;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> input <span class="op">=</span> get_char_input(msg(<span class="st">&quot;Choose menu item!&quot;</span>)<span class="op">,</span> msg(<span class="st">&quot;AREPLUQ&quot;</span>))<span class="op">;</span></span></code></pre></div>
<p>The code for this is almost given in the specification of this
assignment, so won’t be repeated here. However, the resulting code for
<code>main()</code> is nice. Here rewritten with a switch statement just
for fun, and the main menu printed in its own function:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> main<span class="op">(</span><span class="dt">void</span><span class="op">)</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">bool</span> should_quit <span class="op">=</span> false<span class="op">;</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">while</span> <span class="op">(!</span>should_quit<span class="op">)</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>          print_main_menu<span class="op">();</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>          <span class="cf">switch</span> <span class="op">(</span>get_char_input<span class="op">(</span><span class="st">&quot;Choose menu item!&quot;</span><span class="op">,</span> <span class="st">&quot;AREPLUQ&quot;</span><span class="op">))</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="ch">&#39;A&#39;</span><span class="op">:</span> add_action<span class="op">();</span>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="ch">&#39;R&#39;</span><span class="op">:</span> <span class="op">...</span>                          <span class="cf">break</span><span class="op">;</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="ch">&#39;E&#39;</span><span class="op">:</span> <span class="op">...</span>                          <span class="cf">break</span><span class="op">;</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="ch">&#39;P&#39;</span><span class="op">:</span> <span class="op">...</span>                          <span class="cf">break</span><span class="op">;</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="ch">&#39;L&#39;</span><span class="op">:</span> <span class="op">...</span>                          <span class="cf">break</span><span class="op">;</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="ch">&#39;U&#39;</span><span class="op">:</span> <span class="op">...</span>                          <span class="cf">break</span><span class="op">;</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">case</span> <span class="ch">&#39;Q&#39;</span><span class="op">:</span> should_quit <span class="op">=</span> quit_action<span class="op">();</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>In Rust</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> main () <span class="op">{</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> <span class="kw">mut</span> should_quit <span class="op">=</span> <span class="cn">false</span><span class="op">;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">while</span> should_quit <span class="op">==</span> <span class="cn">false</span> <span class="op">{</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>          print_main_menu()<span class="op">;</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>          <span class="cf">match</span> get_char_input(msg(<span class="st">&quot;Choose menu item!&quot;</span>)<span class="op">,</span> msg(<span class="st">&quot;AREPLUQ&quot;</span>)) <span class="op">{</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;A&quot;</span> <span class="op">=&gt;</span> add_action()                   <span class="op">,</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;R&quot;</span> <span class="op">=&gt;</span>  <span class="op">...</span>                           <span class="op">,</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;E&quot;</span> <span class="op">=&gt;</span>  <span class="op">...</span>                           <span class="op">,</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;P&quot;</span> <span class="op">=&gt;</span>  <span class="op">...</span>                           <span class="op">,</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;L&quot;</span> <span class="op">=&gt;</span>  <span class="op">...</span>                           <span class="op">,</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;U&#39;&quot;</span> <span class="op">=&gt;</span>  <span class="op">...</span>                          <span class="op">,</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>                <span class="st">&quot;Q&#39;&quot;</span> <span class="op">=&gt;</span>  should_quit <span class="op">=</span> quit_action()<span class="op">;</span> <span class="op">,</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>Now, we can compile and run the program again, and test that it works
to trigger <code>add_action()</code>, which will print “Add action is
not implemented yet”. Time to implement it!</p>
<h3 id="step-7-think-a-little-code-a-little-again">3.8 Step 7: Think a
little – Code a little (again)</h3>
<p>“Bad programmers worry about the code. Good programmers worry about
data structures and their relationships.”<br />
_ Linus Torvalds</p>
<p>A good candidate for this is adding a ware, because editing,
removing, listing, undoing, etc. all presuppose the existence of some
data in the database. Adding something new is often simpler than editing
or removing. This means that is a good place to start.</p>
<p>It is now time to go back to the specification again, and read about
the add action. We extend our mind-map accordingly:</p>
<figure>
<img src="http://wrigstad.com/ioopm/img3.png"
class="moz-reader-block-img" data-moz-reader-full-width="true"
data-moz-reader-center="true"
alt="Figure 4: Third mindmap of the program" />
<figcaption aria-hidden="true">Figure 4: Third mindmap of the
program</figcaption>
</figure>
<p>We have now arrived at a good place to do some <strong>data
design</strong>. In other programs, we might have started with that if
there weren’t any functions that did not manipulate any core data for
the program.</p>
<p>But what do we mean by <strong>core data</strong>?</p>
<p>Unsurprisingly, perhaps, the program’s <strong>core data</strong> is
the central data for the program. A complicated program might have tons
of different kinds of core data, but in our example, we are more lucky.
To understand a program’s core data, we simply <strong>mine the
specification</strong> again, this time looking for <a
href="http://en.wikipedia.org/wiki/Noun">nouns</a>.</p>
<p>Let’s do that now!</p>
<p>Again, for concreteness, I am copying in the specification and
highlighting as I go:</p>
<blockquote>
<p>Every <strong>ware</strong> in the warehouse has a
<strong>name</strong>, a <strong>description</strong>, a <strong>storage
location</strong>, a <strong>pricetag</strong>, information about the
<strong>number of items</strong> of the particular wares stored in the
warehouse, and the <strong>cost of each item</strong>. A storage
location is a <strong>section</strong> (a single letter a-z), plus a
<strong>shelf</strong> (an integer).</p>
<p>The simple warehouse program manages a <strong>database</strong> of
wares and supports the following operations:</p>
<ol type="1">
<li>Adding a <strong>ware</strong></li>
<li>Removing a <strong>ware</strong></li>
<li>Editing the information about a <strong>ware</strong></li>
<li>Printing the information for a specific <strong>ware</strong></li>
<li>Listing all wares in the <strong>database</strong></li>
<li>Undoing the last <strong>action</strong></li>
<li>Quitting the program</li>
</ol>
</blockquote>
<p>Looking at the highlighted information above, and reading the
surrounding text, a pattern emerges.</p>
<p>There is a <strong>database</strong>, which stores
<strong>wares</strong>, that each store name, description, storage
location, pricetag, and number of items.</p>
<p>There is also a mentioning of <strong>action</strong>, which makes
sense: in order to undo an action, we need to somehow record what the
program did just before, and enough information to undo it. We don’t
know exactly what this information is yet, but that’s fine.</p>
<p>It probably does not make sense to implement <code>undo</code> until
there are actions to be undone. (Read more in the aside below.)</p>
<p>The specification gives us a (mostly) very good idea for a data type
for <strong>ware</strong>. - Name and description are clearly strings. -
Price and number of items (which I will be calling amount from now on)
are clearly integers.</p>
<p>The storage location is less clear, however. Rather that getting
stuck on this detail, let’s cheat and assume that there is a type
<code>storage_location_t</code> that solves the problem.</p>
<p>Now, we can write the type for ware:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ware</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">char</span> <span class="op">*</span>description<span class="op">;</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>      storage_location_t storage_location<span class="op">;</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span>   price<span class="op">;</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span>   amount<span class="op">;</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<div class="sourceCode" id="cb32"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ware <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>      name<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>      description<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>      storage_location<span class="op">:</span> storage_location_t<span class="op">,</span> </span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>      price<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>      amount<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>By passing_the_buck a little, we now have a type <code>ware</code>.
However, in the interest of making progress and working in an
incremental fashion, we are also going to apply another great
simplification trick: <strong>dodging</strong>.</p>
<p>Getting information from the user at all is a great first step in an
incremental development methodology. Once that is done and works, we can
start caring about making sure that the information is correct.</p>
<p>It is time to <strong>dodge</strong>.</p>
<p>Dodging means <strong>temporarily</strong> simplifying the
specification.</p>
<p>In the current example, a good dodge is to say: for now, I am going
to only store string data in wares, and worry about integers and storage
locations later.</p>
<p>This allows us to use a single function for reading input from the
user to complete the entire specification for adding a ware, modulo
saving it to the database.</p>
<p>Temporarily, we change to type of <code>ware</code> to this:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ware</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">char</span> <span class="op">*</span>description<span class="op">;</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">char</span> <span class="op">*</span>storage_location<span class="op">;</span> <span class="co">// </span><span class="al">TODO</span><span class="co">: storage_location_t</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">char</span> <span class="op">*</span>price<span class="op">;</span>            <span class="co">// </span><span class="al">TODO</span><span class="co">: int</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">char</span> <span class="op">*</span>amount<span class="op">;</span>           <span class="co">// </span><span class="al">TODO</span><span class="co">: int</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>In Rust</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> ware <span class="op">{</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>      name<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>      description<span class="op">:</span> <span class="dt">String</span><span class="op">,</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>      storage_location<span class="op">:</span> <span class="dt">String</span><span class="op">,</span> <span class="co">// </span><span class="al">TODO</span><span class="co">: storage_location_t, </span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>      price<span class="op">:</span> <span class="dt">String</span><span class="op">,</span>            <span class="co">// </span><span class="al">TODO</span><span class="co">: i32,</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>      amount<span class="op">:</span> <span class="dt">String</span><span class="op">,</span>           <span class="co">// </span><span class="al">TODO</span><span class="co">: i32,</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>And then we can make a version of <code>get_char_input()</code>, for
example <code>get_string_input()</code>. We will probably also cheat and
assume its existence on the first pass through the code. We will also
cheat and assume the existence of a <code>add_to_db()</code> function,
which does nothing except prints out the obligatory disclaimer of it not
yet being implemented.</p>
<p>Here is a list of suitable steps for almost implementing
<code>add_action()</code>. Each step notably results in a program that
can compile and run, but probably does not do anything useful.</p>
<ol type="1">
<li><p>Read all the inputs as strings and save them into a ware object,
assuming the existance of several functions (This could quite possibly
be several increments.):</p>
<ol type="a">
<li><code>get_string_input()</code>,</li>
<li><code>print_ware()</code> (to print a ware to the user before
answering the save, edit, abort),</li>
<li><code>edit_ware()</code>, (for when the user selects edit above)
and</li>
<li><code>add_to_db()</code>.</li>
</ol></li>
<li><p>Implement <code>get_string_input()</code>.</p></li>
<li><p>Implement <code>edit_ware()</code>.</p></li>
<li><p>In 1. above, we are writing straight-line code. No loops, and the
only branching is the calls to <code>edit_ware()</code> and
<code>add_to_db()</code> based on the users input. This means we do not
yet implement the case where the user makes an edit, gets a printout and
makes the edit again. This support we add in this step.</p></li>
<li><p>Make price and amount ints in ware and replace the two calls to
<code>get_string_input()</code> with calls to an assumed
<code>get_int_input()</code>.</p></li>
<li><p>Implement <code>get_int_input()</code>.</p></li>
<li><p>Decide how to do the storage location. And implement that. This
is likely several steps given that we cheated on the type for storage
location before.</p></li>
</ol>
<p>The last thing we will do is to deal with the database – a final
piece of the puzzle missing to finish this action.</p>
<p>Attention</p>
<p><strong>Multiple Possible Ways Forward</strong></p>
<p>Undo is a good example of a choice in how we choose to go forward.
For example, we could chose to implement undo for each action that we
implement, i.e,. after add we implement undo add, after edit we
implement undo edit, etc. Or we simply wait until all actions are
implemented and implement undo for all of them in a single hit. There is
no right or wrong here, just two different ways of working, each with
its own merit. For example, it is easy to argue that implementing undo X
right after implementing X is the best way because at this point, we
probably have the best understanding of how X works. On the other hand,
it is easy to argue that if we implement the entire undo behaviour at
the same time, it is easier to come up with a clean design for it that
will work for all cases. If we started with a design for undo add, we
might not yet see all the information that must be saved. (For example,
undo edit will require us to store the original values of the edited
data!)</p>
<h3 id="step-8-think-a-little-code-a-little">3.9 Step 8: Think a Little
– Code a Little</h3>
<p>“Smart data structures and dumb code works a lot better than the
other way around.”<br />
_ Eric S. Raymond</p>
<p>Choosing the proper database design is of course very important for
the program at hand. There are multiple alternatives ranging from simple
to hard, for example:</p>
<ol type="1">
<li>A statically sized array of wares</li>
<li>A dynamically sized in-memory structure like a list or a tree</li>
<li>An external database back-end</li>
</ol>
<p>There is however one very important realisation at this stage and
that is that right now, <strong>it does not matter</strong> (right
now).</p>
<p>The rationale is that we are trying to piece by piece construct a
piece of software that fulfils the specification. We are just about to
wrap-up the part of the program that will be adding the first item in
the database. We don’t have the code to remove items, edit them, etc. So
really, we could not care less at this point how the database is
designed.</p>
<p>This is a great opportunity to dodge again. This time, we are going
to dodge in three discrete steps:</p>
<ol type="1">
<li>The database holds only one single element</li>
<li>The database is an array of fixed maximal size</li>
<li>Make the final decision once the program’s done otherwise</li>
</ol>
<p>The first database design will allow implementing everything except
adding and removing with multiple wares, and listing multiple wares. The
second design will allow us to do all that. The third design will make
the program less of a <a
href="http://www.catb.org/jargon/html/M/mickey-mouse-program.html"
target="_blank">Mickey Mouse program</a>.</p>
<p>Following the first database design, we can now define a struct for
the database like so:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> db</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> ware ware<span class="op">;</span> <span class="co">// </span><span class="al">TODO</span><span class="co">: improve later</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typedef</span> <span class="kw">struct</span> db db_t<span class="op">;</span></span></code></pre></div>
<p>In Rust</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> db</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> ware<span class="op">:</span> ware<span class="op">,</span> <span class="co">// </span><span class="al">TODO</span><span class="co">: improve later</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> db_t <span class="op">=</span> db<span class="op">;</span></span></code></pre></div>
<p>Now, we can finally finish the implementation of
<code>add_action()</code>. To do this, we will go through the program
and make a few simple changes:</p>
<ol type="1">
<li>We want to create a <code>db_t</code> value in main.</li>
<li>We want to pass a pointer to the <code>db_t</code> value to
<code>add_action()</code>.</li>
<li>We want to pass a pointer to the <code>db_t</code> value to
<code>add_to_db()</code>.</li>
</ol>
<p>Now we can implement <code>add_to_db()</code> like so:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> add_to_db<span class="op">(</span>db_t <span class="op">*</span>db<span class="op">,</span> <span class="kw">struct</span> ware ware<span class="op">)</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>      db<span class="op">-&gt;</span>ware <span class="op">=</span> ware<span class="op">;</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>In Rust</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    fn add_to_db<span class="op">(</span>db<span class="op">:</span> <span class="op">&amp;</span>db_t<span class="op">,</span> ware<span class="op">:</span> ware<span class="op">){</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>      db<span class="op">.</span>ware <span class="op">=</span> ware<span class="op">;</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>And now we are done with <code>add_action()</code>.</p>
<p>As we finish more actions and move on to the second database design,
we simply update struct db:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define Max_elements_in_db 128</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> db</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> ware wares<span class="op">[</span>Max_elements_in_db<span class="op">];</span> <span class="co">// </span><span class="al">TODO</span><span class="co">: improve later</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span> size<span class="op">;</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>In Rust</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> MAX_ELEMENTS_IN_DB<span class="op">:</span> <span class="dt">i32</span> <span class="op">=</span> <span class="dv">128</span><span class="op">:</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> db</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">struct</span> ware wares[MAX_ELEMENTS_IN_DB]<span class="op">,</span> <span class="co">// </span><span class="al">TODO</span><span class="co">: improve later</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>      size<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>That was easy, and now we can finalise more complex parts of out
program. Moreover, if we have isolated the how the database works from
the rest of the program correctly, only functions like
<code>add_to_db()</code> etc. will have to change as a result:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> add_to_db<span class="op">(</span>db_t <span class="op">*</span>db<span class="op">,</span> <span class="kw">struct</span> ware ware<span class="op">)</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Saves ware on the next available index and increase size by 1</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>      db<span class="op">-&gt;</span>wares<span class="op">[</span>db<span class="op">-&gt;</span>size<span class="op">++]</span> <span class="op">=</span> ware<span class="op">;</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>In Rust</p>
<p>TODO:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> add_to_db(db<span class="op">:</span> <span class="op">&amp;</span><span class="kw">mut</span> db_t<span class="op">,</span> ware<span class="op">:</span> ware)</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>      <span class="co">// Saves ware on the next available index and increase size by 1</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>      db<span class="op">.</span>wares[db<span class="op">.</span>size] <span class="op">=</span> ware<span class="op">;</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>      db<span class="op">.</span>size <span class="op">+=</span><span class="dv">1</span> <span class="co">//??</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h3 id="step-9-and-beyond">3.10 Step 9, and beyond</h3>
<p>“Controlling complexity is the essence of computer
programming.”<br />
_ Brian Kernighan</p>
<p>Think/code/refactor/remove cheats. Repeat until done. Find a good
balance.</p>
<h3 id="summary-and-conclusions">3.11 Summary and Conclusions</h3>
<p>“Those that can, do. Those that can’t, complain.”<br />
_ Linus Torvalds</p>
<p>Almost all hard problems can be broken down into less-hard
subproblems, which in turn can be broken down to even less-hard
subsubproblems, etc. After a while of breaking work down into smaller
and smaller tasks, the tasks finally become simple, and that is the
right time to start solving them. That’s SIMPLE in a nutshell.</p>
<p>As soon as we hit a bump in the road – a problem we don’t know
immediately how to solve, or don’t know how to solve well, or just
cannot be bothered with solving right now – we keep things simple by
passing_the_buck and dodging. We reserve ourselves that right by always
making clear notes about our cheats and dodges and by promising
ourselves that we will set things straight in the future. And by keeping
our promises.</p>
<h2 id="a-summary-of-simple-in-ten-steps">4 A Summary of SIMPLE in Ten
Steps</h2>
<dl>
<dt>Start with a high-level work breakdown structure</dt>
<dd>
Mine your specification for data (nouns) and actions (verbs –
behaviour/functions). Make simple drawings, e.g., mindmaps, to record
your insights. Making things look easy is almost always good.
</dd>
<dt>Write code to test the validity of your thinking</dt>
<dd>
…not to drive the thinking! Thinking should invariably come before
coding, especially thinking about how you check that your thinking is
valid.
</dd>
<dt>Always have a working program</dt>
<dd>
In combination with passing_the_buck, this usually means inserting dummy
functions.
</dd>
<dt>Compile after every change</dt>
<dd>
Fix errors now, not later. Fix errors one by one. Fix errors in the
order they were printed. Take time to actually read the compiler message
so you know you are fixing the right thing.
</dd>
<dt>Run the program “all the time” to spot errors</dt>
<dd>
This requires always working code – preferably in combination with
automated test that don’t involve ocular inspection, etc.
</dd>
<dt>Recursively break your problems up into smaller sub problems</dt>
<dd>
Only start solving problems when they start feeling easy. Make a task
for each problem or subproblem to put on the stack, take tasks from the
stack in a reasonable order (preferably easiest first); when the stack
is empty – you are done!
</dd>
<dt>Break each task up into increments and start with the easy ones</dt>
<dd>
Generate new tasks to put on the stack as you go. If suitable, start
with a straight-line version (without any if-statements). When the
straight-line version works add conditionals, one by one. Start with the
most basic or the most insteresting cases. When you are writing a loop,
do the above steps first and add the looping step last.
</dd>
<dt>Whenever you run the risk of getting stuck, cheat</dt>
<dd>
Don’t forget to push new tasks on the stack that undoes the
passing_the_buck, later. This records the cheat, which is great.
</dd>
<dt>Use dodging to help breaking complex cases up into several less
complex ones</dt>
<dd>
Don’t forget to push new tasks on the stack that undoes the dodge,
later. This records the dodge, which is great.
</dd>
<dt>Alternate between thinking, coding and refactoring</dt>
<dd>
<ul>
<li>thinking – not so much that you get stuck, though,</li>
<li>coding – but never without first thinking about what to code, and
occasionally</li>
<li>refactoring – especially to address your cheats and dodges.</li>
</ul>
<p>Refactoring is good to do between larger tasks. Make it a habit to
continuously go back and refactor your solutions so that recently gotten
insights rub off on older code too.</p>
</dd>
</dl>
<p>Note that this is a simple programming methodology, not a
fully-fledged software design methodology. This means that it will not
scale to “large” software, but will work fine for relatively simple
programs up to say a few thousand lines of code. Certain domains,
especially mathematical domains, might benefit from more advance
thinking before implementing because there are more “truths” in such
domains than in more fickle domains, especially ones involving human
users. Although the running example used a program with a user
interface, SIMPLE works equally well with non-UI programs.</p>
<figure>
<img src="http://wrigstad.com/ioopm18/images/everyone-can-code.jpg"
class="moz-reader-block-img" data-moz-reader-full-width="true"
data-moz-reader-center="true" alt="everyone-can-code.jpg" />
<figcaption aria-hidden="true">everyone-can-code.jpg</figcaption>
</figure>
<h2 id="tickets-tasks-and-post-it-stacks">5 Tickets, Tasks and Post-it
Stacks</h2>
<p>Programming with SIMPLE revolves around breaking problems down into
sets of smaller and smaller tasks. Actually, almost all programming
works like that.</p>
<p>Our first problem was “implement an information system for a
warehouse”. This is a very big and vague problem, so to solve it, we
perused the specification to find the top-level actions that the system
should support. We thus identified a set of tasks, one for each action,
and started working through the tasks one by one. We carefully chose the
order of tasks to make sure that we started as simple as possible and
never worked on a task that could not be a part of the running program
because it relied on another feature that wasn’t quite ready.</p>
<p>We are following a divide-and-conquer approach, where you recursively
break down tasks into increasingly smaller pieces until each piece is
trivially solvable. As is visible, from the steps above, we do not
strive to break everything down into simple problems. For example, we
started by doing <code>quit_action()</code> as soon as we realised it
was simple enough, without caring about breaking down everything else
first. The more you implement the program, the more you will understand
it. You will never understand the program less than right at the start –
therefore, trying to make a detailed planning with that limited
understanding is a bad idea. Instead, tasks will be created as part of
the implementation. At every step of the way, you will have a pile of
tasks to perform. When this pile is empty, you’re done.</p>
<p>The cases where tasks are created in SIMPLE are ideally:</p>
<ol type="1">
<li>As part of the initial identification of top-level tasks</li>
<li>As part of the data design</li>
<li>When you pick a task to implement, you usually start by breaking it
down into several smaller tasks</li>
<li>passing_the_buck creates a new task for the passing_the_buck
function</li>
<li>Dodging creates one or more new tasks to undo the
simplifications</li>
</ol>
<p>Naturally, tasks are sometimes created because you forgot to create
them elsewhere, or because of misunderstanding, etc.</p>
<p><strong>Actually having a physical pile of tasks in front of you is
not a bad idea.</strong> It is quite common in modern software
development organisations to rely heavily on post-it notes for task
planning and follow-up. You will have one or two post-it notes that you
are currently <strong>doing</strong>, a growing pile of post-it notes
that are <strong>done</strong>, and one pile that’s
<strong>next</strong>. Physically moving something from doing to done or
seeing a large stack of notes in the done pile is gratifying. Physically
moving something from next to doing reifies a commitment. Glancing at a
number of post-it notes in the next section of the paper or whiteboard
where you keep your tasks is a quick way to get an overview of where you
are headed.</p>
<p>Using a physical stack of post-it notes or some equivalent software
is an excellent way to manage the constantly growing and shrinking
tasks. Of course, adding notes in the code is great too, but why not
both.</p>
<p>Regardless of how you manage your tasks, an important question is
where you put new tasks when they are created – to the front (so they
are next in line) or to the back (so they won’t be dealt with for a
while). There is no simple rule but there is a SIMPLE guideline:
<strong>simpler tasks go in front of more complicated
tasks.</strong></p>
<p>When you test your software, you may run into bugs or defects which
aren’t of immediate importance. For each defect that you do not
immediately fix, create a ticket, and put that in the task queue. A
ticket is a task like any other, just one that’s about fixing something
that’s inadvertently broken. Creating tickets for defects is a good way
to avoid breaking the current flow by switching into debugging mode, and
helps us remember it so it eventually gets fixed.</p>
<h2 id="the-three-rules-of-passing_the_buck">6 The Three Rules of
passing_the_buck</h2>
<p>passing_the_buck is one of the best tools in the programming toolbox,
and a trick you should be using all the time. The rule of
passing_the_buck is this (also repeated above):</p>
<p>If you don’t know immediately how to solve a problem,<br />
assume the existence of a function<br />
that solves this problem for you,<br />
and call that function.<br />
</p>
<p>There is also a second rule of passing_the_buck:</p>
<p>If you write code that you think about as<br />
Step 1; Step 2; Step 3; … Step n,<br />
and one of the steps suddenly turns out to be<br />
way longer/more complicated/more involved than the others,<br />
assume the existence of a function that performs that step for
you,<br />
and call that function.<br />
</p>
<p>Finally, there is a third rule of passing_the_buck:</p>
<p>If you write straight-line code,<br />
and you suddenly come across a step that you<br />
just cannot be bothered with implementing right now,<br />
assume the existence of a function that performs that step for
you,<br />
and call that function.<br />
</p>
<p>(Yes – I deliberately formatted them as poems.)</p>
<p>In addition to help you stay focused on the control flow you are
implementing and not get stuck in details, passing_the_buck has the
automatic side-effect of breaking down your code into smaller chunks. It
also isolates trickier code inside single functions. For example, the
logic for reading user input is now nicely encapsulated inside the
<code>get_char_input()</code> function and we can solve this problem
completely in isolation of the rest of the code for quitting the program
although that code depends on it.</p>
<p>By giving a proper name to each function invented by
passing_the_buck, we make sure that the code reads more high-level, and
it also helps us remember what problem the function in question should
solve.</p>
<h2 id="dodging-not-quite-passing_the_buck">7 Dodging: Not Quite
passing_the_buck</h2>
<p>When doing the initial database design, we made proper use of dodging
twice to make immediate simplifications that help us make progress and
construct good increments. Here are two examples of dodging
guidelines:</p>
<p>If a feature has several similar yet not identical cases,<br />
start by reducing them to the most basic case<br />
and getting that to work.<br />
</p>
<p>and</p>
<p>If a feature involves a collection of objects,<br />
investigate whether starting with just a single object<br />
is possible and easier.<br />
</p>
<p>Dodging involves simplifying the requirements temporarily in order to
create a simpler specification. The word temporarily is key here, and it
is imperative that we have some system in place to help us remember what
simplifications we have made to make sure we roll them back at some
point and replace them (step by step) with the full specification.</p>
<p>By starting with a design of the ware struct where everything is a
string, we have reduced the number of different input methods for wares
from three to one, and also to the simplest one where input does not
need any real checking. This way, we can write a program in which the
user can input data into the database, and once that program is
sufficiently implemented, we can add more input methods and change the
types in the ware struct. Following the guidelines for increments, we
implement support for:</p>
<ol type="1">
<li>Name, description</li>
<li>Price, amount</li>
<li>Storage location</li>
</ol>
<p>in this very order, which is the ascending order of complexity. That
is is the fact is easy to see: all input is a valid string; integer
input may fail if the user types something other than a number; storage
location requires two different inputs to be correct.</p>
<p>Finally, by starting with a database with only one item we have just
enough to be able to have a working program in which we do pretty much
everything except have more than one ware in the database. The logic for
everything except writing to the database should be exactly the same for
the entire program regardless of whether the database is an array of
wares, a binary tree, etc.</p>
</main>
<p>SOURCE:<br />
These are the pages for a one-semester course at 67% speed on imperative
and object-oriented programming at the <a href="http://it.uu.se/"
target="_blank">department of Information Technology</a> at <a
href="http://www.uu.se/" target="_blank">Uppsala University</a>, ran by
<a href="http://wrigstad.com/" target="_blank">Tobias Wrigstad</a>.</p>
</body>
</html>
