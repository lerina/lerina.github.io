<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>fastpaced_rust01 fastpaced_rust01</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../../../../css/styling.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#level-01" id="toc-level-01">Level 01</a>
<ul>
<li><a href="#data-take-one" id="toc-data-take-one">Data: take
one</a></li>
<li><a href="#input---output-terminal"
id="toc-input---output-terminal">Input - Output: Terminal</a></li>
<li><a href="#processing" id="toc-processing">Processing</a></li>
</ul></li>
<li><a href="#level-02" id="toc-level-02">Level 02</a>
<ul>
<li><a href="#data-take-two" id="toc-data-take-two">Data: Take
two</a></li>
<li><a href="#input-output-working-with-files-and-directories"
id="toc-input-output-working-with-files-and-directories">Input-Output:
Working with files and directories</a></li>
<li><a href="#processing-1" id="toc-processing-1">Processing</a></li>
</ul></li>
<li><a href="#level-03" id="toc-level-03">Level 03</a>
<ul>
<li><a href="#data-take-three" id="toc-data-take-three">Data: Take
three</a></li>
<li><a href="#input-output" id="toc-input-output">Input-output:</a></li>
<li><a href="#processing-2" id="toc-processing-2">Processing</a></li>
</ul></li>
<li><a href="#level-04" id="toc-level-04">Level 04</a></li>
</ul>
</nav>
<div class="bg_rustNfriends">

</div>
<div class="navbar">
<a class="openbtn" onclick="openNav()">☰</a>
</div>
<main>
<blockquote>
<p>Installing Rust on Linux, macOS, and Windows</p>
<p>See <a
href="https://doc.rust-lang.org/book/ch01-00-getting-started.html">Getting
Started</a> from The Rust Programming Language book at
doc.rust-lang.org</p>
</blockquote>
<h1 id="level-01">Level 01</h1>
<h2 id="data-take-one">Data: take one</h2>
<p>When it comes to Software, everything is Data and the access to its
storage.</p>
<p>Programming is about Data and its manupulation Besides it value, all
Data has a <strong>type</strong> whether it is explicit or not.</p>
<blockquote>
<p>Rust is a statically typed language, which means that it must know
the types of all variables at compile time.<br />
The compiler can usually infer what type we want to use based on the
value and how we use it.<br />
_ rustbook</p>
</blockquote>
<p>see also: <a
href="https://doc.rust-lang.org/stable/book/ch03-02-data-types.html">Rust
built-in types</a></p>
<h3 id="scalar-types">Scalar Types</h3>
<h4 id="integers">Integers</h4>
<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 26%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th>Length</th>
<th>Signed</th>
<th>Unsigned</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>8-bit</td>
<td><a
href="https://doc.rust-lang.org/std/primitive.i8.html">i8</a></td>
<td><a
href="https://doc.rust-lang.org/std/primitive.u8.html">u8</a></td>
</tr>
<tr class="even">
<td>16-bit</td>
<td><a
href="https://doc.rust-lang.org/std/primitive.i16.html">i16</a></td>
<td><a
href="https://doc.rust-lang.org/std/primitive.u16.html">u16</a></td>
</tr>
<tr class="odd">
<td>32-bit</td>
<td><a
href="https://doc.rust-lang.org/std/primitive.i32.html">i32</a></td>
<td><a
href="https://doc.rust-lang.org/std/primitive.u32.html">u32</a></td>
</tr>
<tr class="even">
<td>64-bit</td>
<td><a
href="https://doc.rust-lang.org/std/primitive.i64.html">i64</a></td>
<td><a
href="https://doc.rust-lang.org/std/primitive.u64.html">u64</a></td>
</tr>
<tr class="odd">
<td>128-bit</td>
<td><a
href="https://doc.rust-lang.org/std/primitive.i128.html">i128</a></td>
<td><a
href="https://doc.rust-lang.org/std/primitive.u128.html">u128</a></td>
</tr>
<tr class="even">
<td>arch</td>
<td><a
href="https://doc.rust-lang.org/std/primitive.isize.html">isize</a></td>
<td><a
href="https://doc.rust-lang.org/std/primitive.usize.html">usize</a></td>
</tr>
</tbody>
</table>
<p>integers default to <a
href="https://doc.rust-lang.org/std/primitive.i32.html#implementations">i32</a></p>
<blockquote>
<p>isize and usize types depend on the architecture of the computer your
program is running on,<br />
which is denoted in the table as “arch”:<br />
64 bits if you’re on a 64-bit architecture and 32 bits if you’re on a
32-bit architecture.<br />
_ rustbook</p>
</blockquote>
<h5 id="integer-literals-in-rust">Integer Literals in Rust</h5>
<blockquote>
<p>You can write integer literals in any of the forms shown in Table
3-2. Note that number literals that can be multiple numeric types allow
a type suffix, such as 57u8, to designate the type. Number literals can
also use _ as a visual separator to make the number easier to read, such
as 1_000, which will have the same value as if you had specified 1000. _
rustbook</p>
</blockquote>
<table>
<thead>
<tr class="header">
<th>Number literals</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Decimal</td>
<td>98_222</td>
</tr>
<tr class="even">
<td>Hex</td>
<td>0xff</td>
</tr>
<tr class="odd">
<td>Octal</td>
<td>0o77</td>
</tr>
<tr class="even">
<td>Binary</td>
<td>0b1111_0000</td>
</tr>
<tr class="odd">
<td>Byte (u8 only)</td>
<td>b’A’</td>
</tr>
</tbody>
</table>
<h4 id="floats">Floats</h4>
<p>Rust’s floating-point types are <a
href="https://doc.rust-lang.org/std/primitive.f32.html">f32 (32
bits)</a> and <a href="https://doc.rust-lang.org/std/primitive.f64.html"
target="_blank">f64 (64 bits)</a> .</p>
<p>All floating-point types are signed.</p>
<p>Floats defaults to <a
href="https://doc.rust-lang.org/std/primitive.f64.html#implementations">f64</a></p>
<blockquote>
<p>The default type is f64 because on modern CPUs it’s roughly the same
speed as f32 but is capable of more precision.<br />
_ rustbook</p>
</blockquote>
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">42.0</span><span class="op">;</span> <span class="co">// f64</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> y<span class="op">:</span> <span class="dt">f32</span> <span class="op">=</span> <span class="dv">42.0</span><span class="op">;</span> <span class="co">// f32</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Also have a look at the Basic mathematical constants at <a
href="https://doc.rust-lang.org/std/f32/consts/index.html">std::f32::consts</a>
and <a
href="https://doc.rust-lang.org/std/f64/consts/index.html">std::f64::consts</a></p>
<h4 id="bool">bool</h4>
<p>Booleans are one byte in size. Two possible values: <code>true</code>
and <code>false</code></p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> water_is_wet <span class="op">=</span> <span class="cn">true</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> fire_is_wet <span class="op">=</span> <span class="cn">false</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> f<span class="op">:</span> <span class="dt">bool</span> <span class="op">=</span> <span class="cn">false</span><span class="op">;</span> <span class="co">// with explicit type annotation</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="character">Character</h4>
<p><code>char</code> type represents a single character, a ‘Unicode
scalar value’.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> infinity<span class="op">:</span> <span class="dt">char</span> <span class="op">=</span> <span class="ch">&#39;</span><span class="sc">\u{267E}</span><span class="ch">&#39;</span><span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> the_one <span class="op">=</span> <span class="ch">&#39;♾&#39;</span><span class="op">;</span></span></code></pre></div>
<p>also see: <a
href="https://doc.rust-lang.org/std/primitive.char.html">char</a><br />
<a href="https://unicode-table.com/en/">unicode table</a></p>
<h3 id="mutability">Mutability</h3>
<p>Variables are immutable by default, mutable explicitly</p>
<blockquote>
<p>When a variable is immutable, once a value is bound to a name, you
can’t change that value.<br />
_ rustbook</p>
</blockquote>
<h4 id="mut-keyword"><code>mut</code> keyword</h4>
<p>You can make them mutable by adding mut in front of the variable
name. Adding mut also conveys intent to future readers of the code by
indicating</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> var01<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> var02<span class="op">;</span></span></code></pre></div>
<p>Once we bind a value to var01 or var02 they will acquire a type and a
value.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>var01 <span class="op">=</span> <span class="dv">12</span><span class="op">;</span>     <span class="co">// integers </span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>var02 <span class="op">=</span> <span class="dv">41</span><span class="op">;</span>     <span class="co">// defaults to i32</span></span></code></pre></div>
<p>However var01 is immutable whereas var02 can be reassigned a value …
<strong>of the same type</strong>.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// var01 = 42;  //ERROR var01 immutable</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>var02 <span class="op">=</span> var01 <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Ok</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(var02)<span class="op">;</span> <span class="co">// 42</span></span></code></pre></div>
<p>We can declare and define our variable at the same time</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> var01 <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> var02 <span class="op">=</span> <span class="dv">41</span><span class="op">;</span></span></code></pre></div>
<p>We can also explicitly annotate the type</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ascii<span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> <span class="dv">255</span><span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> var02<span class="op">:</span> <span class="dt">i64</span> <span class="op">=</span> <span class="dv">41</span><span class="op">;</span> <span class="co">// default would be i32 so we have to be explicit if we don&#39;t  want i32</span></span></code></pre></div>
<h3 id="collection-types">Collection Types</h3>
<h4 id="array">Array</h4>
<blockquote>
<p>The Array Type An array is a collection of elements of the same type
allocated in a contiguous memory block.</p>
</blockquote>
<p>Every element of an array must have the same type.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> my_array <span class="op">=</span> [<span class="dv">0.07</span><span class="op">,</span> <span class="dv">1.2</span><span class="op">,</span> <span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.1415</span><span class="op">,</span> <span class="dv">4.2</span>]<span class="op">;</span></span></code></pre></div>
<p>Arrays in Rust have a fixed length.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a<span class="op">:</span> [<span class="dt">i32</span><span class="op">;</span> <span class="dv">5</span>]<span class="op">;</span> <span class="co">// type and size of the array</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span></code></pre></div>
<p>We can initialize an array to contain the same value for each
element</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> five_ones <span class="op">=</span> [<span class="dv">1</span><span class="op">;</span> <span class="dv">5</span>]<span class="op">;</span> <span class="co">// [1, 1, 1, 1, 1]</span></span></code></pre></div>
<p>You can access elements of an array using indexing</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> first <span class="op">=</span> a[<span class="dv">0</span>]<span class="op">;</span> <span class="co">// 1</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> second <span class="op">=</span> a[<span class="dv">1</span>]<span class="op">;</span> <span class="co">// 2</span></span></code></pre></div>
<p>A mutable array means the elements are mutable. But the array size
cannot.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> array<span class="op">:</span> [<span class="dt">u8</span><span class="op">;</span> <span class="dv">3</span>] <span class="op">=</span> [<span class="dv">0</span><span class="op">;</span> <span class="dv">3</span>]<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;;T -1: {}, {}, {}&quot;</span><span class="op">;,</span> array[<span class="dv">0</span>]<span class="op">,</span> array[<span class="dv">1</span>]<span class="op">,</span> array[<span class="dv">2</span>])<span class="op">;</span> <span class="co">// T -1: 0, 0, 0</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    array[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    array[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    array[<span class="dv">2</span>] <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;;{}, {}, {} Lift Off!&quot;</span><span class="op">;,</span> array[<span class="dv">0</span>]<span class="op">,</span> array[<span class="dv">1</span>]<span class="op">,</span> array[<span class="dv">2</span>])<span class="op">;</span> <span class="co">// 3, 2, 1 Lift Off!</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>See vectors for a dynamic size array like type.</p>
<h4 id="the-tuple-type">The Tuple Type</h4>
<p>A tuple is a general way of grouping together a number of values with
a variety of types into one compound type. Tuples have a fixed length:
once declared, they cannot grow or shrink in size.<br />
_ rustbook</p>
<blockquote>
<p>fixed-length collections of values of different types.</p>
</blockquote>
<div class="sourceCode" id="cb14"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tup<span class="op">:</span> (<span class="dt">i32</span><span class="op">,</span> <span class="dt">f64</span><span class="op">,</span> <span class="dt">u8</span>) <span class="op">=</span> (<span class="dv">500</span><span class="op">,</span> <span class="dv">6.4</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span> <span class="co">// mixed datatype</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> middle <span class="op">=</span> tup<span class="op">.</span><span class="dv">1</span> <span class="co">// starts at index 0</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(middle)<span class="op">;</span> <span class="co">// 6.4</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (x<span class="op">,</span> y<span class="op">,</span> z) <span class="op">=</span> tup<span class="op">;</span> <span class="co">// unpack</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;The value of y is: {}&quot;</span><span class="op">,</span> y)<span class="op">;</span></span></code></pre></div>
<h4 id="vector">Vector</h4>
<p>A vector is a contiguous re-sizable array type.</p>
<h3 id="slice-str-and-strings">Slice, &amp;str and Strings</h3>
<h4 id="slice">Slice</h4>
<p>Slices act like temporary views into an array. It works by storing a
reference to the first element and a length. Hence all the elements must
be of the same type.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> my_arr <span class="op">=</span> [<span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="dv">40</span><span class="op">,</span> <span class="dv">50</span>]<span class="op">;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> my_slice <span class="op">=</span> <span class="op">&amp;</span>my_arr[<span class="dv">2</span><span class="op">..</span>]<span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> my_arr[<span class="dv">0</span>])<span class="op">;</span> <span class="co">// output: 10</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> my_slice[<span class="dv">0</span>])<span class="op">;</span> <span class="co">// output: 30</span></span></code></pre></div>
<h4 id="string-literal-str">string literal: <code>&amp;str</code></h4>
<p>A string literal &amp;str is a slice <code>&amp;[u8]</code>. In Rust
we call this a string slice or s_tuh_rrr.</p>
<p>Use it if you just need an immutable string or a part of a
string.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> name <span class="op">=</span> <span class="st">&quot;Rust 🦀&quot;</span><span class="op">;</span> <span class="co">// bind the string literal to variable `name`</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> msg<span class="op">:</span> <span class="op">&amp;</span><span class="dt">str</span> <span class="op">=</span> <span class="st">&quot;Trust&quot;</span><span class="op">;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;In {} we {}&quot;</span><span class="op">,</span> name<span class="op">,</span> msg)<span class="op">;</span> <span class="co">// output: In Rust 🦀 we Trust</span></span></code></pre></div>
<p>It is allocated on the stack as UTF-8 sequence. The stack is parts of
memory available to your code to use at runtime. The size of &amp;str is
fixed, meaning it cannot be resized.</p>
<h4 id="string-allocation-on-the-heap">String: Allocation on the
heap</h4>
<p>A String is stored on the Heap as a vector of bytes
<code>Vec&lt;u8&gt;</code> and is encoded in UTF 8 sequence. The heap is
another parts of memory available to your code to use at runtime. Heap
allocation allows for growable, mutable strings.</p>
<p>The data present in the string can be viewed using &amp;str.</p>
<p>Creates a new empty String</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> more_useful <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co">// if you can allocate upfront enough capacity to store your data Use with_capacity.</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">// </span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="co">// After the inital allocation, no memory allocated until it need more than 25</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> I_know_my_initial_max_size <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>with_capacity(<span class="dv">25</span>)<span class="op">;</span></span></code></pre></div>
<p>The are different ways to crate a String from a literal string. Here
are the most common ones.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> s1 <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hello, world!&quot;</span>)<span class="op">;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> s2 <span class="op">=</span> <span class="st">&quot;Hello again&quot;</span><span class="op">.</span>to_string()<span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> s3 <span class="op">=</span> <span class="st">&quot;this used to be faster but to_string caught up.&quot;</span><span class="op">.</span>to_owned()<span class="op">;</span></span></code></pre></div>
<p>Note that earler versions of Rust favored using
<code>to_owned()</code> over <code>to_string()</code>. Back then
to_owned was faster.</p>
<p>also see: <a
href="https://doc.rust-lang.org/stable/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">Storing
UTF-8 Encoded Text with Strings</a></p>
<h2 id="input---output-terminal">Input - Output: Terminal</h2>
<h3 id="writing-to-the-terminal">Writing to the Terminal</h3>
<h4 id="println">println!()</h4>
<div class="sourceCode" id="cb19"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Hello world&quot;</span>)<span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> message <span class="op">=</span> <span class="st">&quot;Use `println!` to display text to the console&quot;</span><span class="op">;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;The message is {}&quot;</span><span class="op">,</span> message)<span class="op">;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> new_message <span class="op">=</span> <span class="st">&quot;Additional simpler formatting strings starting with Rust 1.58&quot;</span> </span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;The message is {new_message}&quot;</span>)<span class="op">;</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>For more on string interpolation : // <a
href="https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html#captured-identifiers-in-format-strings">Announcing
Rust 1.58.0</a></p>
<p>see also:<br />
<a href="https://doc.rust-lang.org/std/macro.print.html">print!()</a>.
It’s equivalent to println!() except that a newline is not printed at
the end of the message.<br />
<a href="https://doc.rust-lang.org/std/macro.eprint.html">eprint!()</a>
to print error and progress messages.</p>
<h3 id="reading-user-input-from-the-terminal">Reading User Input from
the Terminal</h3>
<p>To receive keyboard input, we bring <code>std::io::stdin</code> into
scope with the <code>use</code> keyword. This gives us access to <a
href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line">read_line</a>
method.</p>
<p><code>read_line</code> takes whatever the user types into standard
input and append that into a mutable string, so it takes a mutable
reference to that string as an argument. A mutable reference is noted
<code>&amp;mut</code>. This will be explained in the topic
<strong>Ownership and Borrowing</strong> later.</p>
<h4 id="user-input-is-read-into-a-string">user input is read into a
String</h4>
<div class="sourceCode" id="cb20"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::io::</span>stdin<span class="op">;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Please enter some text: &quot;</span>)<span class="op">;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> user_input <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    stdin()</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>read_line(<span class="op">&amp;</span><span class="kw">mut</span> user_input)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>expect(<span class="st">&quot;Failed to read line&quot;</span>)<span class="op">;</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> user_input)<span class="op">;</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="converting-strings-into-other-types">Converting Strings into
other types</h4>
<h5 id="convert-to-numbers">Convert to numbers</h5>
<div class="sourceCode" id="cb21"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">use</span> <span class="pp">std::io::</span>stdin<span class="op">;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Please enter a number: &quot;</span>)<span class="op">;</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> user_input <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    stdin()</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>read_line(<span class="op">&amp;</span><span class="kw">mut</span> user_input)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>expect(<span class="st">&quot;Failed to read line&quot;</span>)<span class="op">;</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> my_int<span class="op">:</span> <span class="dt">u32</span> <span class="op">=</span> user_input</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>trim()</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>parse()</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>                        <span class="op">.</span>expect(<span class="st">&quot;Please type a number!&quot;</span>)<span class="op">;</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{0} + {0} = {1}&quot;</span><span class="op">,</span> my_int<span class="op">,</span> my_int<span class="op">+</span>my_int)<span class="op">;</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="processing">Processing</h2>
<h3 id="basic-mathematical-operations">Basic mathematical
operations</h3>
<div class="sourceCode" id="cb22"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// addition</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> sum <span class="op">=</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// subtraction</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> difference <span class="op">=</span> <span class="dv">95.5</span> <span class="op">-</span> <span class="dv">4.3</span><span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// multiplication</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> product <span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> <span class="dv">30</span><span class="op">;</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// division</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> quotient <span class="op">=</span> <span class="dv">56.7</span> <span class="op">/</span> <span class="dv">32.2</span><span class="op">;</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> floored <span class="op">=</span> <span class="dv">2</span> <span class="op">/</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// Results in 0</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// remainder</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> remainder <span class="op">=</span> <span class="dv">43</span> <span class="op">%</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>NOTE:<br />
Programming languages often use <code>^</code> or <code>**</code> for
power_of (exponent). This is not used in rust.<br />
Instead the numerical type has a method for it.<br />
such as <a
href="https://doc.rust-lang.org/std/primitive.f32.html#method.powi">powi</a>
and <a
href="https://doc.rust-lang.org/std/primitive.f32.html#method.powf">powf</a>
for the <code>f32</code> type.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x<span class="op">:</span> <span class="dt">f32</span> <span class="op">=</span> <span class="dv">2.0</span><span class="op">;</span> </span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>( x<span class="op">.</span>powi(<span class="dv">2</span>) )<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>( x<span class="op">.</span>powf(<span class="dv">2.0</span>) )<span class="op">;</span></span></code></pre></div>
<h3 id="working-with-strings-take-two">Working with strings: Take
two</h3>
<h4 id="working-with-text-useful-conversions">Working with text: Useful
conversions</h4>
<pre><code>&amp;str    -&gt; String  | String::from(s) or s.to_string() or s.to_owned()
&amp;str    -&gt; &amp;[u8]   | s.as_bytes()
&amp;str    -&gt; Vec&lt;u8&gt; | s.as_bytes().to_vec() or s.as_bytes().to_owned()
String  -&gt; &amp;str    | &amp;s if possible* else s.as_str()
String  -&gt; &amp;[u8]   | s.as_bytes()
String  -&gt; Vec&lt;u8&gt; | s.into_bytes()
&amp;[u8]   -&gt; &amp;str    | s.to_vec() or s.to_owned()
&amp;[u8]   -&gt; String  | std::str::from_utf8(s).unwrap()
&amp;[u8]   -&gt; Vec&lt;u8&gt; | String::from_utf8(s).unwrap()
Vec&lt;u8&gt; -&gt; &amp;str    | &amp;s if possible* else s.as_slice()
Vec&lt;u8&gt; -&gt; String  | std::str::from_utf8(&amp;s).unwrap()
Vec&lt;u8&gt; -&gt; &amp;[u8]   | String::from_utf8(s).unwrap()

* target should have explicit type (i.e., checker can&#39;t infer that)</code></pre>
<p>source: <a
href="https://vastorigins.com/2021/09/22/converting-rust-string-to-and-from/">Converting
Rust String To And From</a></p>
<h4 id="append-to-string">Append to string</h4>
<h5 id="using-the-push_str">Using the <code>push_str</code></h5>
<div class="sourceCode" id="cb25"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;On your mark&quot;</span>)<span class="op">;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>s<span class="op">.</span>push_str(<span class="st">&quot;, get set&quot;</span>)<span class="op">;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{s}&quot;</span>)<span class="op">;</span> <span class="co">// On your mark, get set</span></span></code></pre></div>
<h5 id="using-the">Using the <code>+</code></h5>
<div class="sourceCode" id="cb26"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> s2 <span class="op">=</span> s <span class="op">+</span> <span class="st">&quot; -&gt; GO!&quot;</span><span class="op">;</span> <span class="co">// The String type comes before the str</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{s2}&quot;</span>)<span class="op">;</span> <span class="co">// On your mark, get set -&gt; GO!</span></span></code></pre></div>
<h5 id="using-format-to-get-a-string">Using <code>format!()</code> to
get a String</h5>
<div class="sourceCode" id="cb27"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> s3 <span class="op">=</span> <span class="pp">format!</span>(<span class="st">&quot;{} - {} = {}&quot;</span><span class="op">,</span> <span class="st">&quot;1&quot;</span><span class="op">,</span> <span class="st">&quot;2&quot;</span><span class="op">,</span> <span class="st">&quot;3&quot;</span>)<span class="op">;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{s3}&quot;</span>)<span class="op">;</span> <span class="co">// 1 + 2  = 3</span></span></code></pre></div>
<h5 id="using-concat-to-get-a-str">Using <code>concat!()</code> to get a
str</h5>
<div class="sourceCode" id="cb28"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> s4 <span class="op">=</span> <span class="pp">concat!</span>(<span class="st">&quot;last&quot;</span><span class="op">,</span> <span class="st">&quot;name&quot;</span>)<span class="op">;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;{s4}&quot;</span>)<span class="op">;</span> <span class="co">// lastname</span></span></code></pre></div>
<h4 id="convert-to-characters">Convert to characters</h4>
<div class="sourceCode" id="cb29"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Please enter a word: &quot;</span>)<span class="op">;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> user_input <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    stdin()</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>read_line(<span class="op">&amp;</span><span class="kw">mut</span> user_input)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>expect(<span class="st">&quot;Failed to read line&quot;</span>)<span class="op">;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> ch<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> user_input<span class="op">.</span>chars()<span class="op">.</span>collect()<span class="op">;</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;the first char is {}&quot;</span><span class="op">,</span> ch[<span class="dv">0</span>])<span class="op">;</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ch <span class="kw">in</span> user_input<span class="op">.</span>chars()<span class="op">.</span><span class="pp">collect::</span><span class="op">&lt;</span><span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&gt;</span>() <span class="op">{</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> ch)<span class="op">;</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> ch <span class="kw">in</span> user_input<span class="op">.</span>chars() <span class="op">{</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> ch)<span class="op">;</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (i<span class="op">,</span>ch) <span class="kw">in</span> user_input<span class="op">.</span>chars()<span class="op">.</span>enumerate() <span class="op">{</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{} {}&quot;</span><span class="op">,</span> i<span class="op">,</span> ch)<span class="op">;</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>.chars() converts the string to a char iterator</p>
<p>.collect() converts the iterator to a collection</p>
<h3 id="code-block-scope-and-functions">Code block, scope and
functions</h3>
<p>A scope is the range within a program for which an item is valid.</p>
<p>Like a lot of programming languages, a pair of brackets declares a
block of code with its own scope. Variables remains valid from the point
at which it is declared until it goes out of scope</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">// This prints &quot;in&quot;, then &quot;out&quot;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="st">&quot;out&quot;</span><span class="op">;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// this is a different `x`</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> x <span class="op">=</span> <span class="st">&quot;in&quot;</span><span class="op">;</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>        <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> x)<span class="op">;</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{}&quot;</span><span class="op">,</span> x)<span class="op">;</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Unlike most other languages brackets delimited blocks are also
expressions. An expression evaluate to a value.</p>
<h4 id="user-defined-functions">user defined functions</h4>
<p>see also: <a
href="https://doc.rust-lang.org/stable/book/ch03-03-how-functions-work.html"
target="_blank">Functions in Rust</a></p>
<p>The <code>fn</code> keyword is used to declare new functions.</p>
<blockquote>
<p>Rust code uses snake case as the conventional style for function and
variable names, in which all letters are lowercase and underscores
separate words.<br />
_ rustbook</p>
</blockquote>
<div class="sourceCode" id="cb31"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">// program entry function is main</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>)<span class="op">;</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    another_function()<span class="op">;</span> <span class="co">//user defined function called (used) here</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="co">// user defined function declared and defined here</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> another_function() <span class="op">{</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;Another function.&quot;</span>)<span class="op">;</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="function-parameters-and-call-arguments">Function parameters and
call arguments</h4>
<blockquote>
<p>We can define functions to have parameters, which are special
variables that are part of a function’s signature. When a function has
parameters, you can provide it with concrete values for those
parameters. Technically, the concrete values are called arguments, but
in casual conversation, people tend to use the words parameter and
argument interchangeably for either the variables in a function’s
definition or the concrete values passed in when you call a
function.<br />
_ rustbook</p>
</blockquote>
<div class="sourceCode" id="cb32"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> y <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> answer <span class="op">=</span> double_me(x) <span class="op">+</span> double_me(y)<span class="op">;</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{} is the answer&quot;</span><span class="op">,</span> answer)<span class="op">;</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> double_me(a<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    x<span class="op">*</span><span class="dv">2</span>  <span class="co">// last line without `;` same as `return x*2;`</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>let’s make a better usage of this function and also remove
unnecessary bindings inside the fuction</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> y <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> answer <span class="op">=</span> double_me(x <span class="op">+</span> y)<span class="op">;</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{} is the answer&quot;</span><span class="op">,</span> answer)<span class="op">;</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> double_me(a<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    a<span class="op">*</span><span class="dv">2</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Lets include an add function</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> y <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> answer <span class="op">=</span> add_me(double_me(x)<span class="op">,</span>  double_me(y))<span class="op">;</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;{} is the answer&quot;</span><span class="op">,</span> answer)<span class="op">;</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span>  add_me(x<span class="op">:</span> <span class="dt">i32</span><span class="op">,</span> y<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>    x<span class="op">+</span>y</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> double_me(a<span class="op">:</span> <span class="dt">i32</span>) <span class="op">-&gt;</span> <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    a<span class="op">*</span><span class="dv">2</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h1 id="level-02">Level 02</h1>
<h2 id="data-take-two">Data: Take two</h2>
<h3 id="stack-and-heap-memory">Stack and Heap memory</h3>
<p>The stack and the heap are parts of memory available to your code to
use at runtime.</p>
<h4 id="the-stack">The stack</h4>
<p>The stack stores values in a last in, first out. But more
importantly,<br />
data stored on the stack must have a known, fixed size.</p>
<h4 id="the-heap">The heap</h4>
<p>Data with an unknown size at compile time or a size that might change
must be stored on the heap instead. Putting data on the heap entails a
request for a certain amount of space in memory. The memory allocator
finds an empty spot in the heap that is big enough, marks it as being in
use, and returns a pointer, which is the address of that location. The
pointer to the heap is known, has fixed size and thus is stored on the
stack. The actual data will be on the head as its sizer may not be know
at compile time and or it may grow or shrink during run time. Thus
access to the data is via the pointer.</p>
<h3 id="ownership-and-borrowing">Ownership and Borrowing</h3>
<p>Ownership is how Rust make memory safety guarantees without needing a
garbage collector. It is a set of rules that governs how a Rust program
manages memory and verified at compile time.</p>
<p>Rust is a systems programming language. Understanding what <a
href="https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html#the-stack-and-the-heap"
target="_blank">The Stack and the Heap</a> are is important.</p>
<h4 id="ownership">Ownership</h4>
<p>Ownership Rules::</p>
<pre><code>Each value in Rust has a variable that’s called its owner.
There can only be one owner at a time.
When the owner goes out of scope, the value will be dropped.</code></pre>
<h4 id="move-copie-and-clone">Move, copie and clone</h4>
<h4 id="borrowing-and-references">Borrowing and References</h4>
<p>Ownership of a value can be transferred temporarily to an entity and
then returned to the original owner entity. We call this borrowing and
it is done through references denoted by <code>&amp;</code> before the
variable name.</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> my_var <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> my_ref <span class="op">=</span> <span class="op">&amp;</span>my_var<span class="op">;</span></span></code></pre></div>
<p>Borrowing rules::</p>
<pre><code>Either have multiple immutable (&amp;my_var) borrows
OR exclusively one mutable (&amp;mut my_var) borrow
References cannot outlive what it is refering too</code></pre>
<h2 id="input-output-working-with-files-and-directories">Input-Output:
Working with files and directories</h2>
<h3 id="reading-a-file">Reading a file</h3>
<h3 id="writing-to-a-file">Writing to a file</h3>
<h3 id="navigating-the-directory-path">Navigating the directory
path</h3>
<h2 id="processing-1">Processing</h2>
<h3 id="conditionals">Conditionals</h3>
<h3 id="loops">Loops</h3>
<h3 id="matching">Matching</h3>
<h1 id="level-03">Level 03</h1>
<h2 id="data-take-three">Data: Take three</h2>
<h3 id="traits-and-behaviour">Traits and behaviour</h3>
<h3 id="generics">Generics</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 21%" />
<col style="width: 27%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Rust</th>
<th style="text-align: left;">C++</th>
<th style="text-align: left;">comment</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">a: &amp;T</td>
<td style="text-align: left;">const T* const a;</td>
<td style="text-align: left;">// can’t mutate either</td>
</tr>
<tr class="even">
<td style="text-align: left;">mut a: &amp;T</td>
<td style="text-align: left;">const T* a;</td>
<td style="text-align: left;">// can’t mutate what is pointed to</td>
</tr>
<tr class="odd">
<td style="text-align: left;">a: &amp;mut T</td>
<td style="text-align: left;">T* const a;</td>
<td style="text-align: left;">// can’t mutate pointer</td>
</tr>
<tr class="even">
<td style="text-align: left;">mut a: &amp;mut T</td>
<td style="text-align: left;">T* a;</td>
<td style="text-align: left;">// can mutate both</td>
</tr>
</tbody>
</table>
<p>source: <a
href="https://stackoverflow.com/questions/28587698/whats-the-difference-between-placing-mut-before-a-variable-name-and-after-the#29682542">What’s
the difference between placing “mut” before a variable name and after
the “:”?</a></p>
<h2 id="input-output">Input-output:</h2>
<h3 id="getting-data-from-the-cli-arguments">Getting data from the CLI
arguments</h3>
<h3 id="undestanding-the-display-trait">Undestanding the Display
trait</h3>
<h2 id="processing-2">Processing</h2>
<h3 id="implementing-an-iterator">Implementing an Iterator</h3>
<h3 id="hangman-using-chars">hangman using Chars()</h3>
<h1 id="level-04">Level 04</h1>
<h3 id="lets-play-with">Let’s play with</h3>
<h4 id="user-input-from-the-console-without-the-newline">user input from
the console without the newline</h4>
<p>Note: When using <code>print!()</code> keep in mind that stdout is
frequently line-buffered by default so it may be necessary to use
<code>io::stdout().flush()</code> to ensure the output is emitted
immediately.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> main() <span class="op">{</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">use</span> <span class="pp">std::io::</span><span class="op">{</span>stdin<span class="op">,</span>stdout<span class="op">,</span><span class="bu">Write</span><span class="op">};</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="pp">print!</span>(<span class="st">&quot;Please enter some text: &quot;</span>)<span class="op">;</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    stdout()<span class="op">.</span>flush()<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="kw">mut</span> s <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>new()<span class="op">;</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    stdin()</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>read_line(<span class="op">&amp;</span><span class="kw">mut</span> s)</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">.</span>expect(<span class="st">&quot;Failed to read the line&quot;</span>)<span class="op">;</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">let</span> <span class="cn">Some</span>(<span class="ch">&#39;</span><span class="sc">\n</span><span class="ch">&#39;</span>)<span class="op">=</span>s<span class="op">.</span>chars()<span class="op">.</span>next_back() <span class="op">{</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>pop()<span class="op">;</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// windows has \r too</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">let</span> <span class="cn">Some</span>(<span class="ch">&#39;</span><span class="sc">\r</span><span class="ch">&#39;</span>)<span class="op">=</span>s<span class="op">.</span>chars()<span class="op">.</span>next_back() <span class="op">{</span></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>        s<span class="op">.</span>pop()<span class="op">;</span></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;You typed: {}&quot;</span><span class="op">,</span>s)<span class="op">;</span></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>see also:<br />
<a
href="https://doc.rust-lang.org/std/macro.print.html">std::print</a><br />
<a
href="https://doc.rust-lang.org/std/io/trait.Write.html#tymethod.flush">std::io::Write::flush</a></p>
<h3 id="benchmarking">Benchmarking</h3>
<p>see also : <a
href="https://www.youtube.com/watch?v=3iC3FVS6UXQ">Should you use
to_string() or .to_owned?</a>{target= “_blank”}</p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);


let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `
<div class="hover-nav">
<ul>
<li><a href="../../../index.html">⇦ home</a></li>
<li><a href="../../index.html">lerina</a></li>
<li><a href="./index.html">rust and friends</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
</body>
</html>
